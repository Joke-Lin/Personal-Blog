<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WEIJUN LIN BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://weijun-lin.top/"/>
  <updated>2021-06-02T16:00:00.000Z</updated>
  <id>https://weijun-lin.top/</id>
  
  <author>
    <name>Weijun-Lin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三维重建算法综述-张彦雯 小结</title>
    <link href="https://weijun-lin.top/2021/06/03/2021-06-03-%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0_%E5%BC%A0%E5%BD%A6%E9%9B%AF/"/>
    <id>https://weijun-lin.top/2021/06/03/2021-06-03-%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0_%E5%BC%A0%E5%BD%A6%E9%9B%AF/</id>
    <published>2021-06-02T16:00:00.000Z</published>
    <updated>2021-06-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关键词：三维重建；图像；稀疏点云重建（SFM）；稠密点云重建（MVS）；评价指标</p><p><a href="%5Bnxdxb.cnjournals.org/ch/reader/download_pdf.aspx?file_no=20200509&amp;year_id=2020&amp;quarter_id=5&amp;falg=1%5D(http://nxdxb.cnjournals.org/ch/reader/download_pdf.aspx?file_no=20200509&amp;year_id=2020&amp;quarter_id=5&amp;falg=1)">下载链接</a></p></blockquote><p>获取三维模型主要通过以下三种方式：</p><ol type="1"><li><p>传统的几何建模技术</p><p>最为成熟，但周期长，操作复杂</p></li><li><p><strong>基于图像的三维重建</strong></p><p>基于多幅不同角度拍摄的图像，运用计算机视觉理论进行三维建模；也有基于单幅图像的，但不能用于大规模场景</p></li><li><p>基于点云的三维重建</p><p>利用三维扫描设备对目标进行扫描，以重建模型</p></li></ol><p>文章主要介绍基于多幅图像的三维重建算法，主要包括稀疏点云重建（Structure From Motion，SFM）；稠密点云重建（Multi-View System，MVS）。其中 SFM 包括特征点检测与匹配（SIFT，SURF，FAST等）以及 SFM 重构两个部分。</p><p>SFM 重构大致分为三类：<strong>增量式重构、全局式重构、混合式重构</strong>。在 MVS 中，<strong>深度图</strong>的计算尤为重要。</p><a id="more"></a><h2 id="稀疏点云重建-sfm">稀疏点云重建 SFM</h2><p>SFM 通过相机的移动确定目标的空间和几何关系，特征点匹配后运用 SFM 重构算法，恢复出相机的参数，相机之间的相对位置关系以及场景的稀疏点云，最后捆绑调整优化相机位姿、相机参数、场景结构。</p><p>流程总结为：特征点检测、匹配，相机位姿（旋转矩阵 R，平移矩阵 T）初始值的求解，捆绑调整优化相机位姿、相机参数、场景结构。</p><figure><img src="/assets/ArticleImg/2021/三维重建算法研究综述_张彦雯.assets/image-20210603112341838.png" alt="image-20210603112341838" /><figcaption aria-hidden="true">image-20210603112341838</figcaption></figure><p>SFM 重构为利用相机运动轨迹来估算相机参数，初步匹配生成的的特征点比较粗糙，所以常用几何约束删除匹配错误的特征点对。SFM 重构主要有<strong>增量式和全局式</strong>。</p><p><strong>增量式重构</strong>是从两张图像中恢复相机的旋转矩阵 R 和平移矩阵 T，然后添加图像，利用PnP 计算出第三幅图像的 R、T，通过三角化重建出更多的场景。噪声的干扰会造成结果漂移，所以需要使用 BA（Bundle Adjustment，光束法平差）。每次添加图像完成三角化后都需要进行优化。</p><p>步骤为：初始化、PnP 解算，三角化，BA 算法优化。重要的步骤为 PnP 求解相机位姿，主要有 P3P，EPnP，DLT，UPnP，MRE。</p><p><strong>PnP</strong>：已知 n 个三维空间点坐标（相对于某个指定的坐标系A）及其二维投影位置的情况下，如何估计相机的位姿（即相机在坐标系A下的姿态）</p><p>增量式在对大规模场景重建时由于误差累积会造成场景漂移以及反复地捆绑调整花费大量时间。</p><p><strong>全局式重构</strong>采用的是将相机相对位姿均匀分布的方法，该方法在处 理大规模重建时，相机之间的相关性不同，会导致重 建效果差。</p><p><strong>混合式重构</strong>就是把前两者进行融合。</p><h2 id="稠密点云重建-mvs">稠密点云重建 MVS</h2><p>SFM 重建比较稀疏，需要 MVS 进行完善，MVS 的目的是通过最佳方法对不同图像上的同一个点进行匹配，增强重建场景的稠密性。MVS 的主要任务是通过一种最佳搜索的方法，匹配不同图像上的同一个点。也就是在极线上进行探测，寻找两张图片上的同一点，主要方法为逐像素判断，由此提出了一致性度量函数。</p><p>深度图是指将相机到场景中各点距离作为像素值的图像，是 MVS 的一大重点。主要方法如下：</p><ol type="1"><li>几何法<ul><li>Plane-Sweeping</li><li>PatchMatch</li></ul></li><li>几何与深度学习相结合的方法<ul><li>双通道法</li><li>DeepMVS</li></ul></li><li>基于深度学习的方法<ul><li>MVSNet</li><li>PointMVSNet</li></ul></li></ol><figure><img src="/assets/ArticleImg/2021/三维重建算法研究综述_张彦雯.assets/image-20210603195114007.png" alt="image-20210603195114007" /><figcaption aria-hidden="true">image-20210603195114007</figcaption></figure><h2 id="评价指标">评价指标</h2><p>分为有真实模型和无真实模型两类。</p><p>无真实模型的评价是通过对比输入数据与重建之后的数据一致性程度来实施的，其方法有<strong>重建误差法，积分误差法</strong>。</p><p>有真实模型的评价通过重建之后的模型与真实模型进行对比来实施，主要有<strong>形状误差法，分解法，相位矩不变量法，多指标评价法</strong>等。</p><p>这些算法都有缺陷：</p><ol type="1"><li>部分算法只能分析真实模型的场景</li><li>部分算法只能测量重建的精度，但是不能测量完整性，导致评价的结果存在偏差</li><li>大多算法只考虑到几何精度，并没有将纹理模型的视觉精度添加到评价指标中，在某些需要视觉精度的场景中应用意义不大。</li></ol><h2 id="总结">总结</h2><p>基于图像的三维重建不需要精密的测量一起，成本低，同时该方法计算出了相机的内外参数，使得重建效果更为精确，具有快速、简便、逼真的优点，能较好地实现现实事物的虚拟化，但仍然存在一些缺点：</p><ol type="1"><li>物体细节特征不理想</li><li>不能用于实时变化的场景</li><li>将场景中的物体变成二维对象，用于难获得需要的信息</li><li>对照相机和摄影设备有一定要求</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关键词：三维重建；图像；稀疏点云重建（SFM）；稠密点云重建（MVS）；评价指标&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;%5Bnxdxb.cnjournals.org/ch/reader/download_pdf.aspx?file_no=20200509&amp;amp;year_id=2020&amp;amp;quarter_id=5&amp;amp;falg=1%5D(http://nxdxb.cnjournals.org/ch/reader/download_pdf.aspx?file_no=20200509&amp;amp;year_id=2020&amp;amp;quarter_id=5&amp;amp;falg=1)&quot;&gt;下载链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;获取三维模型主要通过以下三种方式：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;传统的几何建模技术&lt;/p&gt;
&lt;p&gt;最为成熟，但周期长，操作复杂&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;基于图像的三维重建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于多幅不同角度拍摄的图像，运用计算机视觉理论进行三维建模；也有基于单幅图像的，但不能用于大规模场景&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于点云的三维重建&lt;/p&gt;
&lt;p&gt;利用三维扫描设备对目标进行扫描，以重建模型&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;文章主要介绍基于多幅图像的三维重建算法，主要包括稀疏点云重建（Structure From Motion，SFM）；稠密点云重建（Multi-View System，MVS）。其中 SFM 包括特征点检测与匹配（SIFT，SURF，FAST等）以及 SFM 重构两个部分。&lt;/p&gt;
&lt;p&gt;SFM 重构大致分为三类：&lt;strong&gt;增量式重构、全局式重构、混合式重构&lt;/strong&gt;。在 MVS 中，&lt;strong&gt;深度图&lt;/strong&gt;的计算尤为重要。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="CV&amp;CG&amp;DIP" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/"/>
    
      <category term="CV" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/CV/"/>
    
    
      <category term="三维重建" scheme="https://weijun-lin.top/tags/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/"/>
    
      <category term="SFM" scheme="https://weijun-lin.top/tags/SFM/"/>
    
      <category term="MVS" scheme="https://weijun-lin.top/tags/MVS/"/>
    
  </entry>
  
  <entry>
    <title>图像的前向和后向映射</title>
    <link href="https://weijun-lin.top/2021/02/16/2021-02-16-Forward-BackwardMapping/"/>
    <id>https://weijun-lin.top/2021/02/16/2021-02-16-Forward-BackwardMapping/</id>
    <published>2021-02-15T16:00:00.000Z</published>
    <updated>2021-02-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>图像变换中总是伴随着映射，原图中的点到新图中的点之间的映射。从原图映射到新图上，由于坐标的不连续，就有新图上某点的像素确定的问题。也就是像素坐标是整数，但是映射之后的坐标不一定是整数，就需要确定它周围的坐标的像素值。图像像素的映射有前向映射和后向映射。</p><p>后向映射比较好理解，新图映射到原图上某点，然后通过它周围的像素确定这个点的像素值，一般可以有最邻近，双线性，双三次插值等。双线性比较简单且好用。</p><p>前向映射到新图中的浮点数位置，直接取整会有空洞产生，一种合适的方法就是按双线性的思路，把这个点的像素按权值分配到四个周围整数点。直接这样累加会导致像素重叠，所以还需要最后对分配到某个像素的所有像素值及其对应权值归一化。</p><a id="more"></a><p>详细可参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsb3J5ZHJlYW0yMDE1L2FydGljbGUvZGV0YWlscy80NDg3MzcwMw==">图像变换——向前映射和向后映射_薇洛的打火机-CSDN博客<i class="fa fa-external-link-alt"></i></span></p><h2 id="代码实现">代码实现</h2><p>这里给出了完整的 matlab 代码实现，根据实验结果可以知道，这里的前向映射耗费的时间比后向大，计算过程比较复杂，但在某些场景下，前向仍然会比后向方便，所以在此记录：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;./test.JPG&#x27;</span>;</span><br><span class="line">img = double(imread(filename));</span><br><span class="line"><span class="comment">% 旋转的角度</span></span><br><span class="line">theta = <span class="number">0.67</span>*<span class="built_in">pi</span>;</span><br><span class="line"><span class="comment">% 绕原点旋转矩阵</span></span><br><span class="line">T1 = [<span class="built_in">cos</span>(theta) <span class="built_in">sin</span>(theta) <span class="number">0</span>;</span><br><span class="line">      -<span class="built_in">sin</span>(theta) <span class="built_in">cos</span>(theta) <span class="number">0</span>;</span><br><span class="line">      <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">imgsize = <span class="built_in">size</span>(img);</span><br><span class="line">w = imgsize(<span class="number">2</span>);</span><br><span class="line">h = imgsize(<span class="number">1</span>);</span><br><span class="line"><span class="comment">% matlab 坐标从 1 开始有点烦</span></span><br><span class="line">bound = [<span class="number">1</span> <span class="number">1</span>+w <span class="number">1</span>+w <span class="number">1</span>;</span><br><span class="line">         <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>+h <span class="number">1</span>+h;</span><br><span class="line">         <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">%  获取变换后图片的大小和左上角顶点在原坐标系的坐标</span></span><br><span class="line">boundWarp = T1 * bound;</span><br><span class="line"><span class="comment">% 正无穷方向取整,避免越界,这里加1稳妥一点</span></span><br><span class="line">newW = <span class="built_in">ceil</span>(<span class="built_in">max</span>(boundWarp(<span class="number">1</span>,:)) - <span class="built_in">min</span>(boundWarp(<span class="number">1</span>,:))) + <span class="number">1</span>;</span><br><span class="line">newH = <span class="built_in">ceil</span>(<span class="built_in">max</span>(boundWarp(<span class="number">2</span>,:)) - <span class="built_in">min</span>(boundWarp(<span class="number">2</span>,:))) + <span class="number">1</span>;</span><br><span class="line">vex = [<span class="built_in">min</span>(boundWarp(<span class="number">1</span>,:)) <span class="built_in">min</span>(boundWarp(<span class="number">2</span>,:))];</span><br><span class="line"><span class="comment">% 平移到新图坐标系的矩阵为</span></span><br><span class="line">T2 = [<span class="number">1</span> <span class="number">0</span> -vex(<span class="number">1</span>)+<span class="number">1</span>;<span class="number">0</span> <span class="number">1</span> -vex(<span class="number">2</span>)+<span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 最后的变换为</span></span><br><span class="line">T = T2*T1;</span><br><span class="line"><span class="comment">% 变换后的图片矩阵</span></span><br><span class="line">imgsize2 = imgsize;</span><br><span class="line">imgsize2([<span class="number">1</span> <span class="number">2</span>]) = [newH newW];</span><br><span class="line"><span class="comment">% 上面这样利于单通道/多通道的情况</span></span><br><span class="line">img2 = <span class="built_in">zeros</span>(imgsize2);</span><br><span class="line">img3 = img2;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 前向映射</span></span><br><span class="line">tic</span><br><span class="line"><span class="comment">% tempTrans(i,j) 为矩阵,存储分配到这个像素的原图像素值以及其权值</span></span><br><span class="line"><span class="comment">% 用于记录每一个点所分配的权重</span></span><br><span class="line">tempTrans = cell(imgsize2([<span class="number">1</span> <span class="number">2</span>]));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:imgsize(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:imgsize(<span class="number">2</span>)</span><br><span class="line">        coord = T*[<span class="built_in">j</span>;<span class="built_in">i</span>;<span class="number">1</span>];</span><br><span class="line">        x = coord(<span class="number">1</span>); y = coord(<span class="number">2</span>);</span><br><span class="line">        s = <span class="built_in">fix</span>(coord(<span class="number">1</span>)); t = <span class="built_in">fix</span>(coord(<span class="number">2</span>));</span><br><span class="line">        k = [s+<span class="number">1</span>-x x-s t+<span class="number">1</span>-y y-t];</span><br><span class="line">        p = img(<span class="built_in">i</span>,<span class="built_in">j</span>,:); p = p(:);</span><br><span class="line">        <span class="comment">% 双线性插值的方法分配</span></span><br><span class="line">        tempTrans&#123;t, s&#125;(:, <span class="keyword">end</span>+<span class="number">1</span>) = [p;k(<span class="number">1</span>)*k(<span class="number">3</span>)];</span><br><span class="line">        tempTrans&#123;t, s+<span class="number">1</span>&#125;(:, <span class="keyword">end</span>+<span class="number">1</span>) = [p;k(<span class="number">2</span>)*k(<span class="number">3</span>)];</span><br><span class="line">        tempTrans&#123;t+<span class="number">1</span>, s&#125;(:, <span class="keyword">end</span>+<span class="number">1</span>) = [p;k(<span class="number">1</span>)*k(<span class="number">4</span>)];</span><br><span class="line">        tempTrans&#123;t+<span class="number">1</span>, s+<span class="number">1</span>&#125;(:, <span class="keyword">end</span>+<span class="number">1</span>) = [p;k(<span class="number">2</span>)*k(<span class="number">4</span>)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 归一化,否则会造成某些地方很突兀(叠加)</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:imgsize2(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:imgsize2(<span class="number">2</span>)</span><br><span class="line">        temp = tempTrans&#123;<span class="built_in">i</span>,<span class="built_in">j</span>&#125;;</span><br><span class="line">        len = <span class="built_in">size</span>(temp,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> len == <span class="number">0</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">% 归一化数据,也就是重新分配权值</span></span><br><span class="line">        sum_w = sum(temp(<span class="keyword">end</span>,:));</span><br><span class="line">        <span class="keyword">for</span> k = <span class="number">1</span>:len</span><br><span class="line">            img2(<span class="built_in">i</span>,<span class="built_in">j</span>,:) = img2(<span class="built_in">i</span>,<span class="built_in">j</span>,:) + <span class="built_in">reshape</span>(temp(<span class="keyword">end</span>, k)/sum_w * temp(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>,k), <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fprintf(<span class="string">&quot;前向映射耗费的总时间:&quot;</span>);</span><br><span class="line">toc</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">imshow(uint8(img2));</span><br><span class="line">title(<span class="string">&quot;Forward Mapping&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 后向映射</span></span><br><span class="line">tic</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:imgsize2(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:imgsize2(<span class="number">2</span>)</span><br><span class="line">        <span class="comment">% 逆映射回去,得到坐标</span></span><br><span class="line">        coord = T\[<span class="built_in">j</span>;<span class="built_in">i</span>;<span class="number">1</span>];</span><br><span class="line">        img3(<span class="built_in">i</span>, <span class="built_in">j</span>, :) = backward(img, coord);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fprintf(<span class="string">&quot;后向映射耗费的总时间:&quot;</span>);</span><br><span class="line">toc</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">imshow(uint8(img3));</span><br><span class="line">title(<span class="string">&quot;Backward Mapping&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 后向映射到原图,获取对应的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pixel_value</span> = <span class="title">backward</span><span class="params">(srcimg, srccoord)</span></span></span><br><span class="line">    x = srccoord(<span class="number">1</span>);</span><br><span class="line">    y = srccoord(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">% 不再原图上的点返回黑色</span></span><br><span class="line">    pixel_value = <span class="number">0</span>;</span><br><span class="line">    [r, c, ~] = <span class="built_in">size</span>(srcimg);</span><br><span class="line">    <span class="comment">% 坐标在图像外的返回 0 </span></span><br><span class="line">    <span class="keyword">if</span> x &gt; c || y &gt; r || x &lt; <span class="number">1</span> || y &lt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 现在坐标已经在图像内部、或者边界，然后处理边界（图像右和下）避免插值时数组边界访问异常</span></span><br><span class="line">    <span class="keyword">if</span> x == c || y == r</span><br><span class="line">        pixel_value = srcimg(x, y, :);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 此时依据四个点做双线性插值 首先对坐标向零取整</span></span><br><span class="line">    s = <span class="built_in">fix</span>(srccoord(<span class="number">1</span>));</span><br><span class="line">    t = <span class="built_in">fix</span>(srccoord(<span class="number">2</span>));</span><br><span class="line">    k = [s+<span class="number">1</span>-x x-s t+<span class="number">1</span>-y y-t];</span><br><span class="line">    pixel_value = k(<span class="number">1</span>)*k(<span class="number">3</span>)*srcimg(t,s,:) + k(<span class="number">2</span>)*k(<span class="number">3</span>)*srcimg(t, s+<span class="number">1</span>,:) +  ...</span><br><span class="line">                  k(<span class="number">1</span>)*k(<span class="number">4</span>)*srcimg(t+<span class="number">1</span>,s,:) + k(<span class="number">2</span>)*k(<span class="number">4</span>)*srcimg(t+<span class="number">1</span>,s+<span class="number">1</span>,:);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>原图为：</p><p><img src="/assets/ArticleImg/2021/forward-backward-maping.jpg" /></p><p>实现结果如下：</p><p><img src="/assets/ArticleImg/2021/forward-backward-maping2.jpg" /></p><p>代码输出：</p><p>前向映射耗费的总时间:历时 12.063921 秒。 后向映射耗费的总时间:历时 4.419853 秒。</p><h2 id="补存在的问题">【补】存在的问题</h2><p>这样子看起来效果比较好，但是当加入缩放因子时，前向映射仍然会产生空隙，因为这里双线性只将映射到浮点位置的像素分配到四个周围像素。但是，当缩放加入后，会有的像素映射不到，解决办法就是增加分配的核大小，由原来的 2*2 改为更大，但不能有一个通用的方法。所以，一般还是使用后向映射。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图像变换中总是伴随着映射，原图中的点到新图中的点之间的映射。从原图映射到新图上，由于坐标的不连续，就有新图上某点的像素确定的问题。也就是像素坐标是整数，但是映射之后的坐标不一定是整数，就需要确定它周围的坐标的像素值。图像像素的映射有前向映射和后向映射。&lt;/p&gt;
&lt;p&gt;后向映射比较好理解，新图映射到原图上某点，然后通过它周围的像素确定这个点的像素值，一般可以有最邻近，双线性，双三次插值等。双线性比较简单且好用。&lt;/p&gt;
&lt;p&gt;前向映射到新图中的浮点数位置，直接取整会有空洞产生，一种合适的方法就是按双线性的思路，把这个点的像素按权值分配到四个周围整数点。直接这样累加会导致像素重叠，所以还需要最后对分配到某个像素的所有像素值及其对应权值归一化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="CV&amp;CG&amp;DIP" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/"/>
    
      <category term="CV" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/CV/"/>
    
    
      <category term="matltb" scheme="https://weijun-lin.top/tags/matltb/"/>
    
  </entry>
  
  <entry>
    <title>Matlab ransac 库函数介绍</title>
    <link href="https://weijun-lin.top/2021/01/25/2021-01-25-RANSAC-MATLAB/"/>
    <id>https://weijun-lin.top/2021/01/25/2021-01-25-RANSAC-MATLAB/</id>
    <published>2021-01-24T16:00:00.000Z</published>
    <updated>2021-01-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>matlab 自带了 ransac 函数，这里总结一下用法。matlab 自带的这个函数其实是 MSAC（M-estimator sample consensus）算法，但其实差不多，它对给定数据集，以及自定的模型计算函数和误差计算函数返回具有最大内点的模型。</p><a id="more"></a><h2 id="函数声明">函数声明</h2><p>从 ransac 函数的源文件介绍中截取一段：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%RANSAC Fit a model to noisy data. </span></span><br><span class="line"><span class="comment">%   [model, inlierIdx] = RANSAC(data, fitFcn, distFcn, sampleSize, maxDistance) </span></span><br><span class="line"><span class="comment">%   fits a model to noisy data using the M-estimator SAmple Consensus </span></span><br><span class="line"><span class="comment">%   (MSAC) algorithm, a version of RAndom SAmple Consensus algorithm.</span></span><br><span class="line"><span class="comment">%   </span></span><br><span class="line"><span class="comment">%   Inputs      Description </span></span><br><span class="line"><span class="comment">%   ------      -----------</span></span><br><span class="line"><span class="comment">%   data        An M-by-N matrix, whose rows are data points to be modeled.</span></span><br><span class="line"><span class="comment">%               For example, for fitting a line to 2-D points, data would be an </span></span><br><span class="line"><span class="comment">%               M-by-2 matrix of [x,y] coordinates. For fitting a geometric </span></span><br><span class="line"><span class="comment">%               transformation between two sets of matched 2-D points, </span></span><br><span class="line"><span class="comment">%               the coordinates can be concatenated into an M-by-4 matrix.</span></span><br><span class="line"><span class="comment">%   </span></span><br><span class="line"><span class="comment">%   fitFcn      A handle to a function, which fits the model to a minimal</span></span><br><span class="line"><span class="comment">%               subset of data. The function must be of the form </span></span><br><span class="line"><span class="comment">%                 model = fitFcn(data)</span></span><br><span class="line"><span class="comment">%               model returned by fitFcn can be a cell array, if it is</span></span><br><span class="line"><span class="comment">%               possible to fit multiple models to the data. </span></span><br><span class="line"><span class="comment">%  </span></span><br><span class="line"><span class="comment">%   distFcn     A handle to a function, which computes the distances from the</span></span><br><span class="line"><span class="comment">%               model to the data. The function must be of the form</span></span><br><span class="line"><span class="comment">%                 distances = distFcn(model, data)</span></span><br><span class="line"><span class="comment">%               If model is an N-element cell array, then distances must be an </span></span><br><span class="line"><span class="comment">%               M-by-N matrix. Otherwise, distances must be an M-by-1 vector.</span></span><br><span class="line"><span class="comment">%  </span></span><br><span class="line"><span class="comment">%   sampleSize  Positive numeric scalar containing the minimum size of a </span></span><br><span class="line"><span class="comment">%               sample from data required by fitFcn to fit a model.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   maxDistance Positive numeric scalar specifying the distance threshold </span></span><br><span class="line"><span class="comment">%               for finding outliers. Increasing this value will make the </span></span><br><span class="line"><span class="comment">%               algorithm converge faster, but may adversely affect the </span></span><br><span class="line"><span class="comment">%               accuracy of the result.</span></span><br><span class="line"><span class="comment">%  </span></span><br><span class="line"><span class="comment">%   Outputs     Description</span></span><br><span class="line"><span class="comment">%   -------     -----------</span></span><br><span class="line"><span class="comment">%   model       The model, which best fits the data.</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">%   inlierIdx   An M-by-1 logical array, specifying which data points are </span></span><br><span class="line"><span class="comment">%               inliers.</span></span><br></pre></td></tr></table></figure><p>Matlab 官网介绍：<span class="exturl" data-url="aHR0cHM6Ly93dzIubWF0aHdvcmtzLmNuL2hlbHAvdmlzaW9uL3JlZi9yYW5zYWMuaHRtbA==">Fit model to noisy data - MATLAB ransac - MathWorks 中国<i class="fa fa-external-link-alt"></i></span></p><p>这里已经讲的比较清楚了，函数接收五个参数，两个返回值</p><h3 id="参数">参数</h3><ul><li><em>data</em>：一行为一个数据的数据集</li><li><em>fitFcn</em>：计算模型的<strong>函数句柄</strong>，比如匿名函数或者一般函数前面加 @ 符号</li><li><em>distFcn</em>：同样是函数句柄，它返回每一个数据对模型的误差，接收参数为数据以及 <em>fitFcn</em> 计算出的模型</li><li><em>sampleSize</em>：随机选取数据点的个数，通过这几个数据作为 <em>fitFcn</em> 的输入参数</li><li><em>maxDistance</em>：认为是模型到数据的可接受误差，小于这个的都认为是内点，越大函数执行的速度越快</li></ul><h3 id="返回值">返回值</h3><ul><li><em>model</em>：得出的模型</li><li><em>inlierIdx</em>：一个和 <em>data</em> 相同行数的逻辑矩阵，代表最后符合此模型的内点</li></ul><h2 id="使用例子">使用例子</h2><p>官网给出了个例子，用的是匿名函数和一些库函数计算直线，这里用自己的函数实现官网的例子。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">clear;clc;</span><br><span class="line"><span class="comment">% 自带的数据 </span></span><br><span class="line">load pointsForLineFitting.mat</span><br><span class="line">data = points;</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(data(:,<span class="number">1</span>), data(:,<span class="number">2</span>), <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">axis equal</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line">sampleSize = <span class="number">2</span>;</span><br><span class="line">maxDistance = <span class="number">1</span>;</span><br><span class="line">[model, inlierIdx] = ransac(data, @fitFcn, @distFcn, sampleSize, maxDistance);</span><br><span class="line"><span class="comment">% 绘制内点</span></span><br><span class="line">inlier = data(inlierIdx, :);</span><br><span class="line"><span class="built_in">plot</span>(inlier(:,<span class="number">1</span>), inlier(:,<span class="number">2</span>), <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">x = [<span class="built_in">min</span>(data(:,<span class="number">1</span>)), <span class="built_in">max</span>(data(:, <span class="number">1</span>))];</span><br><span class="line">y = model(<span class="number">1</span>)*x + model(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;g--&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"></span><br><span class="line"><span class="comment">% 这里的模型就是算直线的 k 和 b ，y = kx+b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">model</span> = <span class="title">fitFcn</span><span class="params">(data)</span></span></span><br><span class="line">    x = data(:,<span class="number">1</span>);</span><br><span class="line">    y = data(:,<span class="number">2</span>);</span><br><span class="line">    k = (y(<span class="number">1</span>) - y(<span class="number">2</span>))/(x(<span class="number">1</span>) - x(<span class="number">2</span>));</span><br><span class="line">    b = -k*x(<span class="number">2</span>) + y(<span class="number">2</span>);</span><br><span class="line">    model = [k, b];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 就是算 (y - y&#x27;)^2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distances</span>  = <span class="title">distFcn</span><span class="params">(model, data)</span></span></span><br><span class="line">    k = model(<span class="number">1</span>);</span><br><span class="line">    b = model(<span class="number">2</span>);</span><br><span class="line">    distances  = (data(:,<span class="number">2</span>) - (k*data(:,<span class="number">1</span>) + b)).^<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="/assets/ArticleImg/2021/ransac-matlab.png" /></p><p>其中圆点表示数据，橘色代表最后的内点，直线为最后得到的模型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;matlab 自带了 ransac 函数，这里总结一下用法。matlab 自带的这个函数其实是 MSAC（M-estimator sample consensus）算法，但其实差不多，它对给定数据集，以及自定的模型计算函数和误差计算函数返回具有最大内点的模型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="CV&amp;CG&amp;DIP" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/"/>
    
      <category term="CV" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/CV/"/>
    
    
      <category term="matlab" scheme="https://weijun-lin.top/tags/matlab/"/>
    
      <category term="RANSAC" scheme="https://weijun-lin.top/tags/RANSAC/"/>
    
  </entry>
  
  <entry>
    <title>As-Projective-As-Possible Image Stitching with Moving DLT</title>
    <link href="https://weijun-lin.top/2021/01/18/2021-01-14-APAP/"/>
    <id>https://weijun-lin.top/2021/01/18/2021-01-14-APAP/</id>
    <published>2021-01-17T16:00:00.000Z</published>
    <updated>2021-01-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<span class="exturl" data-url="aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL2RvY3VtZW50LzY2MTkxNDc=">As-Projective-As-Possible Image Stitching with Moving DLT<i class="fa fa-external-link-alt"></i></span></p><p>这里主要对文章的 Moving DLT 做介绍，其它关于图像拼接的细节就不描述了，文章的重点就在使用 Moving DLT 来模拟一个复杂映射</p></blockquote><p><strong>摘要</strong>：图像拼接的商用化给我们带来了这个问题已经被解决的错误印象。实际上，在某些严厉的成像条件上，这些结果都不能够使人信服，除非在<strong>只有视角旋转变化或者场景为平面</strong>的条件下。在这些约束下，可以使用二维射影变换或者单应来对齐图片。在一般情况下，这种条件经常被打破，造成错误的对齐或者鬼影。现在这些拼接技术依赖于后处理方法来消除或减轻鬼影。在这篇文章中，提出一种不同的估计技术，名为 “移动直接线性变换 (Moving DLT)”，可以优化射影变换使得其适应输入数据和理想条件的偏差。这生成了一种 <em>尽可能投影的</em> 的图像对齐方法，有效的减少了鬼影并且不损害透视图象拼接的几何写实性。此外，还描述了如何将这种对齐方法使用到多幅图像的大全景图生成中，通过将光束法平差（Bundle Adjustment）同时用于优化以达到准确地对齐。</p><p><strong>关键词</strong>：图像拼接，图像对齐，射影变换，直接线性变换，移动最小二乘法</p><a id="more"></a><h2 id="介绍">介绍</h2><p>文章的介绍部分主要谈到了当前图像拼接算法模型的不足，使用单应变换来实现图像对齐。但<a href="https://weijun-lin.top/2021/01/14/2021-01-14-HomographyLimits/">单应变换有着自身的局限性</a>，只适用于视角仅旋转变换和目标场景为平面两种情况。当违反这两个条件后，会造成鬼影并且错误的对齐。为此，提出了一个名为“移动DLT”的估计技术，可以优化全局单应变换带来的误差。其它技术带来的鬼影等不良影响虽然可以通过后期技术优化，但是作者认为在对齐阶段就消除是很有必要的。</p><h2 id="尽可能射影的变换-apap">尽可能射影的变换 APAP</h2><h3 id="二维射影变换dlt">二维射影变换（DLT）</h3><p>令 <span class="math inline">\(\textbf{x} = [x,y]^T,\textbf{x}&#39;= [x&#39;,y&#39;]^T\)</span>，为两幅具有重叠部分图像 <span class="math inline">\(I,I&#39;\)</span> 上的对应点，它们之间的关系为： <span class="math display">\[\widetilde {\textbf{x}}&#39; \sim \textbf{H} \widetilde {\textbf{x}}\]</span> 字符上的波浪线代表着齐次坐标归一化。也就是说将 <span class="math inline">\(\widetilde {\textbf{x}}\)</span> 通过单应矩阵变换后还需要齐次坐标归一化，也就是除第三个分量。其中 <span class="math inline">\(3\times 3\)</span> 的矩阵 <span class="math inline">\(\textbf{H}\)</span> 为单应矩阵，上面的等式展开后有： <span class="math display">\[\begin{align}x&#39; = \frac{r_1[x,y,1]^T}{r_3[x,y,1]^T} \\y&#39; = \frac{r_2[x,y,1]^T}{r_3[x,y,1]^T}\end{align}\]</span> 其中 <span class="math inline">\(r_j\)</span> 表示矩阵 <span class="math inline">\(\textbf{H}\)</span> 的第 j 行。齐次坐标需要除以第三个分量使得它不是一个线性变换，直接线性变换（DLT）是一种在含有噪声的匹配点中估计单应矩阵的基础方法。首先，因为 <span class="math inline">\(\widetilde {\textbf{x}}&#39; \sim \textbf{H} \widetilde {\textbf{x}}\)</span> 有 <span class="math inline">\(\textbf{0}_{3\times 1} = \widetilde {\textbf{x}}&#39; \times \textbf{H}\widetilde {\textbf{x}}\)</span> ，这个式子可以化为： <span class="math display">\[\begin{align}\textbf{0}_{3\times 1} &amp;= \left[\begin{matrix}\textbf{0}_{1\times 3} &amp; -\widetilde{\textbf{x}}^T &amp; y&#39;\widetilde {\textbf{x}}^T\\\widetilde {\textbf{x}}^T &amp; \textbf{0}_{1\times 3} &amp; -x&#39;\widetilde {\textbf{x}}^T\\-y&#39;\widetilde {\textbf{x}}^T &amp; x&#39;\widetilde {\textbf{x}}^T &amp; \textbf{0}_{1\times 3}\end{matrix}\right]\times \textbf{h} \\\textbf{h} &amp;= \left[\begin{matrix}r_1^T \\r_2^T \\r_3^T\end{matrix}\right]\end{align}\]</span> <span class="math inline">\(\textbf{h}\)</span> 就是矩阵 <span class="math inline">\(\textbf{H}\)</span> 的向量表示，上面 3*9 的矩阵中，只有两行是线性无关的，所以对某一对对应点 <span class="math inline">\(\{\textbf{x}_i,\textbf{x}_i&#39;\}\)</span> 使用 <span class="math inline">\(\textbf{a}_i\)</span> 表示矩阵的前两行，对于需要估计的向量 <span class="math inline">\(\textbf{h}\)</span>，<span class="math inline">\(\vert\vert \textbf{a}_i \textbf{h}\vert\vert\)</span> 为第 i 个点的代数误差（因为理想情况下 <span class="math inline">\(a_ih\)</span> 为 0），所以 DLT 的目标就是将所有对应点的代数误差和做到最小，即： <span class="math display">\[\hat{\textbf{h}} = \mathop{argmin}_{\textbf{h}} \sum_{i=1}^{N}\vert\vert \textbf{a}_i \textbf{h}\vert\vert ^2 \qquad \text{s.t.} \vert\vert \textbf{h}\vert\vert = 1\]</span> 将所有的点累积起来还可以转变为矩阵的形式： <span class="math display">\[\hat{\textbf{h}} = \mathop{argmin}_{\textbf{h}}\vert\vert \textbf{A} \textbf{h}\vert\vert ^2 \qquad \text{s.t.} \vert\vert \textbf{h}\vert\vert = 1\]</span> 其中 <span class="math inline">\(\textbf{A} \in \mathbb{R}^{2N\times 9}\)</span>，这就是一个代数最小二乘问题，它的解是<strong>最小奇异值对应的右奇异向量</strong>。也就是说对于原图像 <span class="math inline">\(I\)</span> 中的任意一点 <span class="math inline">\(\textbf{x}_*\)</span>，它映射到对齐图像 <span class="math inline">\(I&#39;\)</span> 上的点为 <span class="math inline">\(\textbf{x}&#39;_*\)</span>，理想情况下，有以下关系成立： <span class="math display">\[\widetilde {\textbf{x}}_*&#39; \sim \textbf{H} \widetilde {\textbf{x}}_*\]</span> 前面已经提到了单应的局限性，DLT 算法适合在避免了单应局限性，并存在一些离群点（噪声）的情况下，获得最佳的单应映射。但是在一般成像下，一个<strong>全局的单应</strong>不足以拟合所有的点，也就是说会有很大一部分点不符合这个单应矩阵表示的映射。文章提供了一种使用单应模拟复杂映射（非纯单应）的方法，也就是下面要提到的<strong>移动 DLT</strong>。</p><p>在做 DLT 之前可以先将数据归一化可以避免很多数值上的错误，归一化可参考：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MjAyMzIwOA==">《CV中的多视图几何》——图像之间的单应变换 - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span>，其中也谈到了归一化后的反归一化。</p><h3 id="moving-dlt">Moving DLT</h3><p>Moving DLT 本质上就是使用局部单应拟合映射。此时的点 <span class="math inline">\(\textbf{x}_*,\textbf{x}_*&#39;\)</span> 满足下式： <span class="math display">\[\widetilde {\textbf{x}}_*&#39; \sim \textbf{H}_* \widetilde {\textbf{x}}_*\]</span> 这里的 <span class="math inline">\(\textbf{H}_*\)</span> 和点有关，也就是单应的局部表示。而 <span class="math inline">\(\textbf{H}_*\)</span> 则从下面的加权优化问题中得出： <span class="math display">\[\textbf{h}_* = \mathop{argmin}_{\textbf{h}} \sum_{i=1}^{N}\vert\vert w_*^i \textbf{a}_i \textbf{h}\vert\vert ^2 \qquad \text{s.t.} \vert\vert \textbf{h}\vert\vert = 1\]</span> 其中的 <span class="math inline">\(w_*^i\)</span> 是最关键的部分，它给了那些与 <span class="math inline">\(\textbf{x}_*\)</span> 相近的点更高的权重。可以使用高斯函数来确定： <span class="math display">\[w_*^i = \exp(-\vert\vert \textbf{x}_* - \textbf{x}_i \vert\vert^2/\sigma^2)\]</span> 自然的 <span class="math inline">\(\sigma\)</span> 表示尺度参数。和 <a href="/2021/01/07/2021-01-07-MLS/">WLS</a> 的权函数类似，只要符合权函数那几个定义即可。这差不多就是 Moving DLT 的定义了。就加了一个权函数。上式可以矩阵化为： <span class="math display">\[\textbf{h}_* = \mathop{argmin}_{\textbf{h}} \vert\vert \textbf{W}_* \textbf{A} \textbf{h}\vert\vert ^2 \qquad \text{s.t.} \vert\vert \textbf{h}\vert\vert = 1\]</span> 其中的 <span class="math inline">\(\textbf{W}_*\)</span> 为权重组成的对角矩阵： <span class="math display">\[\textbf{W}_* = \mathop{diag}([w_*^1 w_*^1 w_*^2 w_*^2 \cdots w_*^N w_*^N])\]</span> 每一个权重都出现两次是因为 <span class="math inline">\(\textbf{a}_i\)</span> 是一个 2 行的矩阵。矩阵化后就变成了一个加权 SVD（WSVD） 问题，它的解为 <span class="math inline">\(\textbf{W}_*\textbf{A}\)</span> 最小奇异值的右奇异向量。为了确保有界，对那些远离的点做一个补偿（正则化），当权值低于某个值时，将它设为预定的值，因为有些时候没有匹配点（不再图像的重叠区域内），这时那些有匹配点原理当前点，则会数据不足。所以改进后的权值表达如下： <span class="math display">\[w_*^i = \max(\exp(-\vert\vert \textbf{x}_* - \textbf{x}_i \vert\vert^2/\sigma^2), \gamma)\]</span> 概念上讲 Moving DLT 是 MLS（移动最小二乘）的单应变换版本。</p><h3 id="图像拼接的高效计算复杂度优化">图像拼接的高效计算（复杂度优化）</h3><h4 id="ransac-过滤离群点">RANSAC 过滤离群点</h4><p>数据一般都不会是理想的，总存在噪声或者错误匹配的点（离群值）。文章使用 RANSAC 来移除离群值来减少不必要的数据。RANSAC 还是使用的 DLT，这就使得一些正确匹配点（单应局限性造成）和这些离群值一样会在 RANSAC 中产生误差，但离群点的误差会比单应局限性造成的误差大，所以 RANSAC 还是可以有效的工作。</p><h4 id="划分网格">划分网格</h4><p>为每一个源图像中的点计算它的单应模型是没有必要的，因为相近的点的单应差别不大，所以讲图像均分为网格可以提高效率并且保证准确度。可以将原图像划分为 <span class="math inline">\(C_1\times C_2\)</span> 大小的网格，每一个网格的单应由它的中心点 <span class="math inline">\(\textbf{x}_*\)</span> 代表。这样会使得格子之间的单应变换不连续，因为使用离散的网格中心点导致权值不是连续变化。但作者在实验中认为只要分辨率足够高就不会有明显的不连续感。</p><h4 id="wsvd-更新">WSVD 更新</h4><p>在计算 Moving DLT 的时候每一次改变的只有权重矩阵，但是权重矩阵中大部分都是 <span class="math inline">\(\gamma\)</span>（因为里当前点远的点更多），现在考虑是否不用每次都重新计算当前点的 DLT，而是通过上一次的结果来更新。</p><p>首先考虑权重矩阵 <span class="math inline">\(\textbf{W}_\gamma = \gamma \textbf{I}\)</span>，令 <span class="math inline">\(\textbf{V}\)</span> 为矩阵 <span class="math inline">\(\textbf{W}_\gamma\textbf{A}\)</span> 右奇异向量，这个矩阵的特征值分解如下： <span class="math display">\[\textbf{A}^T\textbf{W}_\gamma^T  \textbf{W}_\gamma\textbf{A} = \textbf{V}\textbf{D}\textbf{V}^T\]</span> 令 <span class="math inline">\(\tilde {\textbf{W}}\)</span> 为 <span class="math inline">\(\textbf{W}_\gamma\)</span> 改变第 i 个对角元素得到的矩阵。对它进行特征值分解有： <span class="math display">\[\begin{align}\textbf{A}^T\tilde {\textbf{W}}^T  \tilde {\textbf{W}}\textbf{A} &amp;= \textbf{V}\textbf{D}\textbf{V}^T + \rho \textbf{r}_i \textbf{r}_i^T= \textbf{V}(\textbf{D} + \rho \overline{\textbf{r}}_i \overline{\textbf{r}}_i^T)\textbf{V}^T \\\rho &amp;= (\tilde{w}^2_i/\gamma^2 - 1)\end{align}\]</span> 其中 <span class="math inline">\(\textbf{r}_i\)</span> 为矩阵 <span class="math inline">\(\textbf{A}\)</span> 的第 i 行，<span class="math inline">\(\overline{\textbf{r}}_i = \textbf{V}^T\textbf{r}_i\)</span>。 <span class="math inline">\(\textbf{D} + \rho \textbf{r}_i \textbf{r}_i^T\)</span> 又可以特征值分解为 <span class="math inline">\(\tilde{\textbf{C}}\tilde{\textbf{D}}\tilde{\textbf{C}}^T\)</span>，这个可以使用特征方程得到。解特征方程可以使用相关方法加速。最后解为 <span class="math inline">\(\textbf{V}\tilde{\textbf{C}}\)</span>，这个称为 <strong>Rank-One Update</strong>，可参考<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNzc0MjcyOQ==">特征值分解（EVD）的rank 1 update - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span>。</p><p>参考图如下：</p><p><img src="/assets/ArticleImg/2021/APAP_1.png" /></p><p>其中 a 为原图，b 为将原图网格化，c 为将原图通过 Moving DLT 映射到待匹配平面的结果。</p><h2 id="同时优化">同时优化</h2><p>这里讲的是将 Moving DLT 用到多幅图像（大于三幅）同时拼接用于产生全景图时，产生的相关问题和解决方法。</p><p>这里就没有怎么了解了。</p><p>主要是<strong>拼接顺序的选择</strong>以及<strong>光束法平差优化（Bundle Adjustment）</strong>两个方面的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL2RvY3VtZW50LzY2MTkxNDc=&quot;&gt;As-Projective-As-Possible Image Stitching with Moving DLT&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里主要对文章的 Moving DLT 做介绍，其它关于图像拼接的细节就不描述了，文章的重点就在使用 Moving DLT 来模拟一个复杂映射&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：图像拼接的商用化给我们带来了这个问题已经被解决的错误印象。实际上，在某些严厉的成像条件上，这些结果都不能够使人信服，除非在&lt;strong&gt;只有视角旋转变化或者场景为平面&lt;/strong&gt;的条件下。在这些约束下，可以使用二维射影变换或者单应来对齐图片。在一般情况下，这种条件经常被打破，造成错误的对齐或者鬼影。现在这些拼接技术依赖于后处理方法来消除或减轻鬼影。在这篇文章中，提出一种不同的估计技术，名为 “移动直接线性变换 (Moving DLT)”，可以优化射影变换使得其适应输入数据和理想条件的偏差。这生成了一种 &lt;em&gt;尽可能投影的&lt;/em&gt; 的图像对齐方法，有效的减少了鬼影并且不损害透视图象拼接的几何写实性。此外，还描述了如何将这种对齐方法使用到多幅图像的大全景图生成中，通过将光束法平差（Bundle Adjustment）同时用于优化以达到准确地对齐。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：图像拼接，图像对齐，射影变换，直接线性变换，移动最小二乘法&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="CV&amp;CG&amp;DIP" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/"/>
    
      <category term="CV" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/CV/"/>
    
    
      <category term="Homography" scheme="https://weijun-lin.top/tags/Homography/"/>
    
      <category term="图像拼接" scheme="https://weijun-lin.top/tags/%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5/"/>
    
      <category term="Moving DLT" scheme="https://weijun-lin.top/tags/Moving-DLT/"/>
    
      <category term="DLT" scheme="https://weijun-lin.top/tags/DLT/"/>
    
      <category term="MLS" scheme="https://weijun-lin.top/tags/MLS/"/>
    
  </entry>
  
  <entry>
    <title>单应变换的局限性</title>
    <link href="https://weijun-lin.top/2021/01/14/2021-01-14-HomographyLimits/"/>
    <id>https://weijun-lin.top/2021/01/14/2021-01-14-HomographyLimits/</id>
    <published>2021-01-13T16:00:00.000Z</published>
    <updated>2021-01-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单应变换">单应变换</h2><p>单应变换就是两个平面内保持共线的变换，变换是一个 3*3 的矩阵，因为齐次坐标的尺度无关性所以只有8个自由度。DLT（直接线性变换）算法讨论了单应变换的相关性质，以及变换矩阵的求解。</p><h2 id="局限性">局限性</h2><p>单应变换简单来说就是可以将一个四边形映射为另一个任意的四边形，只需要满足共线点变换后仍为共线即可。在很多算法中都使用到单应变换，但单应变换只能模拟两种情况的变换：</p><ol type="1"><li>相机几何中心位置不变，目标场景任意</li><li>相机位置任意，目标场景为平面（或近似为平面，很多低空遥感图像都视作为平面）</li></ol><a id="more"></a><p>在论文 <a href="%5BPerspective-SIFT:%20An%20efficient%20tool%20for%20low-altitude%20remote%20sensing%20image%20registration%20-%20ScienceDirect%5D(https://www.sciencedirect.com/science/article/abs/pii/S0165168413001503)">Perspective-SIFT: An efficient tool for low-altitude remote sensing image registration</a> 中提取的透视不变特征使用的就是单应变换模拟。</p><p>但上面两个局限性使得在相机位置改变（平移变换）时，场景需要约束到平面。</p><h2 id="局限性的解释">局限性的解释</h2><blockquote><p>下面的内容参考自 <span class="exturl" data-url="aHR0cDovL3Npbmd2aXNpb24ubmV0L3RhZy9ob21vZ3JhcGh5Lw==">Homography | 奇点视觉 (singvision.net)<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>相机位置改变的图示如下：</p><p><img src="/assets/ArticleImg/2021/Homography_2.png" /></p><p>其中 <span class="math inline">\(o,o&#39;\)</span> 表示相机位置，横线表示相机的成像平面，<span class="math inline">\(s_1,s_2\)</span> 表示目标物，这里的 <span class="math inline">\(s_1,s_2\)</span> 在 <span class="math inline">\(o\)</span> 的视角下就成为了一个点，也就是说存在遮挡，这样使用单应变换就不能将一幅图像变换为另一幅图像，在图像拼接中，也就找不到对应点。</p><p>但是当目标为平面时，无论视角怎么改变都不会丢失点（除非视角在平面上），当视角位置不变，仅存在旋转角度的改变时，此时单应也能模拟这种变换。</p><p>视角不变时，单应可以模拟变换，但会造成另一种情况：</p><p><img src="/assets/ArticleImg/2021/Homography_Near90Degreee2.png" /></p><p>成像在 <span class="math inline">\(P&#39;\)</span> 上为均匀的点，但在 <span class="math inline">\(P\)</span> 上却是间隔非均匀的点，当 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(P’\)</span> 垂直时，这种差距更大，可能会使得 <span class="math inline">\(P’\)</span> 上的点在 <span class="math inline">\(P\)</span> 上变成无穷远的点，这在大视角的图像拼接会造成很大的误差。一种解决方法是将图像重投影到均匀圆柱面或者球面上：</p><p><img src="/assets/ArticleImg/2021/Homography_Warp1.png" /></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单应变换&quot;&gt;单应变换&lt;/h2&gt;
&lt;p&gt;单应变换就是两个平面内保持共线的变换，变换是一个 3*3 的矩阵，因为齐次坐标的尺度无关性所以只有8个自由度。DLT（直接线性变换）算法讨论了单应变换的相关性质，以及变换矩阵的求解。&lt;/p&gt;
&lt;h2 id=&quot;局限性&quot;&gt;局限性&lt;/h2&gt;
&lt;p&gt;单应变换简单来说就是可以将一个四边形映射为另一个任意的四边形，只需要满足共线点变换后仍为共线即可。在很多算法中都使用到单应变换，但单应变换只能模拟两种情况的变换：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;相机几何中心位置不变，目标场景任意&lt;/li&gt;
&lt;li&gt;相机位置任意，目标场景为平面（或近似为平面，很多低空遥感图像都视作为平面）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="CV&amp;CG&amp;DIP" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/"/>
    
      <category term="CV" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/CV/"/>
    
    
      <category term="Homography" scheme="https://weijun-lin.top/tags/Homography/"/>
    
  </entry>
  
  <entry>
    <title>MLS移动最小二乘法原理及其实现</title>
    <link href="https://weijun-lin.top/2021/01/07/2021-01-07-MLS/"/>
    <id>https://weijun-lin.top/2021/01/07/2021-01-07-MLS/</id>
    <published>2021-01-06T16:00:00.000Z</published>
    <updated>2021-01-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理介绍">原理介绍</h2><p>原理可参考<span class="exturl" data-url="aHR0cDovL3JlYWQucHVkbi5jb20vZG93bmxvYWRzMTk2L2RvYy85MjA0NzAvTW92aW5nTGVhc3QtU3F1YXJlc01MUy5wZGY=">基于移动最小二乘法的曲线曲面拟合，曾清红，卢德唐<i class="fa fa-external-link-alt"></i></span>，这里面已经讲得很详细了。可以结合<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Njg2NDM3L2FydGljbGUvZGV0YWlscy8xMDYxMDM3NjA=">CSDN 移动最小二乘原理<i class="fa fa-external-link-alt"></i></span>，一起看，曾清红论文的式子稍微有点难懂，结合起来看很不错。</p><p>MLS(Moving Least-Squares)，移动最小二乘，是一种比较方便的曲线、曲面拟合方法，和传统最小二乘法相比有很多优点，在论文中都提到了。这里主要对其原理做个简单的说明和补充。</p><a id="more"></a><p>最小二乘法是通过给定的目标函数和点集中找到目标函数的一组系数使其误差最小（L2范式）。一般是多项式函数，未知数为系数，通过找到最佳的系数来拟合。这就有很大的缺陷，对于一般的函数，很难用一个多项式函数来全局拟合。但分段拟合，其中的光滑又很难保证，会带来很大的困难。</p><h3 id="拟合函数的建立">拟合函数的建立</h3><p>移动最小二乘法其实本质上也类似，不同的是它采取的系数是 x 的函数，也就是对不同的目标拟合点它所属的多项式函数是不同的。这就有了很大的灵活性。有点上面直接分段的意思。</p><p>在拟合区域的一个局部上，拟合函数 <span class="math inline">\(f(x)\)</span> 表示为： <span class="math display">\[f(x) = \sum_{i=1}^m \alpha_i(x) p_i(x) = p^T(x)\alpha(x)\]</span> 乘积相加就可以转换为向量点积，其中： <span class="math display">\[\begin{align}\alpha(x) &amp;= [\alpha_1(x),\alpha_2(x),\cdots,\alpha_m(x)]^T \\p(x) &amp;= [p_1(x), p_2(x),\cdots,p_m(x)]^T\end{align}\]</span> <span class="math inline">\(\alpha(x)\)</span> 为待求系数，每一个元素都是 x 的函数。<span class="math inline">\(p(x)\)</span> 为基函数，一个多项式函数的基，例如拟合线可以使用 <span class="math inline">\([1,x]^T, [1,x,x^2]\)</span> 这类的，对于二维问题（拟合曲面）则可以采用 <span class="math inline">\([1,x,y]^T,[1,x,y,x^2,xy,y^2]\)</span>，优化的目标函数为： <span class="math display">\[J = \sum_{i=1}^n w(x-x_i)[f(x_i)-y_i]^2 = \sum_{i=1}^n w(x-x_i)[p^T(x_i)\alpha(x)-y_i]^2 \rightarrow \mathrm{min}\]</span> 表示的意思其实是对某个小区间，其中的 x 和它对应的 <span class="math inline">\(\alpha(x)\)</span> 使得上式最小，这里<strong>把 x 视作为已知量</strong>，要求的未知量是向量 <span class="math inline">\(\alpha(x)\)</span>。上面的 <span class="math inline">\(f(x)\)</span> 我修改为 <span class="math inline">\(f(x_i)\)</span> ，感觉这才符合论文意思。因为 <span class="math inline">\(w(x-x_i)\)</span> 为权函数，并且具有紧支性（范围之外为 0）也就是<strong>只考虑与 “x” 这个小区间相邻的部分</strong>，其余那些远离它的部分没有影响。</p><p>其中 n 为已知点的数量，<span class="math inline">\(x_i,y_i\)</span> 为已知点集的点。对拟合量 x 来说，未知的只有 <span class="math inline">\(\alpha(x)\)</span> 所以对它求导可得： <span class="math display">\[\begin{align}\frac{\partial J}{\partial \alpha} &amp;= A(x)\alpha(x) - B(x)y = 0\\A(x) &amp;= \sum_{i=1}^n w(x-x_i)p(x_i)p^T(xi) \\B(x) &amp;= [w(x-x_1)p(x_1), w(x-x_2)p(x_2), \cdots, w(x-x_n)p(x_n)] \\y^T &amp;= [y_1, y_2, \cdots,y_n]\end{align}\]</span> 可以先对 <span class="math inline">\(\alpha_i(x)\)</span> 求导，然后拓展到向量形式，偏导等于 0 时取到最小值，此时有： <span class="math display">\[\alpha(x) = A^{-1}(x)B(x)y\]</span> 此时便得到 x 对应的系数向量，其中 <span class="math inline">\(A^{-1}(x),B(x),y\)</span> 为 <span class="math inline">\(m\times m,m\times n,n\times 1\)</span> 的矩阵，把 <span class="math inline">\(\alpha(x)\)</span> 带入 <span class="math inline">\(f(x)\)</span> 定义式有： <span class="math display">\[f(x) = p^T(x)A^{-1}(x)B(x)y = \Phi(x) y\]</span> <span class="math inline">\(\Phi(x)\)</span> 就称为形函数，是一个 <span class="math inline">\(1\times m\)</span> 的向量</p><h3 id="权函数">权函数</h3><p>权函数在最小移动二乘法有很大的作用，甚至是核心作用。它具有紧支性，也就是<strong>权函数在 <em>x</em> 的一个子域内不等于</strong></p><p><strong>零 在这个子域之外全为零</strong>，这个子域称为支持域。权函数是<strong>非负的</strong>，并且随着距离（<span class="math inline">\(\vert\vert x-x_i \vert\vert\)</span>) 的增加而减小，也就是原理 x 的认为对 x 的影响小。权函数还需要具有一定的<strong>光滑性</strong>，因为需要继承原函数的连续性。论文给出的是三次样条函数曲线（这里归一化了）： <span class="math display">\[w(\overline s) = \left \{\begin{align}&amp; \frac{2}{3}-4 \overline s^2 + 4\overline s^3 &amp; &amp;(\overline s \le \frac{1}{2}) \\&amp; \frac{4}{3}-4\overline s+4\overline s^2-\frac{4}{3}\overline s^3 &amp; &amp;(\frac{1}{2} &lt;\overline s\le 1 ) \\&amp; 0 &amp;&amp;(\overline s &gt; 1)\end{align}\right.\]</span></p><p>其中，<span class="math inline">\(s = x - x_i,\overline s = \frac{s}{s_{max}}\)</span>，<span class="math inline">\(s_{max}\)</span> 为影响区域的大小，也就是支持域的大小。需要注意的是，支持域的选取很麻烦，因为拟合函数需要矩阵 A 的逆，这就需要保证<strong>每个拟合点的支持域中的非共线（共面）的点数达到最低要求</strong>。对于使用一维二次基 <span class="math inline">\([1,x,x^2]\)</span> 的曲线拟合，就需要保证拟合点 x 支持域中至少有三个非共线的点。权函数并不是只可以用这个，只要满足上述的特征就可以。</p><p>可以考虑<strong>支持域的动态化</strong>，唯一的支持域对非均匀分部的曲线拟合很不友好，动态化或许可以缓解。</p><h2 id="matlab-实现">Matlab 实现</h2><p>这里使用 matlab 实现，代码不多，只要把思路理清即可，这里分为曲线和曲面拟合，分别对应论文中的两个实验，使用的也是论文中的数据。</p><h3 id="曲线拟合">曲线拟合</h3><p>虽然使用和论文相同的数据，但这里采用了一维二次基 <span class="math inline">\([1,x,x^2]\)</span> 拟合，可以看出比论文的效果稍微好一些。</p><p>代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">clc;clear;</span><br><span class="line"><span class="comment">% 已知点数据</span></span><br><span class="line">x = [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>, <span class="number">1.0</span>];</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">14.5</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line">n = <span class="built_in">size</span>(x,<span class="number">2</span>);</span><br><span class="line">[min_x, max_x] = deal(<span class="built_in">min</span>(x), <span class="built_in">max</span>(x));</span><br><span class="line"><span class="comment">% 绘制点的数量，也就是估计的点</span></span><br><span class="line">points_num = <span class="number">1000</span>;</span><br><span class="line">simulated_x = <span class="built_in">linspace</span>(min_x, max_x, points_num);</span><br><span class="line">simulated_y = <span class="built_in">zeros</span>(<span class="number">1</span>, points_num);</span><br><span class="line"><span class="comment">% 定义格子范围（紧支）需要保证有三个不共线的点，否则A矩阵可能不可逆，这里取4个点范围，避免共线</span></span><br><span class="line"><span class="comment">% 这里是比较均匀的，而且点比较多，到曲面就很难选取了</span></span><br><span class="line">smax = (max_x-min_x)*<span class="number">4</span>/n;</span><br><span class="line"><span class="comment">% 使用一维二次基 [1, x, x^2] m = 3</span></span><br><span class="line">m = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 拟合每一个拟合点</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:points_num</span><br><span class="line">    x_val = simulated_x(<span class="built_in">j</span>);</span><br><span class="line">    <span class="comment">% 预分配 A B, 这里的p就是[1，x_val，x_val^2]</span></span><br><span class="line">    A = <span class="built_in">zeros</span>(m, m);</span><br><span class="line">    B = <span class="built_in">zeros</span>(m, n);</span><br><span class="line">    <span class="comment">% 计算 w 求和</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">        xi = x(<span class="built_in">i</span>);</span><br><span class="line">        w = w_func(<span class="built_in">abs</span>(x_val - xi)/smax);</span><br><span class="line">        p_i = [<span class="number">1</span>;xi;xi^<span class="number">2</span>];</span><br><span class="line">        A = A + w * (p_i*p_i&#x27;);</span><br><span class="line">        B(:, <span class="built_in">i</span>) = w*p_i;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    px = [<span class="number">1</span>, x_val, x_val^<span class="number">2</span>];</span><br><span class="line">    simulated_y(<span class="built_in">j</span>) = px * (A\B) * y&#x27;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot</span>(x, y,<span class="string">&#x27;--o&#x27;</span>, simulated_x, simulated_y);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[w]</span> = <span class="title">w_func</span><span class="params">(s)</span></span></span><br><span class="line">    <span class="keyword">if</span> s &lt;= <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">        w = <span class="number">2</span>/<span class="number">3</span> - <span class="number">4</span>*s^<span class="number">2</span> + <span class="number">4</span>*s^<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">elseif</span> s &lt;= <span class="number">1</span></span><br><span class="line">        w = <span class="number">4</span>/<span class="number">3</span> - <span class="number">4</span>*s + <span class="number">4</span>*s^<span class="number">2</span> - <span class="number">4</span>/<span class="number">3</span>*s^<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>拟合图如下：</p><p><img src="/assets/ArticleImg/2021/MLS_line.png" /></p><p>圆点为数据，虚线为直接连接的线，曲线为拟合线</p><h3 id="曲面拟合">曲面拟合</h3><p>曲面使用的是论文给的函数，使用的和论文的一样的二维线性基 <span class="math inline">\([1,x,y]\)</span> <span class="math display">\[\begin{align}z &amp;= f(x,y) \\ &amp;= 2*(1-x)^2 * exp(-x^2 - (y+1)^2) - 10*(x^4/5 - y^5)* exp(-x^2 - y^2) - 1/3*exp(-(x+1)^2 - y^2)\end{align}\]</span> 函数图像为：</p><p><img src="/assets/ArticleImg/2021/MLS_surface1.png" /></p><p>代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">clc;clear;</span><br><span class="line"><span class="comment">% 定义域</span></span><br><span class="line">l = <span class="number">-3</span>; r = <span class="number">3</span>;</span><br><span class="line"><span class="comment">% 生成随机点 n 个，这 n 个点为已知数据</span></span><br><span class="line">n = <span class="number">200</span>;</span><br><span class="line">x = (r - l) * <span class="built_in">rand</span>(<span class="number">1</span>, n) + l;</span><br><span class="line">y = (r - l) * <span class="built_in">rand</span>(<span class="number">1</span>, n) + l;</span><br><span class="line"><span class="comment">% 函数定义</span></span><br><span class="line">z = <span class="number">2</span>*(<span class="number">1</span>-x).^<span class="number">2</span> .* <span class="built_in">exp</span>(-x.^<span class="number">2</span> - (y+<span class="number">1</span>).^<span class="number">2</span>) - <span class="number">10</span>*(x.^<span class="number">4</span>/<span class="number">5</span> - y.^<span class="number">5</span>) ...</span><br><span class="line">.* <span class="built_in">exp</span>(-x.^<span class="number">2</span> - y.^<span class="number">2</span>) - <span class="number">1</span>/<span class="number">3</span>*<span class="built_in">exp</span>(-(x+<span class="number">1</span>).^<span class="number">2</span> - y.^<span class="number">2</span>);</span><br><span class="line"><span class="comment">% 点是随机的数据，meshgrid 生成点，也就是这里的划分网格</span></span><br><span class="line">[xq, yq] = <span class="built_in">meshgrid</span>(l:<span class="number">0.1</span>:r, l:<span class="number">0.1</span>:r);</span><br><span class="line"><span class="comment">% 插值生成对应的网格数据</span></span><br><span class="line">zq = griddata(x, y, z, xq, yq);</span><br><span class="line"><span class="comment">% 绘制网格和点，这里的网格是插值生成的</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">mesh(xq, yq, zq);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">scatter3</span>(x,y,z);</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"><span class="comment">% 拟合上面的网格</span></span><br><span class="line">points_sum = <span class="built_in">size</span>(xq, <span class="number">1</span>);</span><br><span class="line">simulated_z = <span class="built_in">zeros</span>(points_sum, points_sum);</span><br><span class="line"><span class="comment">% 使用二维线性基[1, x, y] 作为基函数</span></span><br><span class="line">m = <span class="number">3</span>;</span><br><span class="line"><span class="comment">% 定义格子范围（紧支）需要保证有三个不共线的点，否则A矩阵可能不可逆，这个值很难取以避免奇异矩阵的产生，这里简单的取了很大的值</span></span><br><span class="line"><span class="comment">% 我认为严谨的应该事先判断有几个点，对那些产生奇异的块适当的扩大紧支</span></span><br><span class="line">smax = (r-l)/<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% i,j 为拟合点的下标</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:points_sum</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:points_sum</span><br><span class="line">        x_val = xq(<span class="number">1</span>, <span class="built_in">i</span>); y_val = yq(<span class="built_in">j</span>, <span class="number">1</span>);</span><br><span class="line">        A = <span class="built_in">zeros</span>(m, m);</span><br><span class="line">        B = <span class="built_in">zeros</span>(m, n);</span><br><span class="line">        <span class="comment">% 对每个点加权获得拟合值</span></span><br><span class="line">        <span class="keyword">for</span> k = <span class="number">1</span>:n</span><br><span class="line">            xk = x(k); yk = y(k);</span><br><span class="line">            w = w_func(((x_val-xk)^<span class="number">2</span> + (y_val - yk)^<span class="number">2</span>)^<span class="number">0.5</span>/smax);</span><br><span class="line">            p = [<span class="number">1</span>; xk; yk];</span><br><span class="line">            A = A + w*(p*p&#x27;);</span><br><span class="line">            B(:, k) = w * p;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        p_xy = [<span class="number">1</span>, x_val, y_val];</span><br><span class="line">        <span class="comment">% 注意这里 x_val 是第 i 列， y_val是第 j 行 注意mesh的对应下标</span></span><br><span class="line">        simulated_z(<span class="built_in">j</span>, <span class="built_in">i</span>) = p_xy * (A\B) * z&#x27;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">surf(xq, yq, simulated_z);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">scatter3</span>(x,y,z);</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"></span><br><span class="line"><span class="comment">% 这里的s就是半径相当于，也可以设置为格子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[w]</span> = <span class="title">w_func</span><span class="params">(s)</span></span></span><br><span class="line">    <span class="keyword">if</span> s &lt;= <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">        w = <span class="number">2</span>/<span class="number">3</span> - <span class="number">4</span>*s^<span class="number">2</span> + <span class="number">4</span>*s^<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">elseif</span> s &lt;= <span class="number">1</span></span><br><span class="line">        w = <span class="number">4</span>/<span class="number">3</span> - <span class="number">4</span>*s + <span class="number">4</span>*s^<span class="number">2</span> - <span class="number">4</span>/<span class="number">3</span>*s^<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>拟合图如下：</p><p><img src="/assets/ArticleImg/2021/MLS_surface2.png" /></p><p>上面为随机生成的点图和 matlab 插值生成的网格图，下面为 MLS 拟合的曲面，效果还是不错的</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原理介绍&quot;&gt;原理介绍&lt;/h2&gt;
&lt;p&gt;原理可参考&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3JlYWQucHVkbi5jb20vZG93bmxvYWRzMTk2L2RvYy85MjA0NzAvTW92aW5nTGVhc3QtU3F1YXJlc01MUy5wZGY=&quot;&gt;基于移动最小二乘法的曲线曲面拟合，曾清红，卢德唐&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;，这里面已经讲得很详细了。可以结合&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Njg2NDM3L2FydGljbGUvZGV0YWlscy8xMDYxMDM3NjA=&quot;&gt;CSDN 移动最小二乘原理&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;，一起看，曾清红论文的式子稍微有点难懂，结合起来看很不错。&lt;/p&gt;
&lt;p&gt;MLS(Moving Least-Squares)，移动最小二乘，是一种比较方便的曲线、曲面拟合方法，和传统最小二乘法相比有很多优点，在论文中都提到了。这里主要对其原理做个简单的说明和补充。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="CV&amp;CG&amp;DIP" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/"/>
    
      <category term="CV" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/CV/"/>
    
    
      <category term="matlab" scheme="https://weijun-lin.top/tags/matlab/"/>
    
      <category term="曲线曲面拟合" scheme="https://weijun-lin.top/tags/%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E6%8B%9F%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>霍夫变换直线检测原理实现</title>
    <link href="https://weijun-lin.top/2020/12/31/2020-12-31-HoughTransform/"/>
    <id>https://weijun-lin.top/2020/12/31/2020-12-31-HoughTransform/</id>
    <published>2020-12-30T16:00:00.000Z</published>
    <updated>2020-12-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单介绍">简单介绍</h2><p>霍夫变换可以用于边缘检测，更一般的则可以拟合曲线。基本原理如下：由曲线的定义式可得，如果 XY 确定，其对应的未知数构成的等式也可视作一个曲线表达式，这个新的表达式称作<strong>参数空间</strong>（自变量为原来的参数）改变 XY 的过程中这些位置构成的新的表达式必会都经过某一个固定点，这个固定点代表的参数就是原来曲线表达式。</p><a id="more"></a><p>但实际上的曲线会受到噪声影响，也就是说参数空间中所有的表达式并不会经过同一点，而是大部分曲线会经过某一固定点，这个固定点可能不止一个，所以我们将参数空间切分为一个个子区域，并统计子区域中线的交点（也可以直接统计线的点数，只要代表密度即可），交点最多的那个区域就是原曲线的参数。</p><p>更加详细的介绍可见《数字图像处理》中文第三版 <em>P472</em> 10.2.7 边缘检测和边界检测。或参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vUG9ueXMvcC8zMTQ2NzUzLmh0bWw=">Matlab 霍夫变换 ( Hough Transform） 直线检测 - Pony_s - 博客园 (cnblogs.com)<i class="fa fa-external-link-alt"></i></span></p><h2 id="代码实现">代码实现</h2><p>以下为 matlab 代码实现，基本实现过程如下：</p><ol type="1"><li>实现生成直线</li><li>给直线增加噪声</li><li>对噪声处理后的图像生成其参数空间</li><li>对参数空间的所有曲线做直方图统计，得到最大数量的参数表达</li><li>获得拟合的直线</li></ol><p>代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 霍夫变换 &amp; 直线</span></span><br><span class="line"><span class="comment">% 生成直线 y = 2x + 3</span></span><br><span class="line">x = <span class="number">-5</span>:<span class="number">5</span>;</span><br><span class="line">y = <span class="number">2</span>*x + <span class="number">3</span>;</span><br><span class="line"><span class="comment">% 添加噪声</span></span><br><span class="line">y_noise = y + <span class="built_in">randn</span>(<span class="number">1</span>, <span class="built_in">size</span>(x, <span class="number">2</span>))*<span class="number">1.5</span>;</span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;霍夫变换&quot;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">% 绘制原始线和噪声后的线</span></span><br><span class="line"><span class="built_in">plot</span>(x,y, x, y_noise, <span class="string">&#x27;--+&#x27;</span>);</span><br><span class="line">title(<span class="string">&quot;直线拟合&quot;</span>);</span><br><span class="line">axis equal</span><br><span class="line">grid on</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制霍夫变换参数空间，ysin(theta)+xcos(theta) = p</span></span><br><span class="line"><span class="comment">% 设置范围</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="comment">% 设置角度范围</span></span><br><span class="line">[theta_min, theta_max] = deal(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>);</span><br><span class="line">theta = theta_min:<span class="number">0.1</span>:theta_max;</span><br><span class="line"><span class="comment">% 预开辟所有点的参数空间存储</span></span><br><span class="line">p_all = <span class="built_in">zeros</span>(<span class="built_in">size</span>(x,<span class="number">2</span>), <span class="built_in">length</span>(theta(:)));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(x, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">% 生成对应范围内的参数曲线</span></span><br><span class="line">    p = y_noise(<span class="built_in">i</span>) * <span class="built_in">sin</span>(theta) + x(<span class="built_in">i</span>) * <span class="built_in">cos</span>(theta);</span><br><span class="line">    p_all(<span class="built_in">i</span>, :) = p;</span><br><span class="line">    <span class="comment">% 绘制参数空间的曲线</span></span><br><span class="line">    <span class="built_in">plot</span>(theta, p);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">title(<span class="string">&quot;参数空间&quot;</span>);</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line">axis normal</span><br><span class="line">grid on</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">% 统计其中每个子区域中的点数，并记录最大的</span></span><br><span class="line"><span class="comment">% 这里使用直方图hist3计算</span></span><br><span class="line">theta_repeat = <span class="built_in">repmat</span>(theta, <span class="number">11</span>, <span class="number">1</span>);</span><br><span class="line">hist3([theta_repeat(:) p_all(:)], <span class="string">&#x27;CDataMode&#x27;</span>,<span class="string">&#x27;auto&#x27;</span>,<span class="string">&#x27;FaceColor&#x27;</span>,<span class="string">&#x27;interp&#x27;</span>);</span><br><span class="line">title(<span class="string">&quot;直方图统计交点最多的区域&quot;</span>);</span><br><span class="line"><span class="comment">% num 是每个bin的数量，center为对应的x,y坐标</span></span><br><span class="line">[num, center] = hist3([theta_repeat(:) p_all(:)]);</span><br><span class="line"><span class="comment">% 找到最大的那个bin的下标并获取对应的参数</span></span><br><span class="line">[<span class="built_in">i</span>, <span class="built_in">j</span>] = <span class="built_in">find</span>(num == <span class="built_in">max</span>(<span class="built_in">max</span>(num)));</span><br><span class="line">theta_best = center&#123;<span class="number">1</span>&#125;(<span class="built_in">i</span>);</span><br><span class="line">p_best = center&#123;<span class="number">2</span>&#125;(<span class="built_in">j</span>);</span><br><span class="line"><span class="comment">% 获得拟合后的直线并绘制</span></span><br><span class="line">y_simulate = (p_best - x*<span class="built_in">cos</span>(theta_best))/<span class="built_in">sin</span>(theta_best);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x, y_simulate);</span><br><span class="line"><span class="built_in">legend</span>([<span class="string">&quot;y=2x+3&quot;</span>, <span class="string">&quot;y=2x+3+noise&quot;</span>, <span class="string">&quot;simulate&quot;</span>], <span class="string">&#x27;Location&#x27;</span>, <span class="string">&#x27;northwest&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure><p>最后的效果如下：</p><p><img src="/assets/ArticleImg/2020/hough.png" /></p><p>其中参数空间的方框为交点比较多的，也就是比较密集的，这里有两个，代码里就取了一个，另外一个也是可以的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单介绍&quot;&gt;简单介绍&lt;/h2&gt;
&lt;p&gt;霍夫变换可以用于边缘检测，更一般的则可以拟合曲线。基本原理如下：由曲线的定义式可得，如果 XY 确定，其对应的未知数构成的等式也可视作一个曲线表达式，这个新的表达式称作&lt;strong&gt;参数空间&lt;/strong&gt;（自变量为原来的参数）改变 XY 的过程中这些位置构成的新的表达式必会都经过某一个固定点，这个固定点代表的参数就是原来曲线表达式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="CV&amp;CG&amp;DIP" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/"/>
    
      <category term="CV" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/CV/"/>
    
    
      <category term="特征检测" scheme="https://weijun-lin.top/tags/%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B/"/>
    
      <category term="matlab" scheme="https://weijun-lin.top/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>傅里叶变换推导</title>
    <link href="https://weijun-lin.top/2020/12/04/2020-12-04-FourierTransformation/"/>
    <id>https://weijun-lin.top/2020/12/04/2020-12-04-FourierTransformation/</id>
    <published>2020-12-03T16:00:00.000Z</published>
    <updated>2020-12-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍从傅里叶级数出发推导傅里叶变换，知乎有很多优秀的傅里叶变换的推导，这里给出一个从傅里叶级数出发，化离散为连续推导出傅里叶变换（也参考了网上的一些思路）</p><p>本文的傅里叶形式主要为冈萨雷斯中文版《数字图形处理 第三版》第四章给出的形式，下文用《DIP》替代。</p><a id="more"></a><h2 id="傅里叶级数">傅里叶级数</h2><p>复数形式的傅里叶级数： <span class="math display">\[\begin{align}f(t) &amp;= \sum_{n=-\infty}^{\infty} C_n e^{j\frac{2\pi n}{T}t} \\C_n &amp;= \frac{1}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} f(t) e^{-j\frac{2\pi n}{T}t} \text{d}t \\n &amp;= 0,\pm 1,\pm 2,\dots\end{align}\]</span> 等式摘自《DIP》 4.2.2 傅里叶级数。</p><p>傅里叶级数的复数形式可参考网上，注意指数表达有角频率和频率两种，这里为角频率。傅里叶变换推导中将指出。</p><h2 id="傅里叶变换">傅里叶变换</h2><p>《DIP》4.2.4 给出了傅里叶变换对 <span class="math display">\[\begin{align}F(\mu) &amp;= \int_{-\infty}^{\infty} f(t) e^{-j2\pi \mu t} \text{d}t \\f(t) &amp;= \int_{-\infty}^{\infty} F(\mu) e^{-j2\pi \mu t} \text{d}\mu\end{align}\]</span> 其实我们发现傅里叶变换和傅里叶级数的形式是十分相似的，且<strong>级数与积分之间的关系可以用离散和连续来表示</strong>，那么可以试试将傅里叶级数连续化，看看是否可以得出傅里叶变换。傅里叶级数是适用于周期函数的，对于一般函数可认为 <span class="math inline">\(T\rightarrow \infty\)</span></p><p>重写一般函数的傅里叶级数如下： <span class="math display">\[\begin{align}f(t) &amp;= \lim_{T\rightarrow \infty} \sum_{n = -\infty}^{\infty} C_n e^{j\frac{2\pi n}{T}t} \\&amp;=\lim_{T\rightarrow \infty} \sum_{n = -\infty}^{\infty} \{\frac{1}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} f(t) e^{-j\frac{2\pi n}{T}t} \text{d}t\}e^{j\frac{2\pi n}{T}t} \\\end{align}\]</span> 令 <span class="math inline">\(\Delta w = \frac{2\pi}{T}\)</span>（角频率）， <span class="math inline">\(T\rightarrow \infty\)</span> 所以 <span class="math inline">\(\Delta w \rightarrow 0\)</span>，将 <span class="math inline">\(\Delta w\)</span> 带入上式可得 <span class="math display">\[f(t) = \lim_{\Delta w\rightarrow 0} \sum_{n = -\infty}^{\infty} \{\frac{\Delta w}{2\pi} \int_{-\infty}^{\infty} f(t) e^{-j\Delta w\cdot nt} \text{d}t\}e^{j\Delta w\cdot nt}\]</span> 令 <span class="math inline">\(w = \Delta w\cdot n\)</span>，带入可得 <span class="math display">\[f(t) = \lim_{\Delta w\rightarrow 0} \sum_{n = -\infty}^{\infty} \{\frac{\Delta w}{2\pi} \int_{-\infty}^{\infty} f(t) e^{-jwt} \text{d}t\}e^{jwt}\]</span> 这里可以发现大括号内的就是傅里叶变换的形式。所以将其单独提取出来即： <span class="math display">\[F(w) = \int_{-\infty}^{\infty} f(t) e^{-jwt} \text{d}t\]</span> 所以函数又可化为： <span class="math display">\[\begin{align}f(t) &amp;= \lim_{\Delta w\rightarrow 0} \sum_{n = -\infty}^{\infty} \frac{\Delta w}{2\pi} F(w)e^{jwt} \\&amp;= \frac{1}{2\pi} \lim_{\Delta w\rightarrow 0} \sum_{n = -\infty}^{\infty} \Delta w F(w)e^{jwt}\end{align}\]</span> 注意到 <span class="math inline">\(w = \Delta w\cdot n\)</span> ，因为 <span class="math inline">\(n \in (-\infty,\infty)\)</span>，所以 w 为<span class="math inline">\((-\infty,\infty)\)</span> 上以 <span class="math inline">\(\Delta w\)</span> 为间隔的点集。且有定义可知 w 是 n 的函数，对于确定的 <span class="math inline">\(\Delta w\)</span> ，有 <span class="math inline">\(\text{d}w = \Delta w\)</span>，现在，令 <span class="math inline">\(\Delta w\rightarrow 0\)</span> ，即将 w 连续化，所以上式的<strong>本质为函数 <span class="math inline">\(F(w)e^{jwt}\)</span> 自变量 w 在 <span class="math inline">\((-\infty,\infty)\)</span> 上的积分</strong>。最终可得： <span class="math display">\[\begin{align}f(t) &amp;= \frac{1}{2\pi} \int_{-\infty}^{\infty} F(w) e^{jwt} \text{d} w \tag{1}\\F(w)&amp; = \int_{-\infty}^{\infty} f(t) e^{-jwt} \text{d}t \tag{2} \\w &amp;= \Delta w \cdot n \\\Delta w &amp;= \frac{2\pi}{T}\end{align}\]</span> 式子 <span class="math inline">\((1),(2)\)</span> 构成了傅里叶变换对，<span class="math inline">\((1)\)</span> 为傅里叶逆变换，<span class="math inline">\((2)\)</span> 为傅里叶变换</p><p>其中并没有涉及到 <span class="math inline">\(\Delta w\)</span> ，只涉及到自变量 <span class="math inline">\(t,w\)</span>。但傅里叶变换对是时域到频率域的转换。现在也很好理解为什么连接了频率域，<strong>因为推导过程涉及到了 <span class="math inline">\(\Delta w\)</span>，它的物理意义为角频率，而 w 是数轴上以 <span class="math inline">\(\Delta w\)</span> 分割的点集，也就覆盖了全部的频率，换句话说，w 是在频率域中的变量</strong>。</p><p>这个变换对定义式和《DIP》以及网上一些不同，主要在于系数 <span class="math inline">\(\frac{1}{2\pi}\)</span> 以及指数部分，本质上都是相同的，不过是<strong>自变量取角频率还是频率的区别</strong>。</p><p>频率和角频率的关系为：<span class="math inline">\(w = 2 \pi \mu\)</span>，带入角频率傅里叶变换对可得：</p><ol type="1"><li><p>傅里叶变换 <span class="math display">\[ F(w) = F(2\pi \mu) = \int_{-\infty}^{\infty} f(t) e^{-j2\pi \mu t} \text{d}t = F&#39;(\mu) \]</span></p></li><li><p>傅里叶逆变换 <span class="math display">\[ \begin{align} f(t) &amp;= \frac{1}{2\pi} \int_{-\infty}^{\infty}  F(w) e^{jwt} \text{d} w \\ &amp;= \frac{1}{2\pi} \int_{-\infty}^{\infty}  F(2\pi \mu) e^{j2\pi \mu t} \text{d} (2\pi \mu) \\ &amp;= \int_{-\infty}^{\infty}  F&#39;(\mu) e^{j2\pi \mu t} \text{d} \mu \end{align} \]</span></p></li></ol><p>即： $$ <span class="math display">\[\begin{align}F(\mu) &amp;= \int_{-\infty}^{\infty} f(t) e^{-j2\pi \mu t} \text{d}t \\f(t) &amp;= \int_{-\infty}^{\infty} F(\mu) e^{j2\pi \mu t} \text{d} \mu\end{align}\]</span> $$</p><h2 id="总结">总结</h2><p>本文给出了傅里叶变换对的频率与角频率形式，以及从傅里叶级数出发推导傅里叶变换的方法，但不是很严谨，只能是说给出了一个思路，傅里叶变换其实为傅里叶级数拓展到无穷周期的表示。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍从傅里叶级数出发推导傅里叶变换，知乎有很多优秀的傅里叶变换的推导，这里给出一个从傅里叶级数出发，化离散为连续推导出傅里叶变换（也参考了网上的一些思路）&lt;/p&gt;
&lt;p&gt;本文的傅里叶形式主要为冈萨雷斯中文版《数字图形处理 第三版》第四章给出的形式，下文用《DIP》替代。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="CV&amp;CG&amp;DIP" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/"/>
    
      <category term="CV" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/CV/"/>
    
    
      <category term="傅里叶变换" scheme="https://weijun-lin.top/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    
      <category term="信号处理" scheme="https://weijun-lin.top/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【译】图像特征检测，描述和匹配</title>
    <link href="https://weijun-lin.top/2020/12/03/2020-12-03-Image%20Features%20Detection%20Description%20and%20Matching/"/>
    <id>https://weijun-lin.top/2020/12/03/2020-12-03-Image%20Features%20Detection%20Description%20and%20Matching/</id>
    <published>2020-12-02T16:00:00.000Z</published>
    <updated>2020-12-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hassaballah, M. , A. A. Ali , and H. A. Alshazly . &quot;Image Features Detection, Description and Matching.&quot; (2016).a</p><p>原文地址：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnNwcmluZ2VyLmNvbS9jaGFwdGVyLzEwLjEwMDclMkY5NzgtMy0zMTktMjg4NTQtM18y">Image Features Detection, Description and Matching<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><strong>摘要</strong> 特征检测，描述和匹配是计算机视觉应用中重要的组成部分，因此它们在前几十年中受到了极大的注意。几种特征检测器和描述符已经在文献在中被提出，且对图像中那些具有潜在吸引力（即，具有一种独特的属性）的点做了许多定义。这篇文章为检测和描述图像特征介绍了基本符号和数学概念。然后文章还讨论了完美特征所具有的性质并且概述了现存的多种检测和描述方法。更深地，文章还解释了一些特征匹配方法。最后，文章讨论了最常用的检测和描述算法性能评估技术。</p><p><strong>关键词</strong> 兴趣点 特征检测器 特征描述符 特征提取 特征匹配</p><a id="more"></a><h2 id="介绍">1 介绍</h2><p>在前几十年中，图像特征检测器和描述符已经成为计算机视觉社区中最流行的工具并且被广泛应用在大量的应用中。图像表示 【1】，图像分类和图像检索 【2-5】，目标识别和匹配 【6-10】，三维场景重建 【11】，动作追踪 【12-14】，纹理分类 【15-16】，机器人定位 【17-19】，以及生物识别系统 【20-22】，所有都依赖于图像中稳定且有代表性的特征。因此，对于这些应用，检测和提取图像特征是十分重要的步骤。</p><p>为了建立图像之间的对应关系，其中两个或多个图像的对应关系是需要的，确定每一幅图像中显著的点集是重要的 【8，23】。在分类任务中，目标图像的特征描述符和训练完成的图像特征相匹配，并且已训练图像中具有最大一致对应关系的就是最佳匹配。在这种情况下，特征描述符匹配可以建立在距离测量上，例如欧几里得距离或者马氏距离。对于图像配准，同一场景不同设备不同时间获取的两幅或者多幅图像的空间对齐是十分重要的。图像配准或对齐任务中主要的步骤为：特征检测，特征匹配，基于图像中一致特征的变换函数的推导，以及基于导出的变换函数的图像重建【24】。任何匹配、识别系统的首要步骤是检测以及描述图像中的兴趣位置。一旦计算出描述符，比较这些描述符可以得到图像间的关系以完成匹配、识别任务。另外，对于线上街道级别虚拟导航应用，我们需要特征检测和特征描述符从一些平面图像（全景图像）中取提取特征【25】。</p><p>基本思想是首先检测对一类转换协变的兴趣区域。然后，对于每个检测到的区域，在检测到的关键点周围构建图像数据的不变特征向量表示（即描述符）。<u>从图像中提取特征描述符可以基于二阶统计数据、参数模型、从图像变换中获取的参数，甚至是这些方法的组合。</u>两种图像特征可以从图像内容表示中提取出来：<u>全局特征和局部特征</u>。全局特征（例如颜色和纹理）目的是将图像作为整体考虑，可以解释为从图像所有像素中获取的一种特别的属性。然而，局部特征是用于发现和描述图像中的关键点或兴趣区域。在这方面，如果局部特征算法在图像中检测到 n 个关键点，就有 n 个向量描述每一个关键点的形状，颜色，方向，纹理等。全局颜色和纹理特征被证实在数据库中寻找相似图像十分有用，而面向局部结构的特征适合目标分类或者寻找同一对象或场景的其它事件【26】。同时，全局特征不能区分图像的前景和背景，以及两个部分的混合信息【27】。</p><p>另一方面，因为实时应用需要处理更多数据或者需要在计算能力有限的移动设备中运行，对可以快速计算，快速匹配，有效利用内存并且还要保持好的准确度的局部特征描述符的需求在不断增长。另外，对移动平台上的图像匹配来说，局部特征描述符被证实是一个很好的选择，在这里可以处理遮挡和丢失的对象【18】。<u>对于相机标定，图像分类，图像检索和目标追踪、重建这一类具体应用，特征检测器和描述符对亮度、视角改变和图像扭曲（例如噪声，模糊，光照）的鲁棒性是十分重要的</u>【28】。 而其他特定的视觉识别任务，如人脸检测或识别，则需要使用特定的检测器和描述符【29】。</p><p>在文献中，大量的特征提取方法被提出来计算可靠的描述符。有些描述符是专门为特定的应用场景设计例如形状匹配【29，30】。在这些描述符中，<u>尺度不变特征变换（SIFT）</u>描述符【31】利用了高斯函数中一系列差分（DoG）中的局部极值来提取鲁棒性特征，并且<u>加速稳健特征（SURF）</u>描述符【32】受到 SIFT 的部分启发，用于快速计算独特不变的局部特征，SURF 十分流行且广泛应用于多种应用。这些描述符使用预设的过滤器和非线性操作来表示突出的图像区域。在文章的剩余部分， 我们概述了这些方法和算法以及开发人员提出的改进。更深地，我们也将介绍检测和描述图像特征的基础符号和数学概念。我们还在细节上探索检测器和描述符之间的量化关系以及如何评估它们的性能。</p><h2 id="定义和原理">2 定义和原理</h2><h3 id="全局和局部特征">2.1 全局和局部特征</h3><p>在图像处理和计算机视觉任务中，我们需要表示图像通过其特征。原始图像对人眼是抑郁提取特征的，但是对于计算机算法并非如此。总的来说，有两种表示图像的方法，全局特征和局部特征。在全局特征表达中，图像通过一个多维特征向量表示，用来描述整幅图像中的信息。换句话说，全局表示方法会生成一个单一向量，这个向量包含图像的多个方面的可测量信息，例如颜色，纹理或者形状。特别地，每幅图像中提取的单一向量可以用来作比较。例如，当一个人想要区分两幅图像，分别是关于海（蓝色）和森林（绿色）的，一个关于颜色的全局描述符可以为每个类生成完全不同的向量。在这样的背景下，全局特征可以被解释为图像中涉及所有像素的一个特别的属性。这种属性可以是颜色直方图，纹理，边缘，甚至是将图像滤波后的描述符【33】。在另一方面，局部特征表示的主要目标是根据一些显著区域区别表示图像，同时保持视角和光照不变性。因此，<u>图像是基于它的局部结构，通过从一组被称为兴趣区域（即关键点）的图像区域中提取的局部特征描述符集合来描述的</u>。 <strong><em>Fig. 1</em></strong> 描述了这些兴趣区域。大部分局部特征表达了图像块中的纹理。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201111213719530.png" alt="image-20201111213719530" style="zoom:60%;" /></p><p>总的来说，使用哪一种特征一般上很大程度上会依赖于手头上的应用，开发者偏向于最具有区分度的。例如，一个有着大鼻子和小眼睛的人和另一个小鼻子和大眼睛的人在释放图或者灰度分布上会有相似的面部照片。然后，从局部特征簇提取的局部特征或者全局模式看起来会根据有区分度。然而，<u>对于在 WEB 尺度级图像索引应用中的大型数据库，考虑全局特征识是合适的</u>。再者，<u>全局特征对那些可以接受粗略地兴趣目标分割应用是有用的。全局特征的优势在于它们更快，更紧凑同时易于计算且内存友好</u>。不过，全局表示也受到一些众所周知的限制，尤其是它们<u>对一些重要变换不能保持不变，并且对杂物和遮挡敏感</u>。在一些应用中，例如副本检测，许多非法拷贝和原件是十分相似的；它们仅收到压缩，缩放或者有限的裁剪【34】。同时，使用为大尺度图像搜索局部特征可以提供更好的效果【35】。另外因为局部结构比其它平滑区域结构更易区分且稳定，所以局部特征在图像匹配和目标识别中更有用。然而，它们经常需要大量的内存，因为图像可能包含成百上千个局部图像描述符。研究者建议将局部图像描述符聚集为一个紧凑向量并且降维优化【35】。</p><h3 id="特征检测器的特征">2.2 特征检测器的特征</h3><p><em>Tuytelaars</em> 和 <em>Mikolajczyk</em>【27】将局部特征定义为“是一个与其邻居区分开的图像模式”。因此，它们认为局部不变特征的目标是提供一种可以有效匹配图像间局部结构的表示。也就是说，我们希望获取一组稀疏的局部度量，这些度量可以捕获输入图像的本质并对它们的兴趣区域进行编码。为了这个目标，特征检测器和提取器必须有某些性质，同时需要记住这些性质的重要性依赖于实际的应用设置以及做出的妥协。下面列举的性质对在计算机视觉应用中运用特征是十分重要的：</p><ul><li><strong>鲁棒性</strong>，特征检测算法需要检测出同一个特征位置，不依赖缩放，选择，平移，光度变形，人为压缩和噪声。</li><li><strong>可重用性</strong>，特征检测算法可以在不同观测条件下获取的同一场景图像反复检测出相同的特征。</li><li><strong>准确性</strong>，特征检测算法应该准确地定位图像特征（相同像素位置），尤其是在需要精确对应关系来估计对极几何<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>（the epipolar geometry）的图像匹配任务中。</li><li><strong>通用性</strong>，特征检测算法需要可以在不同应用中检测特征。</li><li><strong>高效性</strong>，特征检测算法应该能够在新图像中快速检测特征以支持实时应用。</li><li><strong>保量性</strong>，图像检测算法需要检测所有的或者大量的图像特征。其中，检测出的特征密度应该反映图像的信息内容以提供紧凑的图像表示。</li></ul><h3 id="尺度和仿射不变性">2.3 尺度和仿射不变性</h3><p>事实上，基于矩形或者圆形这类固定形状的区域匹配，在存在一些几何和光度畸变下，寻找对应关系是不可靠的，因为它们会影响区域形状。数字图形中的目标在不同的观察尺度下会有不同的外表。因此，在分析图像内容时，尺度改变会产生重要的影响。已经提出了不同的技术来解决在这种条件下检测和提取不变图像特征。一些是处理尺度变化，还有一些则更深层次地处理仿射变换。为了解决尺度变化，这些技术假设尺度的变化在所有方向上都是相同的(即均匀的)，并使用尺度空间的连续核函数在所有可能的尺度上搜索稳定的特征。其中，<u>图像的大小是不同的，并且滤波器（例如，高斯滤波器）重复地用来平滑图像，也可以保持原始图像大小，改变滤波器的大小</u>，如 <strong><em>Fig. 2</em></strong> 所示。更多关于在尺度改变下的特征检测细节可以在【36】中找到，在这之中提出了一个用于生成图像兴趣尺度级的假设，通过在高斯拉普拉斯（LoG）归一化后的尺度中寻找尺度空间极值。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201114203537215.png" alt="image-20201114203537215" style="zoom:60%;" /></p><p>在另一个方面，<u>在仿射变换中每一个方向的缩放可以是不同的</u><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。不均匀的缩放对定位，尺度，局部结构形状都有影响。因此，尺度不变检测器在这种显著仿射变换中会失效。因此，在这种均匀缩放下的特征检测器需要拓展成仿射不变检测器，以检测局部图像结构的仿射形状。因此，这些放射不变检测器可以看作是尺度不变检测器的一般推广。</p><p>总的来说，仿射变换是一系列变换的组合：平移，缩放，翻转，旋转，和剪切<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>。一个仿射变换（affinity）是任一个保持共线性和距离比的线性映射。在这个角度上看，仿射意味着是射影变换的一个特殊情况，他不会把任何对象从仿射空间 <span class="math inline">\(\mathbb{R}^3\)</span> 移至无穷远平面，反之亦然。简单来说，<span class="math inline">\(\mathbb{R}^n\)</span> 仿射变换是一个映射 <span class="math inline">\(f:\mathbb{R}^n \rightarrow \mathbb{R}^n\)</span>，具体形式如下： <span class="math display">\[f(Y) = \mathbb{A} Y + \mathbb{B}\]</span> 对所有的 <span class="math inline">\(Y\in \mathbb{R}^n\)</span> ，其中 <span class="math inline">\(\mathbb{A}\)</span> 为 <span class="math inline">\(\mathbb{R}^n\)</span> 上的线性变换。在一些特殊的情况，如果 <span class="math inline">\(det(\mathbb{A}) \gt 0\)</span>，这样的变换被称为保向，然而如果 <span class="math inline">\(det(\mathbb{A}) \lt 0\)</span>，则被称为方向反转。众所周知的是，在特定变换族下的函数是不变的，当它的值不随其参数上的变换族改变而改变。二阶矩矩阵为估计局部图像特征的仿射形状提供了理论依据。<u>仿射不变检测器有以下几种：Harris-affine，Hessian-affine，以及 maximally stable extremal regions (MSER)</u>。还需要记住的是这些检测器检测的特征会从圆形变换为椭圆形。</p><h2 id="图像特征检测器">3 图像特征检测器</h2><p><u>特征检测器可以大概地分为三类：单尺度检测器，多尺度检测器以及仿射不变检测器。</u>概括地说，单尺度意味着使用检测器内部参数对特征或目标轮廓仅有一个表示。单尺度检测器对诸如旋转，平移，光照改变和附加噪声的变换是不变的。然而，它们不适用于处理缩放问题。给定同一场景的但尺度不同的两幅图像，我们想要确定是否可以检测到相同的兴趣点。因此，在尺度改变下，建立能够可靠地提取显著特征的多尺度检测器是有必要的。接下来我们会讨论单尺度和多尺度检测器以及仿射不变检测器的细节。</p><h3 id="单尺度检测器">3.1 单尺度检测器</h3><h4 id="moravecs-检测器">3.1.1 Moravec’s 检测器</h4><p>Moravec’s 检测器【37】对寻找图像中完全不同的区域感兴趣，这可以用于记录连续图像帧。它被用于角点检测算法，其中角点是那些低自相似性的点。 这个检测器测试给定图像的每一个像素来确定是否是一个角点。它考虑以某个像素为中心的局部图像块，然后确定它与相邻图像块的相似度。这个相似度是使用中心图像块核其它图像块的平方差之和（SSD）来确定的。基于 SSD 的值，我们需要考虑以下几种情况：</p><ul><li>如果像素在均匀强度的区域内，那么相邻的块会看起来相似或者发生很小的变化。</li><li>如果像素在边上，那么在平行方向的相邻块只有很小的改变，与边垂直的方向会有很大的变化。</li><li>如果像素在一个任意方向都会发生很大变化的位置，那么没有相邻块会与其相似，当任意平移都会发生很大改变时，也就检测到了一个角点。</li></ul><p>块与其邻居（水平，垂直和两个对角线）之间最小的 SSD 被用于角的一个度量。一个角或者兴趣点当 SSD 达到一个局部最大值时被检测到。下面的步骤可以用于实现 Moravec’s 检测器：</p><ol type="1"><li><p>输入：灰度图像，窗口大小，阈值 <span class="math inline">\(T\)</span></p></li><li><p>对图像中的每一个像素 <span class="math inline">\((x,y)\)</span>，以及平移量 <span class="math inline">\((u,v)\)</span>，计算强度变化 <span class="math inline">\(V\)</span>，如下 <span class="math display">\[ V_{u,v}(x,y) = \sum_{\forall a,b \in window } [I(x+u+a,y+v+b) - I(x+a,y+b)]^2 \]</span></p></li><li><p>通过计算角测度 <span class="math inline">\(C(x,y)\)</span> 为每一个像素 <span class="math inline">\((x,y)\)</span> 构建对应的角图 <span class="math display">\[ C(x,y) = min(V_{u,v}(x,y)) \]</span></p></li><li><p>对所有角图中所有小于 T 的值归 0</p></li><li><p>使用非最大值抑制寻找局部最大值。剩下所有的非零值为角点。</p></li></ol><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201115201625703.png" alt="image-20201115201625703" style="zoom:60%;" /></p><p>为了执行非最大值抑制，需要按梯度方向扫描一幅图像，这个方向是与边方向是垂直的。所有不是局部最大值的像素都会被抑制为 0。正如 <strong><em>Fig.3</em></strong> 所描述的，p 和 r 是在 q 梯度方向上的两个相邻点。如果像素 q 的值比 p，q 任一个小，则抑制。Moravec’s 检测器的一个优势为可以检测出大量的角点。然而，<u>它不是各向同性的。强度改变值仅仅在一些离散的位移上（例如，8 个理论方向）并且不再这 8 个相邻方向上的边会被分配到一个相对大的角测度。</u>因此，它不是旋转不变的<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>，这也导致了可重用率低。</p><h4 id="harris-检测器">3.1.2 Harris 检测器</h4><p>Harris 和 Stephens【38】发展了一种结合角和边检测器的方法以解决 Moravec’s 检测器中的限制。通过获取所有方向上的自相关改变量（例如，强度改变），这使得检测器在检测和重用率上变得可取。这个基于自相关矩阵的检测器是应用最广泛的技术。这个用于检测图像特征以及描述局部结构的 2*2 对称自相关矩阵如下表示<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>： <span class="math display">\[M(x,y) = \sum_{x,y} w(u,v) \times \left[\begin{matrix}I_x^2(u,v) &amp; I_xI_y(u,v) \\I_xI_y(u,v) &amp; I_y^2(u,v)\end{matrix}\right]\]</span></p><p>其中 <span class="math inline">\(I_x,I_y\)</span> 分别是在 x 和 y 方向上的局部图像微分，<span class="math inline">\(w(u,v)\)</span> 表示以 <span class="math inline">\((x,y)\)</span> 为中心的区域 <span class="math inline">\((u,v)\)</span> 中的加权窗口。如果一个圆形窗口，例如高斯函数，那么这个响应将是各向同性的，并且中心部分会有更高的权重。为了寻找兴趣点，将为每一个像素计算矩阵 M 的特征值。如果两个特征值都很大就代表这里存在着角点。特征值和检测点的分类关系描述在 <strong><em>Fig.4</em></strong> 中。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201115224916303.png" alt="image-20201115224916303" style="zoom:67%;" /></p><p>通过为每一个像素 <span class="math inline">\((x,y)\)</span> 计算角测度 <span class="math inline">\(C(x,y)\)</span> 构建响应图，<span class="math inline">\(C(x,y)\)</span> 计算公式如下： <span class="math display">\[C(x,y)=det(M) - K(trace(M))^2\]</span> 其中 <span class="math display">\[\begin{align}det(M) &amp;= \lambda_1 \times \lambda_2 \\trace(M) &amp;= \lambda_1 + \lambda_2\end{align}\]</span> K 是一个调节参数，<span class="math inline">\(\lambda_1,\lambda_2\)</span> 是自相关矩阵的特征值。特征值计算的开销是昂贵的，因为涉及到平方根的计算。因此，Harris 建议使用这个角测度，它将两个特征值合并在一个计算中。非最大值抑制用于寻找局部最大值，最后角测度图中保留的非零点就是寻找到的角点。<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p><h4 id="susan-检测器">3.1.3 SUSAN 检测器</h4><p>Simith 和 Brady 【39】介绍了一中不使用图像微分的角点计算方法，是一种通用的低层次的图像处理技术，称为 SUSAN（Smallest Univalue Segment Assimilating Nucleus）<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>。它不仅是一个角检测器还可以用于边缘检测核图像降噪。<u>通过在每一个像素上放置一个固定半径的圆形掩膜来检测角点</u>。中心像素就代表着核，掩膜下的其它像素会与核相比较来检查是否与核有相似的强度值。<u>与核亮度十分相似的像素归为一组，被称为 USAN （Univalve Segment Assimilating Nucleus）。当一个位置的 USAN 中的像素个数达到一个局部最小值并且低于特别的阈值 T，这个位置就是角点</u>。为了检测角点，同一掩膜下的两个像素的相似比较函数 <span class="math inline">\(C(r,r_0)\)</span> 如下表示： <span class="math display">\[C(r,r_0) = \left\{\begin{align}1&amp;, &amp;\text{if　}\vert I(r)-I(r_0) \vert \le T \\0&amp;, &amp; otherwise\end{align}\right.\]</span> 并且 USAN 的区域大小为： <span class="math display">\[n(r_0) = \sum_{r \in c(r_0)} C(r,r_0)\]</span> 其中 <span class="math inline">\(r_0\)</span> 和 <span class="math inline">\(r\)</span> 分别是掩膜下核与其它点的坐标。SUSAN 角点检测器的性能主要依赖于相似比较函数 <span class="math inline">\(C(r,r_0)\)</span>，它不能免疫某些影响图像的因素（例如，强亮度波动和噪声）。</p><p>SUSAN 检测器有如下几个优势：</p><ol type="1"><li>不需要使用微分，因此不需要额外的降噪或者任何昂贵的计算</li><li>高可重用率</li><li>平移以及旋转不变</li></ol><p>不幸的是，<u>它对尺度和其它变换不是不变的，并且固定的阈值不使用于一般情况</u>。这个检测器需要一个可适应的阈值，并且掩膜的形状需要改变。</p><h4 id="fast-检测器7">3.1.4 FAST 检测器<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a></h4><p>FAST（Features from Accelerated Segment Test）最初是由 Rosten 和 Drummondn 【40，41】提出的角点检测器。在这个检测方案中，通过对每个像素使用分段检测来确定候选点，该方法将围绕候选点的 16 个像素作为计算基础。如果在以 r 为半径的 Bresenham 圆上有一组包含 n 个连续像素，且这些像素全部比候选像素（表示为 <span class="math inline">\(I_p\)</span> ）与阈值 t 相加还亮，或者比与阈值相减还暗，那么 p 就被归为角点。有一种高速的检测方法来排除大量的非角点，这种快速检测方法仅检查 1，5，9，13 四个像素。一个角点必须满足至少有三个测试像素比 <span class="math inline">\(I_p+t\)</span> 亮或者比 <span class="math inline">\(I_p - t\)</span> 暗，快速检测方法剩下的点则使用原来的检测方法。<strong><em>Fig.5</em></strong> 描述了这个过程，其中放大的方块为角点检测使用的像素。像素 p 为候选角的中心。使用虚线描绘的弧中有 12 个连续像素比 p 亮了一个阈值。使用 <span class="math inline">\(r=3,n=9\)</span> 的圆可以带来最好的结果。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201116000143758.png" alt="image-20201116000143758" style="zoom:65%;" /></p><p>尽管高速测试可以有很好的性能，但还是受到了在【41】中提及的几个限制和不足。使用机器学习方法可以改善这些限制和不足。决策树算法（ID3）是一种著名的用于学习像素分类的方法，可以对上述算法有很大的加速。因为第一阶段测试会在兴趣点周围产生很多响应，所以需要额外执行非最大值抑制。这使得特征定位更加准确。这个步骤的角测度公式如下： <span class="math display">\[C(x,y) = max(\sum_{j\in S_{bright}}\vert I_{p\rightarrow j} - I_p \vert - t,\sum_{j\in S_{dark}}\vert I_p - I_{p\rightarrow j} \vert - t)\]</span> 其中 <span class="math inline">\(I_{p\rightarrow j}\)</span> 表示位于 Bresenham 圆上的像素。用这个方法，处理时间依然是短，因为第二个阶段测试仅仅用于通过第一阶段测试的那一小部分像素。</p><p>换句话说，整个处理分为两个阶段。<u>首先，对给定 n 以及合适的阈值的分段测试的角点检测在一组图像（最好是取自目标应用域）上执行。圆上的 16 个像素被分为比中心暗，相似或者亮。然后，在这 16 个位置使用 ID3 算法来得到最大信息增益</u><a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>。 非最大值抑制应用于连续弧中像素与中心像素之间的绝对差值之和。注意到使用 ID3 算法执行的角点检测与使用分段检测器会有轻微的不同，因为决策树模型依赖于训练数据，这些模型不能覆盖所有的角点。<u>与现存的许多检测器相比，FAST 角点检测器的高速表现使其十分适合实时视频处理应用</u>。然而，<u>它不是尺度不变的，并且对噪声敏感</u>，它还依赖于阈值，选择一个合适的阈值是一个相当重要的工作。</p><h4 id="hessian-检测器10">3.1.5 Hessian 检测器<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a></h4><p>Hessian 斑点检测器【42，43】是以一个关于图像强度 <span class="math inline">\(I(x,y)\)</span> 的 <span class="math inline">\(2\times 2\)</span> 的二阶微分矩阵，这个矩阵称为 Hesian 矩阵。这个矩阵可以用于局部图像结构，并且其形式如下： <span class="math display">\[H(x,y,\sigma) = \left[\begin{matrix}I_{xx}(x,y,\sigma) &amp; I_{xy}(x,y,\sigma) \\I_{xy}(x,y,\sigma) &amp; I_{yy}(x,y,\sigma)\end{matrix}\right]\]</span></p><p>其中 <span class="math inline">\(I_{xx},I_{xy},I_{yy}\)</span> 是二阶图像微分使用标准差为 <span class="math inline">\(\sigma\)</span> 的高斯函数计算，它寻找在两个正交方向上高响应的点。也就是说，检测器寻找那些满足 Hessian 矩阵行列式达到局部最大值的点： <span class="math display">\[\text{det}(H) = I_{xx}I_{yy}-I_{xy}^2\]</span> 通过选择具有最大行列式的带你，这个方法长结构不友好，因为长结构在一个方向上只有很小的二阶微分（即，信号改变）。使用 <span class="math inline">\(3\times 3\)</span> 的窗口对图像执行非最大值抑制，保持那些比周围 8 个像素都大的像素不变，否则置为 0。然后，检测器返回那些保留下来的像素中大于预设阈值 T 的像素。最后保留下来的主要为角点和纹理改变强烈的区域。虽然 Hessian 矩阵用于描述点周围 8 个相邻点的局部结构，但它的行列式可以用于检测在两个方向上表现出信号变化的图像结构。与其它检测器（例如，拉普拉斯）相比，Hessian 矩阵的行列式仅在两个正交方向显著改变的局部图像模式上响应【44】。然而，在检测器中使用二阶微分使得对噪声敏感。另外，局部最大值经常存在于轮廓或者直边上，在这些位置信号仅在一个方向上发生改变【45】。因此，这些局部最大值是不稳定的，因为噪声和相邻模式的轻微改变都会产生影响。</p><h3 id="多尺度检测器">3.2 多尺度检测器</h3><h4 id="高斯拉普拉斯log">3.2.1 高斯拉普拉斯（LoG）</h4><p>高斯拉普拉斯（Laplacian-of-Gaussian，LoG）是一个二阶微分的线性组合且是一个常用的斑点检测器。给定一副图像 <span class="math inline">\(I(x.y)\)</span> 作为输入，图像的尺度空间表示为 <span class="math inline">\(L(x,y,\sigma)\)</span>，通过图像和一系列不同高斯核卷积 <span class="math inline">\(G(x,y,\sigma)\)</span> 生成，其中 <span class="math display">\[L(x,y,\sigma) = G(x,y,\sigma)\bigotimes I(x,y) \\G(x,y,\sigma) = \frac{1}{2\pi \sigma^2} e^{\frac{-(x^2+y^2)}{2\sigma^2}}\]</span> 通过下式计算拉普拉斯操作 <span class="math display">\[\nabla^2L(x,y,\sigma) = L_{xx}(x,y,\sigma) + L_{yy}(x,y,\sigma)\]</span></p><p>拉普拉斯对暗斑点呈现正响应，对亮斑点则是负响应，斑点大小为 <span class="math inline">\(\sqrt{2\sigma}\)</span> 时响应最强。然而，响应十分依赖于斑点结构的大小以及高斯平滑核的大小。高斯标准差用于控制模糊尺度。为了在图像域自动捕获不同大小的斑点，一种带有自动尺度选择的多尺度方法在【36】中提出，这种方法通过寻找如下式所示的<u>尺度归一化拉普拉斯</u>的尺度空间极值。 <span class="math display">\[\nabla^2_{norm} L(x,y,\sigma) = \sigma^2(L_{xx}(x,y,\sigma) + L_{yy}(x,y,\sigma))\]</span> 它还可以检测那些在空间和尺度上同时是归一化拉普拉斯极值的点。LoG 操作符是循环对称的，因此它很自然地具有旋转不变性。LoG 很适合斑点检测，因为它的循环对称性质，但它也为例如角，边，脊，多节（multi-junctions）这类局部结构提供了很好的<u>特征尺度</u><a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a>估计。在这种情况下，LoG 可用于为给定的图像位置寻找特征尺度或直接检测尺度不变区域，通过寻找 LoG 函数的 3D（位置和尺度<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>） 极值，如 <strong><em>Fig.6</em></strong> 所述。拉普拉斯的尺度选择性质可以在【46】中获取到细节。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201124171703461.png" alt="image-20201124171703461" style="zoom:80%;" /></p><h4 id="高斯差分dog">3.2.2 高斯差分（DoG）</h4><p>实际上，LoG 操作是十分耗时的。为了加速计算，Lowe【31】提出了一种基于局部三维极值的高效算法，极值是在使用高斯差分（Difference-of-Gaussian，DoG）构建的尺度空间金字塔中寻找的。这种方法应用于<em>尺度不变特征变换（SIFT）</em>算法。在这个背景下，DoG 给出了 LoG 的一种近似，并且用于从尺度空间极值中高效检测稳定特征。DoG 函数 <span class="math inline">\(D(x,y,\sigma)\)</span> 可以不使用卷积操作得出，通过高斯金字塔中由因子 k 分割的相邻尺度相减得到。 <span class="math display">\[\begin{align}D(x,y,\sigma) =&amp; (G(x,y,k\sigma)-G(x,y,\sigma)) \bigotimes I(x,y) \\=&amp; L(x,y,k\sigma) - L(x,y,\sigma)\end{align}\]</span> 通过 DoG 提取的特征类型与 LoG 有一致的分类。DoG 区域检测器寻找 3D 尺度空间极值的过程如 <strong><em>Fig.7</em></strong> 所示。LoG 和 DoG 共有的<u>缺点为局部极值可以在相邻的直边轮廓中检测出，这种轮廓仅在一个方向上发生信号改变，使得它们稳定性下降，并对噪声和微小的改变敏感</u>【45】。</p><figure><img src="\assets\Note\Image%20Features%20Detection%20Description%20and%20Matching.assets\image-20201124174117634.png" alt="image-20201124174117634" /><figcaption>image-20201124174117634</figcaption></figure><h4 id="harris-laplace13">3.2.3 Harris-Laplace<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a></h4><p>Harris-Laplace 是由 Mikolajczyk 和 Schmid【45】提出的尺度不变的角点检测器。<u>它依赖于 Harris 角点检测器和高斯尺度空间的组合</u>。尽管 Harris 角点具有旋转不变性和光照不变性，但不是尺度不变的因此，对该检测器中使用的二阶矩矩阵进行了修正，使其与图像分辨率无关。Harris-Laplace 中的尺度适应的二阶矩矩阵表示如下： <span class="math display">\[M(x,y,\sigma_1,\sigma_D) = \sigma^2_D g(\sigma_1)\left[\begin{matrix}I^2_{x}(x,y,\sigma_D) &amp; I_{x}I_y(x,y,\sigma_D) \\I_{x}I_y(x,y,\sigma_D) &amp; I^2_{y}(x,y,\sigma_D)\end{matrix}\right]\]</span> 其中 <span class="math inline">\(I_x,I_y\)</span> 为使用尺度为 <span class="math inline">\(\sigma_D\)</span> 的高斯核在分别在它们方向上做的图像微分。参数 <span class="math inline">\(\sigma_1\)</span> 决定了当前尺度，Harris 角点在这个尺度下的高斯尺度空间内检测。换句话说，微分尺度 <span class="math inline">\(\sigma_D\)</span> 决定了用于计算微分的高斯核大小。然而，积分尺度 <span class="math inline">\(\sigma_1\)</span> 用于控制某一相邻区域内的微分加权平均。多尺度 Harris 角点度量是使用上式矩阵的行列式和迹计算的，如下式： <span class="math display">\[C(x,y,\sigma_1,\sigma_D) = \text{det} [M(x,y,\sigma_1,\sigma_D)]-\alpha \cdot \text{trace}^2[M(x,y,\sigma_1,\sigma_D)]\]</span> 常量 <span class="math inline">\(\alpha\)</span> 的值在 0.04 和 0.06 之间。在每一层尺度空间表示中，通过检测点 <span class="math inline">\((x,y)\)</span> 8 邻域的局部最大值来提取兴趣点。然后，使用阈值来过滤那些极值比较小的角点，因为它们在任一观测条件下都不稳定 <span class="math display">\[C(x,y.\sigma_1,\sigma_D) &gt; Threshold_{Harris}\]</span> 另外，LoG 也可以用于寻找所有尺度上的极大值。其中，只有那些达到拉普拉斯最大值或者其响应大于阈值的点才可以接受<a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a>。 <span class="math display">\[\sigma_1^2\vert L_{xx}(x,y,\sigma_1) + L_{yy}(x,y,\sigma_1) \vert &gt; Threshold_{Laplacian}\]</span> Harris-Laplace 提供了一组具有代表性的点，这些点在图像以及尺度维度都是具有特征的。与多尺度 Harris 相比，Harris-Laplace 减少了很多不必要的兴趣点。这些兴趣点在尺度，旋转，光照以及附加噪声具有不变性。 此外，兴趣点是高可重用的。然而，Harris-Laplace 检测器与 LoG 和 DoG 检测器相比，返回更少的点。它也不适用于仿射变换。</p><h4 id="hessian-laplace">3.2.4 Hessian-Laplace</h4><p>和 Harris-Laplace 相似，基于 Hessian 矩阵的检测器也可以用相同的方法构造一个具有尺度不变性的检测器，名为 Hessian-Laplace。首先，我们使用 Laplacian 或者它的近似表示 DoG 来构造尺度空间。然后使用 Hessian 矩阵的行列式提取尺度不变类斑点特征。Hessian-Laplace 检测器获取的大量特征覆盖了整幅图像，和 Harris-Laplace 相比可重用性略低。此外，由于空间和尺度定位中使用的滤波器的相似性，提取的位置更适合于基于二阶高斯微分的尺度估计。Bay et al. 【32】宣称基于 Hessian 的检测器比基于 Harris 的更稳定。类似得，使用 DoG 代替 LoG 来加速计算，Hessian 行列式使用积分图像技术来近似【29】以达到 Fast Hessian 检测器【32】。</p><h4 id="gabor-wavelet-检测器">3.2.5 Gabor-Wavelet 检测器</h4><p>最近，Yussof 和 Hitam【47】提出一种基于 Gabor 小波<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a>的多尺度兴趣点检测器。Gabor 小波是受高斯包络函数限制的平面波形状的生物激励卷积核，其核类似于哺乳动物简单皮层细胞的二维感受场谱的响应。Gabor 小波使用经过高斯包络函数调制的复平面波。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201125112807047.png" alt="image-20201125112807047" style="zoom:39%;" /></p><p>其中 <span class="math inline">\(K_{u,v} = K_ve^{i\Phi u},z=(x,y)\)</span>，u 和 v 决定了Gabor 小波的方向和尺度，<span class="math inline">\(K_v = K_{max}/f^v\)</span> 并且 <span class="math inline">\(\Phi_u = \pi u/8\)</span>，<span class="math inline">\(K_{max}\)</span> 是最大频率，<span class="math inline">\(f = \sqrt{2}\)</span> 为频率域内核间距因子。通过下面的卷积计算图像 <span class="math inline">\(I\)</span> 与 <span class="math inline">\(\psi\)</span> 之间的响应 <span class="math display">\[G = I \bigotimes \psi\]</span> 这个卷积的系数表示局部图像区域的信息，这应该比独立的像素更有效。Gabor 小波的优势是可以同时在空间和空间频率域上提供最佳分辨率。另外，Gabor 小波可以增强低层次的特征，例如峰，谷，脊。因此，通过组合图像多方向的响应，它可以从不同尺度的图像中提取特征点。兴趣点在多个尺度上提取，并结合均匀间隔的方向。作者证明了 Gabor 小波检测器提取的特征点对不同几何变换都具有高准确度以及高适应性。</p><h3 id="仿射不变检测器">3.3 仿射不变检测器</h3><p>到现在为止讨论的特征检测器展示了平移、旋转和均匀尺度的不变性，并认为局部图像结构的位置和尺度不受仿射变换的影响。因此，它们可以处理一部分富含挑战性的反射不变性问题，同时记住尺度在每个方向上是可以不同的。这反过来使得尺度不变检测器不能处理显著的仿射变换。因此，建立一个对透视变换具有鲁棒性的检测器需要仿射变换不变性。一个仿射不变检测器可以视作是尺度不变检测器的一般版本。最近，一些特征检测器拓展为可以处理仿射变换不变特征。举个例子，Schaffalitzky 和 Zisserman 【48】通过仿射归一化拓展 Harris-Laplace 检测器。Mikolajczyk 和 Schmid 【45】介绍了一种尺度以及仿射不变兴趣点检测方法。他们的算法同时适应了点邻域的位置，尺度，形状来获取仿射不变点。其中，Harris 检测器使用适用于仿射变换并基于二阶矩矩阵估计点邻域的形状。这是通过如下由 Lindberg 和 Garding【49】得出的迭代估计方案：</p><ol type="1"><li>使用尺度不变 Harris-Laplace 检测器明确初始区域点。</li><li>对每一个初始点，使用仿射形状自适应将区域归一化以满足仿射不变。</li><li>迭代估计仿射区域，选择合适的积分尺度，微分尺度和空间定位兴趣点。</li><li>使用这些尺度以及空间定位来更新仿射区域。</li><li>重复第三步直到满足停止条件。</li></ol><p>类似于 Harris-affine，同样的想法可以用于基于 Hessian 的检测器，以实现名为 Hessian-affine 的仿射不变检测器。对于单幅图像。Hessian-affine 通常比 Harris-affine 得到更多可靠的区域。性能的改变依赖于分析的场景类型。再者，Hessian-affine 对纹理场景有很好的响应，纹理场景中有很多类似角的部分。然而，对一些类似建筑的结构化场景，Hessian-affine 处理得很好。Mikolajczyk 和 Schmid 对几种最先进的仿射检测器进行了深入的分析【50】。</p><p>由于篇幅限制，还有几种没有被讨论过的特征检测器，例如，Fast Hessian 或 the Determinant of Hessian (DoH) 【32】 ，MSER【51，52】。关于这些检测器更详细的讨论见【44，45，53】。</p><h2 id="图像特征描述">4 图像特征描述</h2><p>一旦在位置 <span class="math inline">\(p(x,y)\)</span>，尺度 <span class="math inline">\(s\)</span>，以及角度 <span class="math inline">\(\theta\)</span> 检测到一组兴趣点，它们在 <span class="math inline">\(p\)</span> 邻域的内容或者图像结构就需要编码为合适的描述符以达到有识别度的匹配并对局部图像变形不敏感。这种描述符需要和 <span class="math inline">\(\theta\)</span> 对齐并和尺度 <span class="math inline">\(s\)</span> 成比例。文献中有大量的图像特征描述符，最常用的是在接下来的章节中要讨论的几种。</p><h3 id="尺度不变特征变换sift">4.1 尺度不变特征变换（SIFT）</h3><p>lowe【31】提出了尺度不变特征变换算法（scale-invariant feature transform ，SIFT），其使用 DoG 操作在图像中检测到大量的兴趣点。这些点通过 DoG 函数的局部极值选择。在每一个兴趣点可以提取一个特征向量。在多个尺度上，在兴趣点周围的邻域上，利用局部图像属性来估计图像的局部方向，以提供相对于旋转的不变性。接下来，为每一个检测到的点基于特定特征尺度的局部图像信息计算一个描述符。通过建立兴趣点周围区域的梯度方向直方图，SIFT 描述符寻找最高的方向值并且其它大于最值 80% 的值，并使用这些方向作为这个关键点的主方向。</p><p>SIFT 算法的描述阶段从采样关键点周围 <span class="math inline">\(16\times 16\)</span> 区域的梯度值与方向开始，使用它的尺度作为高斯模糊的等级。然后，将原区域划分为 <span class="math inline">\(4\times 4\)</span> 的子区域，并为每个子区域创建一组包含 8 个方向的方向直方图。<span class="math inline">\(\sigma\)</span> 大小为区域一半的高斯加权函数为每一个采样点赋予一个权值，位于区域中心的梯度有较高的权值，这些梯度受位置变化的影响较小。描述符由所有方向直方图组成的向量构成。因为有 <span class="math inline">\(4\times 4\)</span> 个直方图，每一个都包含 8 个 bin，所以每个关键点的特征向量有 <span class="math inline">\(4\times 4\times 8 = 128\)</span> 个元素。最后，特征向量归一化为单位长度以获取光照仿射变化的不变性。然而，相机饱和度或其它类似的影响造成非的线性光照改变会使得某些梯度发生大的改变。这些改变可以通过将特征向量最大值 0.2 以上的值阈值化<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a>处理减少，并再次归一化。<strong><em>Fig.8</em></strong> 为 SIFT 算法的图形表示，其中梯度方向和大小在每一个像素处计算并使用高斯分布加权（如图中的覆盖圆）。然后为每一个子区域计算加权的梯度方向直方图。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201126082806529.png" alt="image-20201126082806529" style="zoom:70%;" /></p><p>标准 SIFT 描述符表示在几个方面是值得注意的：<u>这种表示是精心设计的，以避免由于边界效应和位置的平滑变化而产生的问题，方向和尺度不会引起特征向量的根本变化；它十分紧凑，使用 128 元素的向量表示像素块；但对仿射变换不是显著不变的，这种表示对由透视效果引起的变形具有惊人的弹性</u>。这些特征在不同尺度，选择和光照下与其它竞争算法的匹配性能中得到了证明。在另一个方面，标准 SIFT 特征向量的组成是复杂的并且 SIFT 具体设计背后的选择不明确导致 SIFT 公共的高维问题，这影响了计算描述符所需的时间（十分慢）。作为 SIFT 的拓展，Ke 和 Sukthankar【54】提出了 PCA-SIFT 来减少原始 SIFT 描述符的高维性。<strong>PCA-SIFT</strong> 使用主成分分析（Principal Components Analysis，PCA）技术对关键点周围的梯度图像块归一化。它在给定的尺度下提取 <span class="math inline">\(41\times 41\)</span> 的块并计算竖直和水平两个方向的图像梯度，然后将两个方向的梯度连接以创建特征向量。因此，它的特征向量长度为 <span class="math inline">\(2\times 39 \times 39 = 3042\)</span>。梯度图像向量投影到事先计算的特征空间中，最后得到 36 维的特征向量。然后将向量归一化为单位大小以减少光照改变的影响。此外，Morel 和 Yu【55】证明了 SIFT 对除了六参数的仿射变换外的四参数的缩放，选择和平移是完全不变的。因此，它们介绍了 <strong>affine-SIFT（ASIFT）</strong>通过不同的相机轴方向参数，也就是 SIFT 遗留下来的经纬度角，模拟可获得的所有图像视图。</p><h3 id="梯度位置方向直方图gloh">4.2 梯度位置方向直方图（GLOH）</h3><p>梯度位置方向直方图（Gradient location-orientation histogram，GLOH）由 Mikolajczyk 和 Schmid 【50】提出，也是 SIFT 描述符的拓展。GLOH 与 SIFT 描述符非常相似，它只将 SIFT 使用的笛卡尔位置网格替换为对数-极坐标网格，并应用 PCA 来减小描述符的大小。GLOH 使用对数-极坐标位置网格将径向分为三个（半径设置为 6，11，15），角度方向分为 8 个，如 <strong><em>Fig.9</em></strong> 所示最后有 17 个子块。GLOH 描述符将梯度方向分为 16 个条目并以此建立了一组直方图，所以每个兴趣点的特征向量有 <span class="math inline">\(17\times 16 = 272\)</span> 个元素。通过计算 PCA 协方差矩阵将这个 272 维描述符降为 128 维，并选择最高的 128 维特征用于描述。基于在【50】中的实验评估，<u>GLOH 优于原始 SIFT 描述符，并给出了最佳的性能，尤其是在光照改变的情况下。此外，和 SIFT 描述符相比，GLOH 获取的特征更具有区分度，但也需要更昂贵的计算开销</u>。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201126112550328.png" alt="image-20201126112550328" style="zoom:67%;" /></p><h3 id="加速鲁棒特征描述符surf">4.3 加速鲁棒特征描述符（SURF）</h3><p>加速鲁棒特征（Speeded-Up Robust Features，SURF）检测-描述符由 Bay 等人发展【32】以作为 SIFT 的有效替代。与SIFT 相比它更加快且更具鲁棒性。对于兴趣点检测阶段，并不依赖理想高斯微分，而是基于简单的 2D 核滤波器。其中，它使用基于 Hessian 矩阵行列式的尺度不变斑点检测器来进行尺度选择和定位。<u>它基础的思想为用一个高效的方式来近似高斯二阶微分，通过一组盒滤波器创建的积分图像</u>。<strong><em>Fig.10</em></strong> 描绘了这个 <span class="math inline">\(9\times 9\)</span> 的盒滤波器，它是 <span class="math inline">\(\sigma = 1.2\)</span> 的高斯函数的近似，并且代表了斑点响应映射的最低尺度。这些近似表示为 <span class="math inline">\(D_{xx},D_{yy},D_{xy}\)</span>。因此，Hessian 行列式的近似表示为： <span class="math display">\[\text{det}(H_{approx}) = D_{xx}D_{yy} - (wD_{xy})^2\]</span> 其中 <span class="math inline">\(w\)</span> 是滤波器响应的相对权重，用于平衡 Hessian 行列式表达式。近似的 Hessian 行列式表示了图像中的斑点响应大小。这些响应存储在斑点响应映射图中，使用二次插值寻找并细化局部最大值，如 DoG。最后，在 <span class="math inline">\(3\times 3\times 3\)</span> 的邻域内做非极大值抑制来获取稳定的兴趣点和尺度值。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201127130822757.png" alt="image-20201127130822757" style="zoom:67%;" /></p><p>SURF 描述符首先以检测到的兴趣点为中心建立一个方形区域，并确定其主方向。这个窗口的大小为 <span class="math inline">\(20s\)</span>，其中 s 为其兴趣点对应的尺度。然后，这个兴趣区域进一步分为 <span class="math inline">\(4\times 4\)</span> 个更小的子区域并为每一个子区域在如图 <strong><em>Fig.11</em></strong> <span class="math inline">\(5\times 5\)</span> 大小的采样点上计算竖直和水平（分别表示为 <span class="math inline">\(d_x,d_y\)</span> ）两个方向上的 Harr 小波响应。这些响应使用以兴趣点为中心的高斯窗口加权以增加对几何畸变和位置错误的鲁棒性。对每一个子区域小波响应 <span class="math inline">\(d_x,d_y\)</span> 求和并添加到特征向量 <span class="math inline">\(v\)</span> ，其中 <span class="math display">\[v = (\sum d_x,\sum \vert d_x\vert,\sum d_y,\sum \vert d_y \vert)\]</span> 为所有 <span class="math inline">\(4\times 4\)</span> 的子区域计算这个，就得到一个 <span class="math inline">\(4\times 4\times 4 = 64\)</span> 维的特征描述符。最后，对这个特征描述符归一化以减少光照影响。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201127131158056.png" alt="image-20201127131158056" style="zoom:60%;" /></p><p>和 SIFT 相比 SURF 描述符主要的优势在于处理速度，因为它使用 64 维特征向量来描述局部特征，而 SIFT 使用的是 128 维。然而，<u>SIFT 描述符更适于描述受平移，选择，缩放和其它光照变化影响的图像</u>。尽管 SURF 展示了它在很多计算机视觉应用上的潜力，但它也有许多缺陷。<u>在比较 2D 和 3D 目标时，当旋转幅度大或视角差距大时它将失效。此外，如【56】解释的那样，SURF 并不是完全仿射不变的</u>。</p><h3 id="local-binary-pattern-lbp">4.4 Local Binary Pattern (LBP)</h3><p>LBP 【57，58】表征了纹理的空间结构并展示了灰度单一变换的不变性特点。它通过将相邻像素和中心像素比较以编码排序关系，也就是说通过将每一个像素值和其相邻像素比较以创建一个基于顺序的特征。特别地，将那些比中心像素具有更大特征响应的相邻像素标记为 “1”，否则标记为 “0”。这些同时进行的比较的结果由一个二进制串记录。然后，从公共比率为 2 的几何序列得到的权重，根据串的索引分配给每一个比特。因此，带有权值的二进制串就可以转换为一个十进制值索引（即，LBP 特征响应）。也就是说，这个描述符将邻域上的结果描述了为一个二进制数（二元模式）。其标准模式下，强度为 <span class="math inline">\(g(c)\)</span> 的像素 <span class="math inline">\(c\)</span> 的标记按下式确定 <span class="math display">\[S(g_p - g_c) = \left \{\begin{align}1,&amp; &amp;\text{if　} g_p \ge g_c \\0,&amp; &amp;\text{if　} g_p &lt; g_c\end{align}\right.\]</span> 其中像素 <span class="math inline">\(p\)</span> 属于 <span class="math inline">\(3\times 3\)</span> 大小的邻域，灰度为 <span class="math inline">\(g_p(p=0,1,\dots,7)\)</span> 。然后，像素邻域的 LBP 通过对阈值 <span class="math inline">\(S(g_p-g_c)\)</span> 按 <span class="math inline">\(2^k\)</span> 加权相加获得，如下： <span class="math display">\[LBP = \sum_{k=0}^7 S(g_p-g_c).2^k\]</span> 在为每一个像素计算其标记之后，就可以生成一个 256 bin 的直方图，作为这个纹理的特征描述符。<strong><em>Fig.12</em></strong> 展示了在 <span class="math inline">\(3\times 3\)</span> 邻域内计算 LBP 以及基础区域的方向描述符的例子。此外，LBP 描述符的一般形式为：</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201128003446585.png" alt="image-20201128003446585" style="zoom:55%;" /></p><p>其中 <span class="math inline">\(n_c\)</span> 对应着局部邻域中心像素的灰度级，<span class="math inline">\(n_i\)</span> 是半径为 R 的圆上的 N 等分像素的灰度级。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201128003803784.png" alt="image-20201128003803784" style="zoom:60%;" /></p><p>因为像素之间的关系随距离增加而减少，所以许多的纹理信息可以从局部邻域中获得。因此，半径 R 一般都比较小。在实际应用中，邻域间的差分符号被解释为 N 位二进制数，使得有如 <strong><em>Fig.13</em></strong> 所示的 <span class="math inline">\(2^N\)</span> 个不同的二元模式。二元模式被称为均匀模式，其中每位最多包含两个从 “0” 到 “1” 的转换。例如，“11000011” 和 “00001110” 是两个二元模式，但 “00100100” 和 “01001110” 就不是二元模式。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201129111111162.png" alt="image-20201129111111162" style="zoom:60%;" /></p><p>已经提出了几种不同的 LBP，包括中心对称 LBP（the center-symmetric local binary patterns，CS-LBP），局部三元模式（the local ternary pattern，LTP），基于 CS-LBP 的中心对称 LTP（CS-LTP），以及正交对称 LTP（orthogonal symmetric local ternary pattern，OS-LTP）【60】。不像 LBP，CS-LBP 描述符比较中心对称对之间的灰度差分（见 Fig.13）。实际上，LBP 有容忍光照改变和计算简单的优势。不幸的是，LBP 特征是离散模式的索引而不是数值特征，因此它很难与其它区分度高的特征结合在一个紧凑的描述符中【61】。此外，它产生更高维的特征并对平坦区域的高斯噪声敏感。</p><h3 id="binary-robust-independent-elementary-features-brief">4.5 Binary Robust Independent Elementary Features (BRIEF)</h3><p>BRIEF 是一个低比特率描述符，用于随机森林和随机蕨类分类器的图像匹配【62】。它属于 LBP 和 BRISK 那样的二元描述族，它仅执行简单的二元比较测试和使用汉明距离<a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a>而不是欧几里得距离或者马氏距离。简单来说，为了建立二元描述符，有必要的仅仅是比较被检测兴趣点周围的两个像素的强度。这使得以一个非常小的计算开销便可以获得具有代表形的描述符。此外，二元描述符匹配仅需要计算汉明距离，而汉明距离通过现代架构的 XOR 原语实现快速计算。</p><p>BRIEF 算法依赖于相对小的图像强度差分测试来将图像块表示为二进制串。更特别的是，对大小为 <span class="math inline">\(S \times S\)</span> 的图像块的二元描述符通过连接以下测试结果获得： <span class="math display">\[\tau = \left\{\begin{align}1,&amp; &amp;\text{if　} I(P_j) &gt; I(P_i) \\0,&amp; &amp;\text{otherwise}\end{align}\right.\]</span> 其中 <span class="math inline">\(I(p_i)\)</span> 表示为 <span class="math inline">\(p_i\)</span> 处的（平滑）像素强度，并且所有 <span class="math inline">\(p_i\)</span> 位置的选择唯一定义了一组二进制测试。采样点来自于均值为 0 ，方差为 <span class="math inline">\(\frac{1}{25} S^2\)</span> 的各向同性的高斯分布。为了增加这个描述子的鲁棒性，图像块使用方差为 2，大小为 <span class="math inline">\(9\times 9\)</span> 的高斯核进行预平滑。BRIEF 描述符需要设置两个参数：二元像素对数量和二进制阈值。</p><p>作者的实验显示了仅仅 256 位，甚至 128 位便足以获取十分好的匹配结果。因此，BRIEF 在计算以及内存存储方面都是高效的。不幸的是 BRIEF 描述符对大于 35° 的旋转不具鲁棒性，因此，它并不提供旋转不变性。</p><h3 id="其它特征描述符">4.6 其它特征描述符</h3><p>大量的描述符在文献中提出，并且之中的许多已经被证明在计算机视觉应用中是有效的。举个例子，基于颜色的局部特征是由 Weijer 和 Schmidt 【63】提出的基于颜色信息的四个颜色描述符。Gabor 表示或者其变化【64，65】在某种意义上是最优的，在最小化空间和频率的二维联合不确定性上。Zernike 矩【66，67】和 Steerable 滤波器【68】也用于特征提取和描述。</p><p>受到 Weber’s Law 的启发，根据局部强度变化和中心像素强度值为每个像素计算一个密集的描述符，这个方法为在【28】中提出的 Weber Local Descriptor（WLD）。WLD 描述符采用了 SIFT 使用梯度和其方向直方图的优势，以及 LBP 的计算效率和较小支持区域的优势。和 LBP 描述符相比，WLD 首先计算显著微模式（即，差分激励），然后在这些显著模式以及当前点的梯度方向上建立统计数据。</p><p>两种基于测量图像可视实体相似度从兴趣区域提取特征的方法在【69】中提出。这些方法的思路为将两个著名的方法结合起来，即 SIFT 描述符和 Local Self-Similarities（LSS）。基于笛卡尔位置网格提取了两个名为 Local Self-Similarities（LSS，C）和 Fast Local Self-Similarities（FLSS，C）的特征，这两个特征是基于对数-极坐标位置网格（LSS，LP）的 Local Self-Similarities 的改进版本。LSS 和 FLSS 作为局部特征应用于 SIFT 算法。LSS和FLSS描述符在每个单元中使用基于分布的直方图表示而不是而不是在自然（LSS，LP）描述符中的对数-极坐标位置网格中选择每个桶中的最大相关值。因此，它们得到更具鲁棒性的几何变换不变性和好的光度变换不变性。一个基于二阶梯度直方图的局部图像描述符在【70】中提出，名为 HSOG，用于捕捉神经邻域的曲率相关几何特性。Dalal 和 Triggs【71】展示了梯度方向直方图（HOG）描述符，结合了 SIFT 的性质以及 GLOH 描述符。HOG 和 SIFT 的主要差别为 HOG描述符是在具有重叠局部对比归一化的均匀间隔单元的密集网格上计算的。</p><p>Fan 等人在另一个方向提出了一种兴趣区域描述方法，这种方法在多个可使用区域中基于强度顺序汇聚局部特征。通过强度顺序汇聚不仅对选择和单调强度改变不变，而且将序数信息编码为描述符。通过汇聚两种不同的局部特征，可以得到一种基于梯度，一种基于强度的描述符，即 Multisupport Region Order-Based Gradient Histogram (MROGH) 和 the Multisupport Region Rotation and Intensity Monotonic Invariant Descriptor (MRRID)。前一种结合了强度顺序信息和梯度，然而后一种完全基于强度顺序，这使得它对大的光照改变部分不变。</p><p>尽管最近提出了大量的图像特征描述符，其中的几个是专门为某些场景应用设计的，如目标识别，形状检索或者 LADAR 数据处理【73】。此外，这些描述符的作者在为某些特别任务收集的有限数量基准数据集上评估描述符性能。因此，为特别的应用邻域选择一个合适的描述符是困难的。在这方面，最近一些研究对几种描述符做了比较：兴趣区域描述符【50】，二进制描述符【74】，局部颜色描述符【75】，和 3D 描述符【76，77】。事实上，声称描述图像特征是一个已经被解决的问题是过于大胆和乐观的。另一方面，鉴于上述描述符在几种应用程序中的成功，声称为一般现实情况设计描述符几乎是不可能的说法太过悲观了。最后，为了将描述符算法设计为可以通用还有大量的工作要做。我们主张进一步研究如何使用由三维数据和颜色信息捕获的新模式。对于实时应用，未来研究的进一步是在如 GPU 的并行处理单元上实现算法。</p><h2 id="特征匹配">5 特征匹配</h2><p>特征匹配或者一般而言的图像匹配，作为很多计算机视觉应用的一部分，如图像配准，相机标定和目标识别，建立同一场景/目标的两幅图像之间的对应关系。一种常见的图像匹配方法包括从图像数据中检测一组与图像描述符相联系的兴趣点。一旦特征和它的描述符从两幅或多幅图像中提取出来，下一步便是如 <strong><em>Fig.14</em></strong> 那样在这些图像之间建立基础的特征匹配。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202112550367.png" alt="image-20201202112550367" style="zoom:67%;" /></p><p>为了不失一般性，图像匹配的问题可以表述如下，假设 <span class="math inline">\(p\)</span> 是由检测器检测到的点与一个描述符相联系<a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a></p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202000243428.png" alt="image-20201202000243428" style="zoom:60%;" /></p><p>其中，对于所有的 <span class="math inline">\(K\)</span>，第 <span class="math inline">\(k\)</span> 个描述符的特征向量为：</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202000306500.png" alt="image-20201202000306500" style="zoom:60%;" /></p><p>兴趣点 <span class="math inline">\((p,q)\)</span> 匹配仅当 <span class="math inline">\((\text{i})\)</span> <span class="math inline">\(p\)</span> 为 <span class="math inline">\(q\)</span> 与第一幅图像中所有点的最佳匹配并且反过来 <span class="math inline">\((\text{ii})\)</span> <span class="math inline">\(q\)</span> 是 <span class="math inline">\(p\)</span> 与第二幅图像所有点的最佳匹配。在这个条件下，设计一个高效算法来尽可能快的执行匹配是非常重要的。欧氏范数中图像描述符特征空间中的最近邻匹配可用于基于向量的特征匹配。然而，实际上最优最近邻匹配算法及其参数依赖于数据集的特征。此外，为了抑制那些被认为模棱两可的一致关系的候选匹配，图像描述符之间的最近距离和次近距离之间的比值需要小于一个阈值。特别的是，在高维特征匹配中，这两个算法是最高效的：随机 K-d 森林和 the fast library for approximate nearest neighbors (FLANN)【78】。</p><p>在另一方面，这些算法并不适用与二进制特征（例如，FREAK 或者 BRISK）。二进制特征匹配使用的是汉明距离，通过 按位 XOR 操作计算，并对结果进行位计数。这里涉及到的操作都可以很快的执行。匹配大型数据库的经典方案为使用比线性搜索快几个数量级的近似匹配来提到原先的线性搜索。也就是说，以返回最近邻的近似点作为代价，但是经常与真实的最近邻点十分相近。为了执行二进制特征匹配，需要使用其它的方法如【80-82】。</p><p>一般地，基于兴趣点的匹配方法的性能依赖于潜在兴趣点的性质以及与之相联系的图像描述符【83】。因此，适合图像内容的检测器和描述符应该被用于应用中。举个例子，如果一副包含细菌细胞的图像，那么就需要斑点检测器而不是角点检测器，但对于城市的鸟瞰图，角点检测器更适于人造结构。此外，选择一个可以解决图像退化问题的检测器和描述符是十分重要的。例如，如果没有尺度改变，则不处理尺度变换的检测器更受推崇；反之，如果一副包含很大变形，例如尺度和旋转，那么具有更高计算力的 SURF 特征检测器和描述符更适用于这个情况。至于更高的准确度，建议同时使用几种检测器和描述符。在特征匹配邻域，必须注意到二进制描述符（例如，FREAK 或 BRISK）一般具有更快的速度且一般用于寻找图像间点的一致性关系，但是它们和基于向量的描述符相比准确度更低【74】。数据分析显示，类似 RANSAC 的鲁棒性方法可以用于在估计几何变换或者基础矩阵时，筛选匹配特征中的外点，这对图像配置和目标识别应用中的特征匹配十分有用。</p><h2 id="性能评估">6 性能评估</h2><h3 id="基准数据集">6.1 基准数据集</h3><p>在互联网上有多种多样的数据集可以作为研究者的基准。一个流行并广泛用于检测器和描述符性能评估的为标准 Oxford 数据集【84】。这个数据集包含了不同几何和光度变换（视角改变，尺度改变，图像旋转，图像模糊，光照变换以及 JPEG 压缩）以及不同场景类型的（结构和纹理场景）数据集。在光照改变的情况下，通过改变相机孔径来改变光照。然而对于旋转，尺度改变，视角改变和模糊，有两种不同的场景类型。一种为结构场景，包含独特边缘边界的同类区域（例如涂鸦，建筑）。另一种则包含不同形式的重复纹理。因此，图像变换和场景类型造成的影响可以单独分析。每一个数据集包含 6 个几何和光度变形图像，其中第一张图像和其余 5 张相比是渐变的。<strong><em>Fig.15</em></strong> 为从 Oxford 数据集中抽取的几张图像。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202224948702.png" alt="image-20201202224948702" style="zoom:67%;" /></p><h3 id="评估标准">6.2 评估标准</h3><p>为了判断两张图像特征是否匹配（即，属于是否属于同一特征），Mikolajczyk 等人【44】提出基于重复率标准的评估方法，通过比较检测到的区域和真实区域之间的重叠大小。重复率可以被认为是最重要的评估标准，在评估特征检测器的稳定性上。它测量探测器在图像中提取相同特征点的能力，而不考虑成像条件。重复率标准表示了检测器某个检测器对于某一场景是否足够好。在这个评估方法中，两个兴趣区域 A 和 B 是一致的，当重叠错误率 <span class="math inline">\(\epsilon\)</span> 足够小时，如 <strong>Fig.16</strong> 所示。这个重复错误率表示了在一个单应性变换 H 下两个区域一致性的好坏。它由两个区域的交集和并集的比率定义：</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202230218642.png" alt="image-20201202230218642" style="zoom:67%;" /></p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202225919982.png" alt="image-20201202225919982" style="zoom:67%;" /></p><p>这个方法计算了两个区域的并集和交集的全部像素数量。此外，一个匹配是正确的，当图像上两个对应区域的错误率小于 区域并的 50%，也就是 <span class="math inline">\(\epsilon &lt; 0.5\)</span> 。重叠错误率的计算是基于 H 的，这个单应性变换矩阵是由区域定义的。因此，为了评估特征检测器的性能，对给定一对图像的重复率分数计算为区域与区域的对应数量和这对图像中较少的区域数量的比值。</p><p>另一方面，区域描述符的性能由匹配标准度量，即，描述符表示一个场景区域的好坏。这是基于由图像对得到的正确和错误匹配的数量决定的。这通过比较真实的对应区域数量和正确匹配的区域数量计算。匹配为描述符空间中最邻近的【50】。在这个情况下，两个兴趣区域成匹配对，如果它们描述符 <span class="math inline">\(D_A,D_B\)</span> 之间的欧几里得距离小于一个阈值 <span class="math inline">\(\tau\)</span> 。最后的结果使用召回率（recall）和 1-准确度（1-precision） 表示。每一个参考图像的描述符与变换之后的描述符相比较并计算正确和错误匹配的数量。</p><p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202232054828.png" alt="image-20201202232054828" style="zoom:60%;" /></p><p>其中，No.correspondences 为两幅图像的匹配区域的数量。然而，召回率是同一场景的两幅图像之间正确匹配的区域数量对于一致区域数量。一个理想描述符的对任意准确率其召回率为 1。为了获取其曲线，需要改变阈值 <span class="math inline">\(\tau\)</span>。特别地，召回率随着阈值的增长而增长，因为图像变换引入的噪声和区域检测器中相似描述符间距离的增加。一个慢增长曲线表明描述符会受到图像噪声的影响。如果不同描述符的曲线的斜率差异很大，然后，对于所研究的图像变换或场景类型，这些描述符的显著性和鲁棒性是不同的【50】。</p><h2 id="总结">7 总结</h2><p>这篇文章的目标是为新研究者在图像特征检测和提取研究领域提供一简洁明了的，简短的介绍。介绍了检测和提取图像特征的基本符号和数学概念，描述了完美特征检测器的特性。之前介绍了各种现存的检测兴趣点的算法。也讨论了使用最频繁的描述算法 SIFT，SURF，LBP，WLD，……并且它们的优缺点也着重强调了。此外，它解释了一些特征匹配方法。最后，文章还介绍了它们算法中用于评估性能的技术。</p><hr /><h2 id="参考文献">参考文献</h2><ol type="1"><li>Yap, T., Jiang, X., Kot, A.C.: Two-dimensional polar harmonic transforms for invariant image representation. IEEE Trans. Pattern Anal. Mach. Intell. 32(7), 1259–1270 (2010)</li><li>Liu, S., Bai, X.: Discriminative features for image classification and retrieval. Pattern Recogn. Lett. 33(6), 744–751 (2012)</li><li>Rahmani, R., Goldman, S., Zhang, H., Cholleti, S., Fritts, J.: Localized content-based image retrieval. IEEE Trans. Pattern Anal. Mach. Intell. 30(11), 1902–1912 (2008)</li><li>Stöttinger, J., Hanbury, A., Sebe, N., Gevers, T.: Sparse color interest points for image retrieval and object categorization. IEEE Trans. Image Process. 21(5), 2681–2691 (2012)</li><li>Wang, J., Li, Y., Zhang, Y., Wang, C., Xie, H., Chen, G., Gao, X.: Bag-of-features based medical image retrieval via multiple assignment and visual words weighting. IEEE Trans. Med. Imaging 30(11), 1996–2011 (2011)</li><li>Andreopoulos, A., Tsotsos, J.: 50 years of object recognition: directions forward. Comput. Vis. Image Underst. 117(8), 827–891 (2013)</li><li>Dollár, P., Wojek, C., Schiele, B., Perona, P.: Pedestrian detection: an evaluation of the state of the art. IEEE Trans. Pattern Anal. Mach. Intell. 34(4), 743–761 (2012)</li><li>Felsberg, M., Larsson, F., Wiklund, J., Wadströmer, N., Ahlberg, J.: Online learning of correspondences between images. IEEE Trans. Pattern Anal. Mach. Intell. 35(1), 118–129 (2013)</li><li>Miksik, O., Mikolajczyk, K.: Evaluation of local detectors and descriptors for fast feature matching. In: International Conference on Pattern Recognition (ICPR 2012), pp. 2681–2684. Tsukuba, Japan, 11–15 Nov 2012</li><li>Kim, B., Yoo, H., Sohn, K.: Exact order based feature descriptor for illumination robust image matching. Pattern Recogn. 46(12), 3268–3278 (2013)</li><li>Moreels, P., Perona, P.: Evaluation of features detectors and descriptors based on 3D objects. Int. J. Comput. Vis. 73(3), 263–284 (2007)</li><li>Takacs, G., Chandrasekhar, V., Tsai, S., Chen, D., Grzeszczuk, R., Girod, B.: Rotation-invariant fast features for large-scale recognition and real-time tracking. Sign. Process. Image Commun. 28(4), 334–344 (2013)</li><li>Tang, S., Andriluka, M., Schiele, B.: Detection and tracking of occluded people. Int. J. Comput. Vis. 110(1), 58–69 (2014)</li><li>Rincón, J.M., Makris, D., Uru ˇnuela, C., Nebel, J.C.: Tracking human position and lower body parts using Kalman and particle filters constrained by human biomechanics. IEEE Trans. Syst. Man Cybern. Part B 41(1), 26–37 (2011)</li><li><p>Lazebnik, S., Schmid, C., Ponce, J.: A sparse texture representation using local affine regions. IEEE Trans. Pattern Anal. Mach. Intell. 27(8), 1265–1278 (2005)</p></li><li>Liu, L., Fieguth, P.: Texture classification from random features. IEEE Trans. Pattern Anal. Mach. Intell. 34(3), 574–586 (2012)</li><li>Murillo, A., Guerrero, J., Sagues, C.: SURF features for efficient robot localization with omnidirectional images. In: International Conference on Robotics and Automation, pp. 3901–3907. Rome, Italy, 10–14 Apr, 2007</li><li>Valgren, C., Lilienthal, A.J.: SIFT, SURF &amp; seasons: appearance-based long-term localization in outdoor environments. Rob. Auton. Syst. 58(2), 149–156 (2010)</li><li>Campos, F.M., Correia, L., Calado, J.M.F.: Robot visual localization through local feature fusion: an evaluation of multiple classifiers combination approaches. J. Intell. Rob. Syst. 77(2), 377–390 (2015)</li><li>Farajzadeh, N., Faez, K., Pan, G.: Study on the performance of moments as invariant descriptors for practical face recognition systems. IET Comput. Vis. 4(4), 272–285 (2010)</li><li>Mian, A., Bennamoun, M., Owens, R.: Keypoint detection and local feature matching for textured 3D face recognition. Int. J. Comput. Vis. 79(1), 1–12 (2008)</li><li>Jain, A.K., Ross, A.A., Nandakumar, K.: Introduction to Biometrics, 1st edn. Springer (2011)</li><li>Burghardt, T., Damen, D., Mayol-Cuevas, W., Mirmehdi, M.: Correspondence, matching and recognition. Int. J. Comput. Vis. 113(3), 161–162 (2015)</li><li>Bouchiha, R., Besbes, K.: Comparison of local descriptors for automatic remote sensing image registration. SIViP 9(2), 463–469 (2015)</li><li>Zhao, Q., Feng, W., Wan, L., Zhang, J.: SPHORB: a fast and robust binary feature on the sphere. Int. J. Comput. Vis. 113(2), 143–159 (2015)</li><li>Zhang, S., Tian, Q., Huang, Q., Gao, W., Rui, Y.: USB: ultrashort binary descriptor for fast visual matching and retrieval. IEEE Trans. Image Process. 23(8), 3671–3683 (2014)</li><li>Tuytelaars, T., Mikolajczyk, K.: Local invariant feature detectors: a survey. Found. Trends Comput. Graph. Vis. 3(3), 177–280 (2007)</li><li>Chen, J., Shan, S., He, C., Zhao, G., Pietikäinen, M., Chen, X., Gao, W.: WLD: a robust local image descriptor. IEEE Trans. Pattern Anal. Mach. Intell. 32(9), 1705–1720 (2010)</li><li>Viola, P., Jones, M.J.: Robust real-time face detection. Int. J. Comput. Vis. 57(2), 137–154 (2004)</li><li>Janan, F., Brady, M.: Shape description and matching using integral invariants on eccentricity transformed images. Int. J. Comput. Vis. 113(2), 92–112 (2015)</li><li>Lowe, D.G.: Distinctive image features from scale-invariant keypoints. Int. J. Comput. Vis. 60(2), 91–110 (2004)</li><li>Bay, H., Ess, A., Tuytelaars, T., Gool, L.: Speeded-up robust features (SURF). Comput. Vis. Image Underst. 110(3), 346–359 (2008)</li><li>Oliva, A., Torralba, A.: Modeling the shape of the scene: a holistic representation of the spatial envelope. Int. J. Comput. Vis. 42(3), 145–175 (2001)</li><li>Bianco, S., Mazzini, D., Pau, D., Schettini, R.: Local detectors and compact descriptors for visual search: a quantitative comparison. Digital Signal Process. 44, 1–13 (2015)</li><li>Jégou, H., Perronnin, F., Douze, M., Sánchez, J., Pérez, P., Schmid, C.: Aggregating local descriptors into a compact codes. IEEE Trans. Pattern Anal. Mach. Intell. 34(9), 1704–1716 (2012)</li><li>Lindeberg, T.: Feature detection with automatic scale selection. Int. J. Comput. Vis. 30(2), 79–116 (1998)</li><li>Moravec, H.P.: Towards automatic visual obstacle avoidance. In: 5th International Joint Conference on Artificial Intelligence, pp. 584–594 (1977)</li><li>Harris, C., Stephens, M.: A combined corner and edge detector. In: The Fourth Alvey Vision Conference, pp. 147–151. Manchester, UK (1988)</li><li>Smith, S.M., Brady, J.M.: A new approach to low level image processing. Int. J. Comput. Vis. 23(1), 45–78 (1997)</li><li><p>Rosten, E., Drummond, T.: Fusing points and lines for high performance tracking. In: International Conference on Computer Vision (ICCV’05), pp. 1508–1515. Beijing, China, 17–21 Oct 2005</p></li><li>Rosten, E., Drummond, T.: Machine learning for high speed corner detection. In: 9th European Conference on Computer Vision (ECCV’06), pp. 430–443. Graz, Austria, 7–13 May 2006</li><li>Beaudet, P.R.: Rotationally invariant image operators. In: International Joint Conference on Pattern Recognition, pp. 579–583 (1978)</li><li>Lakemond, R., Sridharan, S., Fookes, C.: Hessian-based affine adaptation of salient local image features. J. Math. Imaging Vis. 44(2), 150–167 (2012)</li><li>Mikolajczyk, K., Tuytelaars, T., Schmid, C., Zisserman, A., Matas, J., Schaffalitzky, F., Kadir, T., Gool, L.: A comparison of affine region detectors. Int. J. Comput. Vis. 65(1/2), 43–72 (2005)</li><li>Mikolajczyk, K., Schmid, C.: Scale &amp; affine invariant interest point detectors. Int. J. Comput. Vis. 60(1), 63–86 (2004)</li><li>Lindeberg, T.: Scale selection properties of generalized scale-space interest point detectors. J. Math. Imaging Vis. 46(2), 177–210 (2013)</li><li>Yussof, W., Hitam, M.: Invariant Gabor-based interest points detector under geometric transformation. Digital Signal Process. 25, 190–197 (2014)</li><li>Schaffalitzky, F., Zisserman, A.: Multi-view matching for unordered image sets. In: European Conference on Computer Vision (ECCV), pp. 414–431. Copenhagen, Denmark, 28–31 May 2002</li><li>Lindeberg, T., Gårding, J.: Shape-adapted smoothing in estimation of 3-D shape cues from affine deformations of local 2-D brightness structure. Image Vis. Comput. 15(6), 415–434 (1997)</li><li>Mikolajczyk, K., Schmid, C.: A performance evaluation of local descriptors. IEEE Trans. Pattern Anal. Mach. Intell. 27(10), 1615–1630 (2005)</li><li>Matas, J., Chum, O., Urban, M., Pajdla, T.: Robust wide baseline stereo from maximally stable extremal regions. In. In British Machine Vision Conference (BMV), pp. 384–393 (2002)</li><li>Matas, J., Ondrej, C., Urban, M., Pajdla, T.: Robust wide-baseline stereo from maximally stable extremal regions. Image Vis. Comput. 22(10), 761–767 (2004)</li><li>Li, J., Allinson, N.: A comprehensive review of current local features for computer vision. Neurocomputing 71(10–12), 1771–1787 (2008)</li><li>Ke, Y., Sukthankar, R.: PCA-SIFT: a more distinctive representation for local image descriptors. In: IEEE Conference on Computer Vision and Pattern Recognition (CVPR’04), pp. 506–513. Washington, DC, USA, 27 June–2 July 2004</li><li>Morel, J., Yu, G.: ASIFT: a new framework for fully affine invariant image comparison. SIAM J. Imaging Sci. 2(2), 438–469 (2009)</li><li>Pang, Y., Li, W., Yuan, Y., Pan, J.: Fully affine invariant SURF for image matching. Neurocomputing 85, 6–10 (2012)</li><li>Ojala, T., Pietikäinen, M., Mäenpää, M.: Multiresolution gray-scale and rotation invariant texture classification with local binary patterns. IEEE Trans. Pattern Anal. Mach. Intell. 24(7), 971–987 (2002)</li><li>Heikkiläa, M., Pietikäinen, M., Schmid, C.: Description of interest regions with local binary patterns. Pattern Recogn. 42(3), 425–436 (2009)</li><li>Tian, H., Fang, Y., Zhao, Y., Lin, W., Ni, R., Zhu, Z.: Salient region detection by fusing bottomup and top-down features extracted from a single image. IEEE Trans. Image Process. 23(10), 4389–4398 (2014)</li><li>Huang, M., Mu, Z., Zeng, H., Huang, S.: Local image region description using orthogonal symmetric local ternary pattern. Pattern Recogn. Lett. 54(1), 56–62 (2015)</li><li>Hong, X., Zhao, G., Pietikäinen, M., Chen, X.: Combining LBP difference and feature correlation for texture description. IEEE Trans. Image Process. 23(6), 2557–2568 (2014)</li><li>Calonder, M., Lepetit, V., Özuysal, M., Trzcinski, T., Strecha, C., Fua, P.: BRIEF: computing a local binary descriptor very fast. IEEE Trans. Pattern Anal. Mach. Intell. 34(7), 1281–1298 (2012)</li><li>Van De Weijer, J., Schmid, C.: Coloring local feature extraction. In: European Conference on Computer Vision (ECCV), pp. 334–348. Graz, Austria, 7–13 May 2006</li><li>Subrahmanyam, M., Gonde, A.B., Maheshwari, R.P.: Color and texture features for image indexing and retrieval. In: IEEE International Advance Computing Conference (IACC), pp.1411–1416. Patiala, India, 6–7 Mar 2009</li><li>Zhang, Y., Tian, T., Tian, J., Gong, J., Ming, D.: A novel biologically inspired local feature descriptor. Biol. Cybern. 108(3), 275–290 (2014)</li><li>Chen, Z., Sun, S.: A Zernike moment phase-based descriptor for local image representation and matching. IEEE Trans. Image Process. 19(1), 205–219 (2010)</li><li>Chen, B., Shu, H., Zhang, H., Coatrieux, G., Luo, L., Coatrieux, J.: Combined invariants to similarity transformation and to blur using orthogonal Zernike moments. IEEE Trans. Image Process. 20(2), 345–360 (2011)</li><li>Freeman, W., Adelson, E.: The design and use of steerable filters. IEEE Trans. Pattern Anal. Mach. Intell. 13(9), 891–906 (1991)</li><li>Liu, J., Zeng, G., Fan, J.: Fast local self-similarity for describing interest regions. Pattern Recogn. Lett. 33(9), 1224–1235 (2012)</li><li>Huang, D., Chao, Z., Yunhong, W., Liming, C.: HSOG: a novel local image descriptor based on histograms of the second-order gradients. IEEE Trans. Image Process. 23(11), 4680–4695 (2014)</li><li>Dalal, N., Triggs, B.: Histograms of oriented gradients for human detection. In: IEEE Conference on Computer Vision and Pattern Recognition (CVPR’05), pp. 886–893. San Diego, CA, USA, 20–26 June 2005</li><li>Fan, B., Wu, F., Hu, Z.: Rotationally invariant descriptors using intensity order pooling. IEEE Trans. Pattern Anal. Mach. Intell. 34(10), 2031–2045 (2012)</li><li>Al-Temeemy, A.A., Spencer, J.W.: Invariant chromatic descriptor for LADAR data processing. Mach. Vis. Appl. 26(5), 649–660 (2015)</li><li>Figat, J., Kornuta, T., Kasprzak, W.: Performance evaluation of binary descriptors of local features. Lect. Notes Comput. Sci. (LNCS) 8671, 187–194 (2014)</li><li>Burghouts, G., Geusebroek, J.M.: Performance evaluation of local color invariantss. Comput. Vis. Image Underst. 113(1), 48–62 (2009)</li><li>Moreels, P., Perona, P.: Evaluation of features detectors and descriptors based on 3D objects. Int. J. Comput. Vis. 73(2), 263–284 (2007)</li><li>Guo, Y., Bennamoun, M., Sohel, F., Lu, M., Wan, J., Kwok, N.M.: A comprehensive performance evaluation of 3D local feature descriptors. Int. J. Comput. Vis. First online, 1–24 (2015)</li><li>Muja, M., Lowe, D.G.: Scalable nearest neighbor algorithms for high dimensional data. IEEE Trans. Pattern Anal. Mach. Intell. 36(11), 2227–2240 (2014)</li><li>Szeliski, R.: Computer Vision: Algorithms and Applications. Springer, USA (2011)</li><li>Muja, M., David G. Lowe: Fast matching of binary features. In: IEEE Conference on Computer Vision and Pattern Recognition (CVPR’12), pp. 404–410. Toronto, ON, USA, 28–30 May 2012</li><li>Nister, D., Stewenius, H.: Scalable recognition with a vocabulary tree. In: IEEE Conference on Computer Vision and Pattern Recognition (CVPR’06), pp. 2161–2168. Washington, DC, USA, 17–22 June 2006</li><li>Yan, C.C., Xie, H., Zhang, B., Ma, Y., Dai, Q., Liu, Y.: Fast approximate matching of binary codes with distinctive bits. Frontiers Comput. Sci. 9(5), 741–750 (2015)</li><li>Lindeberg, T.: Image matching using generalized scale-space interest points. J. Math. Imaging Vis. 52(1), 3–36 (2015)</li><li><p>The oxford data set is available at (last visit, Oct. 2015) <span class="exturl" data-url="aHR0cDovL3d3dy5yb2JvdHMub3guYWMudWsvfnZnZy9kYXRhL2FmZmluZS8=">http://www.robots.ox.ac.uk/~vgg/data/affine/<i class="fa fa-external-link-alt"></i></span></p></li></ol><hr /><section class="footnotes"><hr /><ol><li id="fn1"><p>研究在两个相机位置产生的两幅图像的之间存在的特殊几何关系<a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>即仿射不变性包含了尺度不变，仿射会改变不同方向的尺度，即不均匀地缩放，尺度不变是均匀地缩放<a href="#fnref2" class="footnote-back">↩</a></p></li><li id="fn3"><p>四边形变为平行四边形的变换，仿射变换其实就是一个线性变换和一个平移<a href="#fnref3" class="footnote-back">↩</a></p></li><li id="fn4"><p>这里使用8个方向作为改变依据，但旋转会改变这8个离散方向所代表的原有方向<a href="#fnref4" class="footnote-back">↩</a></p></li><li id="fn5"><p>这里原文有点错误（或者他想表达的是卷积操作），可参考http://dept.me.umn.edu/courses/me5286/vision/Notes/2015/ME5286-Lecture8.pdf<a href="#fnref5" class="footnote-back">↩</a></p></li><li id="fn6"><p>具有旋转不变性，部分光照变化不变性（兴趣点数量会发生改变），不具备尺度不变性，因为依然单尺度的<a href="#fnref6" class="footnote-back">↩</a></p></li><li id="fn7"><p>翻译为最小核值相似区或者最小同值分割吸收核<a href="#fnref7" class="footnote-back">↩</a></p></li><li id="fn8"><p>参考 https://www.cnblogs.com/ronny/p/4078710.html<a href="#fnref8" class="footnote-back">↩</a></p></li><li id="fn9"><p>也就是首先对一组测试图像使用完整的 FAST 算法，然后使用 ID3 得到16像素中亮，暗，相似像素数量和是否是角点的关系，之后就可以直接判断 16 像素中这三种像素的数量直接判断角点<a href="#fnref9" class="footnote-back">↩</a></p></li><li id="fn10"><p>海森矩阵参考 https://blog.csdn.net/u013921430/article/details/79770458<a href="#fnref10" class="footnote-back">↩</a></p></li><li id="fn11"><p>具有最大 LoG 响应的尺度<a href="#fnref11" class="footnote-back">↩</a></p></li><li id="fn12"><p>位置代表的是图像空间，尺度代表的是尺度空间，尺度为1维，图像为2维，组成3维<a href="#fnref12" class="footnote-back">↩</a></p></li><li id="fn13"><p>可参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcm9ubnkvcC80MDA5NDI1Lmh0bWw=">Harris角点 - ☆Ronny丶 - 博客园 (cnblogs.com)<i class="fa fa-external-link-alt"></i></span><a href="#fnref13" class="footnote-back">↩</a></p></li><li id="fn14"><p>这里也就是说需要在尺度空间获得最大值，尺度不变性需要同时满足尺度空间 LoG 最大响应以及图像空间极值条件<a href="#fnref14" class="footnote-back">↩</a></p></li><li id="fn15"><p>这个是真不懂 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd3hsODQ1MjM1ODAwL3AvMTA3MTE4NTguaHRtbA==">小波变换——哈尔小波，Haar - ostartech - 博客园 (cnblogs.com)<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzI3NjQzMjc1L2FydGljbGUvZGV0YWlscy84NDgyNjc3Mw==">【小波变换】小波变换入门----haar小波-筱-CSDN博客-haar小波<i class="fa fa-external-link-alt"></i></span><a href="#fnref15" class="footnote-back">↩</a></p></li><li id="fn16"><p>即值大于最大值 0.2 的值截断为最大值的 0.2<a href="#fnref16" class="footnote-back">↩</a></p></li><li id="fn17"><p>两个字之间对应位不同的数量<a href="#fnref17" class="footnote-back">↩</a></p></li><li id="fn18"><p>感觉这里是某一个点的一组描述符<a href="#fnref18" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hassaballah, M. , A. A. Ali , and H. A. Alshazly . &amp;quot;Image Features Detection, Description and Matching.&amp;quot; (2016).a&lt;/p&gt;
&lt;p&gt;原文地址：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9saW5rLnNwcmluZ2VyLmNvbS9jaGFwdGVyLzEwLjEwMDclMkY5NzgtMy0zMTktMjg4NTQtM18y&quot;&gt;Image Features Detection, Description and Matching&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt; 特征检测，描述和匹配是计算机视觉应用中重要的组成部分，因此它们在前几十年中受到了极大的注意。几种特征检测器和描述符已经在文献在中被提出，且对图像中那些具有潜在吸引力（即，具有一种独特的属性）的点做了许多定义。这篇文章为检测和描述图像特征介绍了基本符号和数学概念。然后文章还讨论了完美特征所具有的性质并且概述了现存的多种检测和描述方法。更深地，文章还解释了一些特征匹配方法。最后，文章讨论了最常用的检测和描述算法性能评估技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt; 兴趣点 特征检测器 特征描述符 特征提取 特征匹配&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="CV&amp;CG&amp;DIP" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/"/>
    
      <category term="CV" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/CV/"/>
    
    
      <category term="特征检测" scheme="https://weijun-lin.top/tags/%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B/"/>
    
      <category term="译文" scheme="https://weijun-lin.top/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>卷积的简单概况</title>
    <link href="https://weijun-lin.top/2020/11/01/2020-11-01-ConvolutionAndCorrelation/"/>
    <id>https://weijun-lin.top/2020/11/01/2020-11-01-ConvolutionAndCorrelation/</id>
    <published>2020-10-31T16:00:00.000Z</published>
    <updated>2020-10-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机视觉与图形图像处理等方面傅里叶变换都是一个十分重要的工具，与傅里叶变换紧密结合起来的便是<strong>卷积和相关</strong>，尤其是卷积（Convolution）在《数字图像处理-冈萨雷斯》中对卷积的的介绍比较笼统。</p><a id="more"></a><p>以下内容参考自《傅里叶变换-冷建华》以及《DIP》</p><p>卷积和相关有连续时间和离散时间两种形式，称之为时间是因为傅里叶是和信号紧密相关的，信号简单来说就是有意义的改变量，一般是随时间改变。</p><h2 id="冲激信号">冲激信号</h2><p>类似的冲激信号也有连续和离散两种形式，冲激信号是十分重要的基本信号，在傅里叶变换和取样有重要作用。</p><h3 id="连续时间的冲激信号">连续时间的冲激信号</h3><p>基本形式如下： <span class="math display">\[\delta_a(t) = \left\{\begin{aligned}+\infty&amp;, &amp;t = 0 \\0&amp;, &amp;t\neq 0\end{aligned}\right.\]</span> 且满足： <span class="math display">\[\int_{-\infty}^{+\infty} \delta_a(t) dt = 1\]</span> 下标 a 表示模拟信号（analog），有以下的积分形式的取样特性（sift）： <span class="math display">\[\int_{-\infty}^{+\infty} f(t) \delta_a(t) dt = f(0) \\\int_{-\infty}^{+\infty} f(t) \delta_a(t-t_0) dt = f(t_0)\]</span></p><h3 id="离散时间的冲激信号">离散时间的冲激信号</h3><p>和连续形式的冲激类似，其形式如下： <span class="math display">\[\delta(n) = \left\{\begin{aligned}1&amp;, &amp;n = 0 \\0&amp;, &amp;n\neq 0\end{aligned}\right.\]</span> 其中 n 为整数，满足： <span class="math display">\[\sum_{n = -\infty}^{+\infty}\delta(n) = 1\]</span> 类似的取样特性如下： <span class="math display">\[\sum_{n = -\infty}^{+\infty} f(n)\delta(n) = f(0) \\\sum_{n = -\infty}^{+\infty} f(n)\delta(n - x_0) = f(x_0)\]</span></p><h2 id="连续时间信号的卷积">连续时间信号的卷积</h2><h3 id="线性卷积">线性卷积</h3><p>定义如下： <span class="math display">\[x_a(t) * y_a(t) = \int_{-\infty}^{+\infty} x_a(\tau) y_a(t-\tau) d\tau\]</span> 也就是将 <span class="math inline">\(y_a\)</span> 翻转（卷）之后对应相乘（积）然后平移计算出所有的值。</p><p>具有<strong>冲激不变性</strong>： <span class="math display">\[x_a(t) * \delta_a(t) = \int_{-\infty}^{+\infty} x_a(\tau) \delta_a(t-\tau) d\tau = x_a(t)\]</span> 线性卷积一般针对一般信号，需要在整个定义域内进行计算</p><h3 id="周期卷积">周期卷积</h3><p>周期卷积也就是针对的是周期信号的卷积，因为是周期信号所以只需要关注一个周期就可以了</p><p>定义如下： <span class="math display">\[x_a(t) * y_a(t) = \int_{0}^{T} x_a(\tau) y_a(t-\tau) d\tau\]</span> 其中 <span class="math inline">\(x_a\)</span> 和 <span class="math inline">\(y_a\)</span> 都是周期为 T 的信号，和线性卷积唯一不同的就是积分区域，这里采用的是 <span class="math inline">\([0 \sim T]\)</span>，其实只要满足一个周期就可以了</p><h3 id="循环卷积">循环卷积</h3><p>循环卷积是针对有限信号，即在某一段区域内有定义的信号（定义域外为 0）假设信号 <span class="math inline">\(x_a,y_a\)</span> 定义在 <span class="math inline">\([0 \sim T]\)</span> 上，循环卷积定义如下： <span class="math display">\[x_a(t) * y_a(t) = \int_{0}^{T} x_a(\tau) y_a(&lt;t-\tau&gt;_T) d\tau\]</span> 其中 <span class="math inline">\(&lt;t-\tau&gt;_T\)</span> 表示对 <span class="math inline">\(t-\tau\)</span> 取模 T 运算，即余数。</p><p>卷积后的信号仅在 <span class="math inline">\([0\sim T]\)</span> 有定义，其它均为 0。</p><p><strong>周期卷积和循环卷积同样满足冲击不变性</strong>。</p><h2 id="离散时间信号的卷积">离散时间信号的卷积</h2><p>类似于连续信号，离散信号（序列）仅仅是将积分改为求和，离散卷积同样具有冲击不变性</p><h3 id="线性卷积-1">线性卷积</h3><p>定义如下： <span class="math display">\[x(n) * y(n) = \sum_{i=-\infty}^{+\infty} x(i) y(n-i)\]</span> n 为整数，代表离散</p><h3 id="周期卷积-1">周期卷积</h3><p>周期卷积对应的就是周期序列，两个周期为 N 的信号的卷积如下： <span class="math display">\[x(n) * y(n) = \sum_{i=0}^{N-1} x(i) y(n-i)\]</span></p><h3 id="循环卷积-1">循环卷积</h3><p>循环卷积定义的是一般有限序列，定义如下： <span class="math display">\[x(n) * y(n) = \sum_{i=0}^{N-1} x(i) y(&lt;n-i&gt;_N)\]</span></p><h2 id="简单补充">简单补充</h2><p>循环卷积和周期卷积本质上并无区别，循环卷积就是对有限序列直接进行<strong>周期拓展</strong>后的周期卷积</p><p>循环卷积也叫做圆周卷积</p><p>对于长度不同的序列做循环卷积一般会进行拓展，即在末尾补0，假设两个信号长度分别为 M，N，则补充 0 后的长度应该至少为 M+N，这样的循环卷积才会和直接线性卷积相同。即两个信号的高低频不会混淆。</p><h2 id="拓充参考">拓充参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2Vuc3Bvcmdlci9wLzEyOTAzMTUyLmh0bWw=">序列卷积：线性、周期和圆周<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDAyODkzMzc=">别怕，&quot;卷积&quot;其实很简单<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机视觉与图形图像处理等方面傅里叶变换都是一个十分重要的工具，与傅里叶变换紧密结合起来的便是&lt;strong&gt;卷积和相关&lt;/strong&gt;，尤其是卷积（Convolution）在《数字图像处理-冈萨雷斯》中对卷积的的介绍比较笼统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="CV&amp;CG&amp;DIP" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/"/>
    
      <category term="CV" scheme="https://weijun-lin.top/categories/Computer-Science/CV-CG-DIP/CV/"/>
    
    
      <category term="傅里叶变换" scheme="https://weijun-lin.top/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    
      <category term="信号处理" scheme="https://weijun-lin.top/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
      <category term="卷积" scheme="https://weijun-lin.top/tags/%E5%8D%B7%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>【STL】next_permutation 算法原理</title>
    <link href="https://weijun-lin.top/2020/09/24/2020-09-24-next-permutation/"/>
    <id>https://weijun-lin.top/2020/09/24/2020-09-24-next-permutation/</id>
    <published>2020-09-23T16:00:00.000Z</published>
    <updated>2020-09-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbHVydWl5dWFuL3AvNTkxNDkwOS5odG1s">【博客园】 STL next_permutation 算法原理和自行实现<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0N6eWF1bi9hcnRpY2xlL2RldGFpbHMvMTA0NDIwMzI5">【CSDN】next_permutation和pre_permutation源码解析<i class="fa fa-external-link-alt"></i></span></li></ul></blockquote><h2 id="基本思路">基本思路</h2><p>【STL】 <code>next_permutation</code> 函数就是返回当前序列的下一个字典序，已经为最大字典序则返回 False，否则为返回 True</p><p>基本思想如下：</p><ol type="1"><li>从尾端开始依次比较两个相邻元素直到存在 <span class="math inline">\(a_i,a_{i+1}\)</span> 满足 <span class="math inline">\(a_i &lt; a_{i+1}\)</span>，如果未找到返回 False</li><li>从尾端开始向前检验，找出第一个大于 <span class="math inline">\(a_i\)</span> 的元素 <span class="math inline">\(a_j\)</span>，交换 <span class="math inline">\(a_i,a_j\)</span></li><li>将 <span class="math inline">\(a_i\)</span> 之后（不包括 <span class="math inline">\(a_i\)</span>）的序列做反序处理</li></ol><a id="more"></a><p>可能的代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirIt</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">next_permutation</span><span class="params">(BidirIt first, BidirIt last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    BidirIt i = last;</span><br><span class="line">    <span class="keyword">if</span> (first == --i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        BidirIt i1, i2;</span><br><span class="line"> </span><br><span class="line">        i1 = i;</span><br><span class="line">        <span class="keyword">if</span> (*--i &lt; *i1) &#123;</span><br><span class="line">            i2 = last;</span><br><span class="line">            <span class="keyword">while</span> (!(*i &lt; *--i2))</span><br><span class="line">                ;</span><br><span class="line">            <span class="built_in">std</span>::iter_swap(i, i2);</span><br><span class="line">            <span class="built_in">std</span>::reverse(i1, last);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == first) &#123;</span><br><span class="line">            <span class="built_in">std</span>::reverse(first, last);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单证明">简单证明</h2><p>上面给出了思路，这里做一个简单证明</p><p>对一个序列 <span class="math inline">\(a_0,a_1,\cdots,a_i,a_{i+1},\cdots,a_{n-1}\)</span>，必定存在 <span class="math inline">\(i\)</span>，使得 <span class="math inline">\(a_i \sim a_{i+1}\)</span>，为正序，<span class="math inline">\(a_{i+1}\sim a_{n-1}\)</span> 为逆序（这里正序指的是从小到大的顺序，逆序为从大到小），这里对应了上面的步骤 1</p><p>现在需要求此序列的下一个字典序，容易得到，<span class="math inline">\(a_{i+1}\sim a_{n-1}\)</span> 已经为逆序（也为递减数列），不存在更大的字典序，但 <span class="math inline">\(a_{i}\sim a_{n-1}\)</span>，并不是逆序，即存在更大的字典序</p><p>显然以 <span class="math inline">\(a_i\)</span> 作为 <span class="math inline">\(a_{i}\sim a_{n-1}\)</span> 的首元素已经达到最大，所以需要在 <span class="math inline">\(a_{i+1}\sim a_{n-1}\)</span> 中找到一个元素替换 <span class="math inline">\(a_i\)</span>，显然此元素为大于 <span class="math inline">\(a_i\)</span> 的最小元素，因为数列 <span class="math inline">\(a_{i+1}\sim a_{n-1}\)</span> 为递减数列，所以只需要从末端开始向前寻找第一个大于 <span class="math inline">\(a_i\)</span> 的元素即可，记此元素为 <span class="math inline">\(a_j\)</span>，即步骤 2</p><p>因为 <span class="math inline">\(a_j &gt; a_i\)</span>，所以 <span class="math inline">\(a_j\)</span> 作为首元素的最小排列为 <span class="math inline">\(a_{i+1} \sim a_{n-1}\)</span> 的顺序表示即可。交换后的序列仍然为逆序的，所以只需要反序处理即可，对应步骤 3</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbHVydWl5dWFuL3AvNTkxNDkwOS5odG1s&quot;&gt;【博客园】 STL next_permutation 算法原理和自行实现&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0N6eWF1bi9hcnRpY2xlL2RldGFpbHMvMTA0NDIwMzI5&quot;&gt;【CSDN】next_permutation和pre_permutation源码解析&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本思路&quot;&gt;基本思路&lt;/h2&gt;
&lt;p&gt;【STL】 &lt;code&gt;next_permutation&lt;/code&gt; 函数就是返回当前序列的下一个字典序，已经为最大字典序则返回 False，否则为返回 True&lt;/p&gt;
&lt;p&gt;基本思想如下：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;从尾端开始依次比较两个相邻元素直到存在 &lt;span class=&quot;math inline&quot;&gt;\(a_i,a_{i+1}\)&lt;/span&gt; 满足 &lt;span class=&quot;math inline&quot;&gt;\(a_i &amp;lt; a_{i+1}\)&lt;/span&gt;，如果未找到返回 False&lt;/li&gt;
&lt;li&gt;从尾端开始向前检验，找出第一个大于 &lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt; 的元素 &lt;span class=&quot;math inline&quot;&gt;\(a_j\)&lt;/span&gt;，交换 &lt;span class=&quot;math inline&quot;&gt;\(a_i,a_j\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;将 &lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt; 之后（不包括 &lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;）的序列做反序处理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="DSAA" scheme="https://weijun-lin.top/categories/Computer-Science/DSAA/"/>
    
    
      <category term="C/C++" scheme="https://weijun-lin.top/tags/C-C/"/>
    
      <category term="STL" scheme="https://weijun-lin.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1066 Root of AVL Tree (AVL树)</title>
    <link href="https://weijun-lin.top/2020/06/01/2020-06-01-PAT-Advanced-1066/"/>
    <id>https://weijun-lin.top/2020/06/01/2020-06-01-PAT-Advanced-1066/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-05-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>给定整数序列，按顺序添加到AVL树中，给出最后AVL树的根节点的值（没想到甲级居然还要考AVL）</p><a id="more"></a><h2 id="思路">思路</h2><p>只要会AVL平衡操作的旋转就可以了</p><p>参考：</p><ol type="1"><li>https://zhuanlan.zhihu.com/p/34899732</li><li>https://www.cnblogs.com/vamei/archive/2013/03/21/2964092.html</li></ol><p>知乎那篇文章也有点问题。。。</p><p>参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    node *left;</span><br><span class="line">    node *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treeHeight</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max(treeHeight(root-&gt;left),treeHeight(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回高度差</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treeGetBalanceFactor</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> treeHeight(root-&gt;left) - treeHeight(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单右旋 返回新的ROOT节点</span></span><br><span class="line"><span class="function">node* <span class="title">treeRotateRight</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    node* left = root-&gt;left;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = left-&gt;right; <span class="comment">// 将将要被抛弃的节点连接为旋转后的 root 的左孩子</span></span><br><span class="line">    left-&gt;right = root; <span class="comment">// 调换父子关系</span></span><br><span class="line">    <span class="comment">// 这里高度就不更新了，用到的时候直接递归获取</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单左旋 返回新的ROOT节点</span></span><br><span class="line"><span class="function">node* <span class="title">treeRotateLeft</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    node* right = root-&gt;right;</span><br><span class="line"></span><br><span class="line">    root-&gt;right = right-&gt;left;</span><br><span class="line">    right-&gt;left = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">treeRebalance</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> factor = treeGetBalanceFactor(root);</span><br><span class="line">    <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; treeGetBalanceFactor(root-&gt;left) &gt; <span class="number">0</span>) <span class="comment">// LL</span></span><br><span class="line">        <span class="keyword">return</span> treeRotateRight(root);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; treeGetBalanceFactor(root-&gt;left) &lt;= <span class="number">0</span>) &#123; <span class="comment">//LR</span></span><br><span class="line">        root-&gt;left = treeRotateLeft(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> treeRotateRight(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(factor &lt; <span class="number">-1</span> &amp;&amp; treeGetBalanceFactor(root-&gt;right) &lt;= <span class="number">0</span>) <span class="comment">// RR</span></span><br><span class="line">        <span class="keyword">return</span> treeRotateLeft(root);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((factor &lt; <span class="number">-1</span> &amp;&amp; treeGetBalanceFactor(root-&gt;right) &gt; <span class="number">0</span>)) &#123; <span class="comment">// RL</span></span><br><span class="line">        root-&gt;right = treeRotateRight(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> treeRotateLeft(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Nothing happened.</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node **root_ptr, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    node *root = *root_ptr;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node *new_node = <span class="keyword">new</span> node&#123;val,<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">        *root_ptr = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; val) &#123;</span><br><span class="line">            insert(&amp;(root-&gt;right), val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            insert(&amp;(root-&gt;left), val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *root_ptr = treeRebalance(*root_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    node* root = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br><span class="line">        insert(&amp;root, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定整数序列，按顺序添加到AVL树中，给出最后AVL树的根节点的值（没想到甲级居然还要考AVL）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="OJ" scheme="https://weijun-lin.top/categories/Computer-Science/OJ/"/>
    
      <category term="PAT" scheme="https://weijun-lin.top/categories/Computer-Science/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://weijun-lin.top/tags/C-C/"/>
    
      <category term="Tree" scheme="https://weijun-lin.top/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1065 A+B and C (64bit)</title>
    <link href="https://weijun-lin.top/2020/05/28/2020-05-28-PAT-Advanced-1065/"/>
    <id>https://weijun-lin.top/2020/05/28/2020-05-28-PAT-Advanced-1065/</id>
    <published>2020-05-27T16:00:00.000Z</published>
    <updated>2020-05-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>给定三个数A，B，C，范围在<span class="math inline">\([-2^{63},2^{63}]\)</span>，判断<code>A+B&gt;C</code></p><a id="more"></a><h2 id="简单思路">简单思路</h2><p>网上很多都是将范围看作<span class="math inline">\([-2^{63},2^{63}-1]\)</span>的范围（因为测试点没有<span class="math inline">\(2^{63}\)</span>这个数据……），这样就可以直接使用<code>long long</code>类型存数据然后判断是否溢出即可。但终究不符合题意，如果真有<span class="math inline">\(2^{63}\)</span>便不行了。</p><p>既然<code>long long</code>存不下，就可以改用<code>unsigned long long</code>，符号位另外单独保存，所以只需要根据符号位计算对应的和就可以了，但是相加之后还是会出现溢出的情况，所以单独判断溢出即可。</p><p>出现溢出的情况只有在正+正，负+负的情况，并且假设<code>A+B = S</code>，那么有<code>S &lt; A and S &lt; B</code>，根据这个结论便可以判断是否溢出。</p><p>对于符号位的存储，需要首先将数存为字符串类型，然后通过<code>sscanf</code>读入，对于负号要先去掉。</p><p>当然你也可以直接使用字符串模拟加法操作也是可以的。</p><p>参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> llu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isGreater</span><span class="params">(<span class="keyword">bool</span> s_a, llu a, <span class="keyword">bool</span> s_b, llu b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正 负</span></span><br><span class="line">    <span class="keyword">if</span>(s_a &amp;&amp; !s_b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负 正</span></span><br><span class="line">    <span class="keyword">if</span>(!s_a &amp;&amp; s_b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负 负</span></span><br><span class="line">    <span class="keyword">if</span>(!s_a &amp;&amp; !s_b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">3</span>][<span class="number">50</span>];    <span class="comment">// 保存为字符串 区别正负数</span></span><br><span class="line">    <span class="keyword">bool</span> s[<span class="number">3</span>];          <span class="comment">// 0 非负数 1 负数 符号位保存</span></span><br><span class="line">    llu nums[<span class="number">3</span>];        <span class="comment">// 保存数值</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %s %s&quot;</span>, str[<span class="number">0</span>], str[<span class="number">1</span>], str[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">3</span>;k++) &#123;</span><br><span class="line">            s[k] = str[k][<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">char</span> *buffer = str[k][<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> ? str[k]+<span class="number">1</span> : str[k];</span><br><span class="line">            <span class="built_in">sscanf</span>(buffer, <span class="string">&quot;%llu&quot;</span>, &amp;nums[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag;  <span class="comment">// 结果的符号</span></span><br><span class="line">        llu res;    <span class="comment">// 存放结果</span></span><br><span class="line">        <span class="comment">// 正 负</span></span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] &amp;&amp; !s[<span class="number">1</span>]) &#123;</span><br><span class="line">            flag = nums[<span class="number">0</span>] &gt;= nums[<span class="number">1</span>];  <span class="comment">// a &gt;= b true</span></span><br><span class="line">            res = flag ? nums[<span class="number">0</span>] - nums[<span class="number">1</span>] : nums[<span class="number">1</span>] - nums[<span class="number">0</span>];</span><br><span class="line">            flag = isGreater(flag, res, s[<span class="number">2</span>], nums[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 负 正</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!s[<span class="number">0</span>] &amp;&amp; s[<span class="number">1</span>]) &#123;</span><br><span class="line">            flag = nums[<span class="number">1</span>] &gt;= nums[<span class="number">0</span>];  <span class="comment">// a &gt;= b true</span></span><br><span class="line">            res = flag ? nums[<span class="number">1</span>] - nums[<span class="number">0</span>] : nums[<span class="number">0</span>] - nums[<span class="number">1</span>];</span><br><span class="line">            flag = isGreater(flag, res, s[<span class="number">2</span>], nums[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 负 负</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!s[<span class="number">0</span>] &amp;&amp; !s[<span class="number">1</span>]) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>];</span><br><span class="line">            flag = isGreater(flag, res, s[<span class="number">2</span>], nums[<span class="number">2</span>]);</span><br><span class="line">            <span class="comment">// 必然是小于溢出，溢出则必定是小于</span></span><br><span class="line">            <span class="keyword">if</span>(res &lt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>];</span><br><span class="line">            flag = isGreater(flag, res, s[<span class="number">2</span>], nums[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span>(res &lt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %s\n&quot;</span>, i, flag ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定三个数A，B，C，范围在&lt;span class=&quot;math inline&quot;&gt;\([-2^{63},2^{63}]\)&lt;/span&gt;，判断&lt;code&gt;A+B&amp;gt;C&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="OJ" scheme="https://weijun-lin.top/categories/Computer-Science/OJ/"/>
    
      <category term="PAT" scheme="https://weijun-lin.top/categories/Computer-Science/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://weijun-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1064 Complete Binary Search Tree （二叉树）</title>
    <link href="https://weijun-lin.top/2020/05/27/2020-05-27-PAT-Advanced-1064/"/>
    <id>https://weijun-lin.top/2020/05/27/2020-05-27-PAT-Advanced-1064/</id>
    <published>2020-05-26T16:00:00.000Z</published>
    <updated>2020-05-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>给定一个各个数不同的序列，给出满足完全二叉树定义的二叉搜索树的层序遍历结果</p><p>Sample Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 0</span><br></pre></td></tr></table></figure><p>Sample Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 3 8 1 5 7 9 0 2 4</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="基本思路">基本思路</h2><p>主要需要知道完全二叉树的定义以及一些性质，完全二叉树即除底层之外，为满二叉树，且底层为从左到右排列。所以对于给定数量的节点，它的完全二叉树结构是确定的，此时只需要用中序遍历，将给定的序列排序后依次放入就可以了，因为它也是一个搜索树。最后在层序遍历输出结果即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Tree[<span class="number">1010</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> vals[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> nodes[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> layers;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">midorder</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历左边</span></span><br><span class="line">    <span class="keyword">if</span>(Tree[root][<span class="number">0</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">        midorder(Tree[root][<span class="number">0</span>], tar);</span><br><span class="line">    &#125;</span><br><span class="line">    nodes[root] = vals[tar++];</span><br><span class="line">    <span class="comment">// 遍历右边</span></span><br><span class="line">    <span class="keyword">if</span>(Tree[root][<span class="number">1</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">        midorder(Tree[root][<span class="number">1</span>], tar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(Tree, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, vals + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="comment">// 构建树结构</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        l = <span class="number">2</span>*i+<span class="number">1</span>, r = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; n) &#123;</span><br><span class="line">            Tree[i][<span class="number">0</span>] = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; n) &#123;</span><br><span class="line">            Tree[i][<span class="number">1</span>] = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vals, vals+n);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过中序遍历</span></span><br><span class="line">    midorder(<span class="number">0</span>, cnt);</span><br><span class="line">    <span class="comment">//层序遍历</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = q.front(); q.pop();</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%s&quot;</span>, nodes[r], cnt == n ? <span class="string">&quot;&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(Tree[r][<span class="number">0</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">            q.push(Tree[r][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Tree[r][<span class="number">1</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">            q.push(Tree[r][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个各个数不同的序列，给出满足完全二叉树定义的二叉搜索树的层序遍历结果&lt;/p&gt;
&lt;p&gt;Sample Input:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 2 3 4 5 6 7 8 9 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Sample Output:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;6 3 8 1 5 7 9 0 2 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="OJ" scheme="https://weijun-lin.top/categories/Computer-Science/OJ/"/>
    
      <category term="PAT" scheme="https://weijun-lin.top/categories/Computer-Science/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://weijun-lin.top/tags/C-C/"/>
    
      <category term="Tree" scheme="https://weijun-lin.top/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统结构 张晨曦-第二版 整理</title>
    <link href="https://weijun-lin.top/2020/05/24/2020-05-24-Computer-System-Architecture-Note/"/>
    <id>https://weijun-lin.top/2020/05/24/2020-05-24-Computer-System-Architecture-Note/</id>
    <published>2020-05-23T16:00:00.000Z</published>
    <updated>2020-05-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Github：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dlaWp1bi1MaW4vTm90ZXMvdHJlZS9tYXN0ZXIv6K6h566X5py657O757uf57uT5p6ELeW8oOaZqOabpi3nrKzkuozniYg=">笔记-计算机系统结构-张晨曦-第二版<i class="fa fa-external-link-alt"></i></span></p></blockquote><a id="more"></a><h2 id="第一章-计算机系统结构的基本概念">第一章 计算机系统结构的基本概念</h2><p>第一台通用电子计算机诞生于1946年</p><p>计算机技术的飞速发展得益于两个方面</p><ol type="1"><li>计算机制造技术的发展</li><li>计算机系统结构的创新</li></ol><p>系统结构的重大转折：</p><ol type="1"><li>从单纯依靠指令级并行转向开发线程级并行和数据级并行</li><li>计算机系统结构在计算机的发展中有着极其重要的作用</li></ol><h3 id="计算机系统结构的概念">1.2 计算机系统结构的概念</h3><h4 id="计算机系统的层次结构">计算机系统的层次结构</h4><ol type="1"><li>计算机系统＝硬件/固件＋软件</li><li>计算机语言从低级向高级发展</li><li>从计算机语言的角度，把计算机系统按功能划分成多层次结构</li></ol><h4 id="计算机系统结构的定义">计算机系统结构的定义</h4><ol type="1"><li><p>计算机系统结构的经典定义：程序员所看到的计算机属性，即概念性结构与功能特性</p></li><li><p>按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性</p></li><li><p>Amdahl提出的系统结构：传统机器语言级程序员所看到的计算机属性</p><p>属性主要为：</p><ul><li>指令系统</li><li>数据表示</li><li>寻址规则</li><li>寄存器定义</li><li>中断系统</li><li>机器工作状态的定义和切换</li><li>存储系统</li><li>信息保护</li><li>I/O结构</li></ul></li><li><p><strong>广义的系统结构定义：指令集结构、组成、硬件</strong></p></li><li><p>计算机系统结构概念的<strong>实质</strong>：确定计算机系统中软、硬件的界面，界面之上是软件实现的功能，界面之下是硬件和固件实现的功能</p></li></ol><h4 id="计算机组成和计算机实现">计算机组成和计算机实现</h4><p>一种体系结构可以有多种组成，一种组成可以有多种物理实现</p><ol type="1"><li><p><strong>计算机系统结构</strong>：计算机系统的软、硬件的界面</p></li><li><p><strong>计算机组成</strong>：计算机系统结构的逻辑实现</p><p>物理机器级内各事件的排序方式与控制方式、各部件的功能以及各部件之间的联系</p></li><li><p><strong>计算机实现</strong>：计算机组成的物理实现（器件技术（起主导作用）、微组装技术）</p></li></ol><h4 id="计算机系统结构的分类">计算机系统结构的分类</h4><ol type="1"><li><p><strong>冯氏分类法：用系统的最大并行度对计算机进行分类</strong></p><p>最大并行度：计算机系统在单位时间内能够处理的最大的二进制位数</p></li><li><p><strong>Flynn分类法：按照指令流和数据流的多倍性进行分类</strong></p><ul><li>指令流：计算机执行的指令序列</li><li>数据流：由指令流调用的数据序列</li><li>多倍性：在系统受限的部件上，同时处于同一执行阶段的指令或数据的最大数目</li></ul><p>可以分为四类：</p><ul><li>单指令流单数据流(SISD)</li><li>单指令流多数据流(SIMD)</li><li>多指令流单数据流(MISD)</li><li>多指令流多数据流(MIMD)</li></ul><p>以上四类的基本结构：IS：指令流，DS：数据流，CS：控制流，CU：控制部件，PU：处理部件，MM和SM：存储器</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/1-1.jpg" style="zoom:50%;" /></p></li></ol><h3 id="定量分析技术">1.3 定量分析技术</h3><h4 id="计算机系统结构的定量原理">计算机系统结构的定量原理</h4><ol type="1"><li><p>以经常性事件为重点(大概率事件优先)</p></li><li><p>Amdahl定律</p><p>系统性能加速比：<strong><span class="math inline">\(加速比=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}\)</span></strong></p><p>加速比依赖于两个因素：</p><ol type="1"><li><p>可改进比例：改进前的系统中，可改进部分的执行时间在总的执行时间中所占的比例</p></li><li><p>部件加速比：可改进部分改进后性能提高的倍数，改进前所需的执行时间于改进后执行时间的比</p></li><li><p>改进后的程序总执行时间： <span class="math display">\[ \begin{align} 总执行时间_{改进后} &amp;= 不可改进部分的执行时间 + 可改进部分改进后的执行时间 \nonumber \\ 总执行时间_{改进后} &amp;= (1-可改进比例)\times总执行时间_{改进前}+\frac{可改进比例\times总执行时间_{改进前}}{部件加速比}  \nonumber \\ &amp;= [(1-可改进比例)+\frac{可改进比例}{部件加速比}]\times总执行时间_{改进前} \nonumber \end{align} \]</span></p></li><li><p>可得加速比为： <span class="math display">\[ \begin{align} 加速比 &amp;= \frac{总执行时间_{改进前}}{总执行时间_{改进后}} \nonumber\\ &amp;= \frac{1}{(1-可改进比例)+\frac{可改进比例}{部件加速比}} \nonumber \end{align} \]</span></p></li><li><p>是一种性能改进的递减规则，如果只针对整个任务的一部分进行改进和优化，那么所获得的加速比不超过1/(1－可改进比例)</p></li></ol></li><li><p>CPU性能公式</p><ol type="1"><li><p>执行一个程序所需的CPU时间</p><p><strong>CPU时间 = 执行程序所需的时钟周期数×时钟周期时间</strong></p><p>时钟周期时间是系统时钟频率的倒数</p></li><li><p>每条指令执行的平均时钟周期数CPI</p><p><strong>CPI = 执行程序所需的时钟周期数/IC，IC所执行的指令条数</strong> 程序执行的CPU时间可以写为：IC ×CPI ×时钟周期时间</p></li><li>CPU的性能取决于3个参数：<ol type="1"><li>时钟周期时间：取决于硬件实现技术和计算机组成</li><li>CPI：取决于计算机组成和指令集结构</li><li>IC：取决于指令集结构和编译技术</li></ol></li><li><p>CPU性能公式进一步细化：</p><p>CPIi ：第i种指令的处理时间 ICi ：在程序中第i种指令出现的次数 <span class="math inline">\(CPU时钟周期数=\sum_{i=1}^{n}{CPI_i\times IC_i}\)</span></p><p><span class="math inline">\(CPI=\frac{时钟周期数}{IC} = \sum_{i=1}^{n}{CPI_i\times \frac{IC_i}{IC}}\)</span></p></li></ol></li><li><p>程序的局部性原理</p><p>程序执行时所访问的存储器地址分布不是随机的，而是相对地簇聚</p><p>常用的应该经验规则：程序执行时间的90%都是在执行程序中10%的代码</p><ul><li><p>程序的时间局部性：</p><p>程序即将用到的信息很可能就是目前正在使用的信息</p></li><li><p>程序的空间局部性：</p><p>程序即将用到的信息很可能与目前正在使用的信息在空间上相邻或者临近</p></li></ul></li></ol><h4 id="计算机系统的性能测评">计算机系统的性能测评</h4><ol type="1"><li><p>执行时间和吞吐率</p><p>用户角度：单个程序的执行时间</p><p>数据管理与：吞吐率（单位时间里能够完成的任务）</p></li><li><p>主要标准：执行程序的时间</p><ol type="1"><li>MIPS，每秒百万条指令数 <span class="math display">\[ \begin{align} MIPS &amp;= 指令条数/(执行时间\times 10^6) \nonumber \\ &amp;= 时钟频率/(CPI\times 10^6) \nonumber \end{align} \]</span></li></ol></li><li><p>MFLOPS，每秒百万次浮点操作次数 = 程序中的浮点操作次数 /（执行时间×10^6）</p></li><li><p>利用基准测试程序</p></li></ol><h3 id="计算机系统结构的发展">1.4 计算机系统结构的发展</h3><h4 id="冯诺依曼结构">冯·诺依曼结构</h4><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/1-2.jpg" style="zoom:50%;" /></p><p>主要特点：（存储程序计算机）</p><ul><li>以运算器为中心。</li><li>在存储器中，指令和数据同等对待</li><li>存储器是按地址访问、按顺序线性编址的一维结构，每个单元的位数是固定的</li><li>指令的执行是顺序的</li><li>指令由操作码和地址码组成</li><li>指令和数据均以二进制编码表示，采用二进制运算</li></ul><h3 id="计算机系统中并行性的发展">1.5 计算机系统中并行性的发展</h3><h4 id="并行性的概念">并行性的概念</h4><ol type="1"><li>并行性：计算机系统在同一时刻或者同一时间间隔内进行多种运算或操作，只要在时间上相互重叠，就存在并行性<ul><li>同时性：两个或两个以上的事件在同一时刻发生。</li><li>并发性：两个或两个以上的事件在同一时间间隔内发生。</li></ul></li><li>从执行程序的角度来看，并行性等级从低到高可分为<ul><li>指令内部并行</li><li>指令级并行</li><li>线程级并行</li><li>任务级或过程级并行</li><li>作业或程序级并行</li></ul></li><li>提高并行性的技术途径<ul><li>时间重叠</li><li>资源重复</li><li>资源共享</li></ul></li></ol><h2 id="第二章-计算机指令集结构mips">第二章 计算机指令集结构（MIPS）</h2><ul><li><p>CISC（复杂指令集计算机）</p><p>增强指令功能，把越来越多的功能交由硬件来实现，并且指令的数量也是越来越多。</p></li><li><p>RISC（精简指令集计算机） 尽可能地把指令集简化，不仅指令的条数少，而且指令的功能也比较简单。</p></li></ul><h2 id="第三章-流水线技术">第三章 流水线技术</h2><h3 id="重叠执行和先行控制">3.1 重叠执行和先行控制</h3><h4 id="重叠执行">重叠执行</h4><p>二次重叠执行过程如下：</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-1.png" style="zoom:48%;" /></p><p>此时，执行n条指令花费的时间为<span class="math inline">\(T=(2+n)t\)</span></p><p>有以下优点：</p><ul><li>时间缩短</li><li>部件利用率提高</li></ul><p>缺点：</p><ul><li>需要增加更多的硬件</li><li>需要设置独立的取指令部件，指令分析部件和指令执行部件</li></ul><p>存在主存的访问冲突问题（读写主存），有以下四种解决方法：</p><ul><li><p>设置两个独立编址的存储器： 指令存储器（存放指令）、数据存储器（存放数据）</p></li><li><p>指令和数据仍然混合存放在同一个主存中，但设置两个Cache：指令Cache、数据Cache，<strong>程序空间和数据空间相互独立的系统结构被称为哈佛结构</strong></p></li><li><p>指令和数据仍然混合存放在同一个主存中，但主存采用多体交叉结构</p></li><li><p>在主存和指令分析部件之间增设指令缓冲站（又被称为先行指令缓冲站 ）</p><p>先行指令缓冲站的组成如下：</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-2.jpg" style="zoom:50%;" /></p><ul><li>指令缓冲存储区和相应的控制逻辑<ul><li>按队列方式工作</li><li>只要指令缓冲站不满，它就自动地向主存控制器发取指令请求，不断地预取指令</li></ul></li><li>指令分析部件<ul><li>每分析完一条指令，就自动向指令缓冲站发出取下一条指令的请求。指令取出之后就把指令缓冲站中的该指令作废</li><li>指令缓冲站中存放的指令的条数是动态变化的</li></ul></li><li>两个程序计数器<ul><li>先行程序计数器PC1：用于从主存预取指令</li><li>现行程序计数器PC：用来记录指令分析部件当前正在分析的指令的地址</li></ul></li></ul></li></ul><p>当每个子过程执行的时间不相等时，会出现部件空闲的情况：</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-3.png" style="zoom:48%;" /></p><h4 id="先行控制">先行控制</h4><ol type="1"><li><p>先行控制技术：缓冲技术和预处理技术的结合</p><ul><li>缓冲技术：在工作速度不固定的两个功能部件之间设置缓冲器，用以平滑它们的工作</li><li>预处理技术：预取指令、对指令进行加工以及预取操作数等。</li></ul></li><li><p>采用先行控制方式的处理机结构</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-4.jpg" style="zoom:50%;" /></p><p>特点：</p><ul><li>缓冲站按先进先出的方式工作</li><li>每个存储单元由3部分组成：先行地址字段、先行操作数字段、标志字段</li></ul></li></ol><h3 id="流水线的基本概念">3.2 流水线的基本概念</h3><h4 id="什么是流水线">什么是流水线</h4><ol type="1"><li>流水线技术<ul><li>把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件来实现</li><li>把多个处理过程在时间上错开，依次通过各功能段，这样，每个子过程就可以与其他的子过程并行进行</li></ul></li><li>流水线中的每个子过程及其功能部件称为流水线的级或段，段与段相互连接形成流水线。流水线的段数称为流水线的深度</li><li>流水技术的特点<ul><li>流水线把一个处理过程分解为若干个子过程（段），每个子过程由一个专门的功能部件来实现</li><li>流水线中各段的时间应尽可能相等，否则将引起流水线堵塞、断流。<strong>时间长的段将成为流水线的瓶颈</strong></li><li>流水线每一个功能部件的后面都要有一个缓冲寄存器（锁存器），称为流水寄存器，在相邻的两段之间传送数据，以保证提供后面要用到的数据，并把各段的处理工作相互隔离</li><li><strong>流水技术适合于大量重复的时序过程，只有在输入端不断地提供任务，才能充分发挥流水线的效率</strong></li><li>流水线需要有通过时间和排空时间<ul><li>通过时间：第一个任务从进入流水线到流出结果所需的时间</li><li>排空时间：最后一个任务从进入流水线到流出结果所需的时间</li></ul></li></ul></li></ol><h4 id="流水线的分类">流水线的分类</h4><ul><li><p>单功能流水线于多功能流水线</p><ul><li>单功能：只能完成一种固定功能的流水线</li><li>多功能：流水线的各段可以进行不同的连接，以实现不同的功能</li></ul></li><li><p>静态与动态流水线</p><ul><li>静态流水线：在同一时间内，多功能流水线中的各段只能按同一种功能的连接方式工作，只有输入为一串相同的运算任务时，流水的效率才得到充分的发挥</li><li>动态流水线：在同一时间内，多功能流水线中的各段可以按照不同的方式连接，同时执行多种功能</li></ul><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-5.png" style="zoom:75%;" /></p></li><li><p>部件级、处理机级及处理机间流水线</p><ul><li>部件级流水线（运算操作流水线）：把处理机的算术逻辑运算部件分段，使得各种类型的运算操作能够按流水方式进行</li><li>处理机级流水线（指令流水线）：把指令的解释执行过程按照流水方式处理。把一条指令的执行过程分解为若干个子过程，每个子过程在独立的功能部件中执行</li><li>处理机间流水线（宏流水线）：它是由两个或者两个以上的处理机串行连接起来，对同一数据流进行处理，每个处理机完成整个任务中的一部分</li></ul></li><li><p>线性流水线和非线性流水线</p><ul><li>线性流水线：流水线的各段串行连接，没有反馈回路。数据通过流水线中的各段时，每一个段最多只流过一次</li><li>非线性流水线：流水线中除了有串行的连接外，还有反馈回路</li></ul></li><li><p>顺序流水线和乱序流水线</p><ul><li>顺序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序完全相同。每一个任务在流水线的各段中是一个跟着一个顺序流动的。</li><li>乱序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序可以不同，允许后进入流水线的任务先完成（从输出端流出）</li></ul></li><li><p>标量处理机与向量流水处理机</p><ul><li>标量处理机：处理机不具有向量数据表示和向量指令，仅对标量数据进行流水处理</li><li>向量流水处理机：具有向量数据表示和向量指令的处理机</li></ul></li></ul><h3 id="流水线的性能指标">3.3 流水线的性能指标</h3><h4 id="吞吐率">吞吐率</h4><blockquote><p>在单位时间内流水线所完成的任务数量或输出结果的数量，<span class="math inline">\(TP=\frac{n}{T_k}\)</span>，其中n为任务数，<span class="math inline">\(T_k\)</span>为处理完成n个任务所用的时间</p></blockquote><ol type="1"><li><p>各段时间均相等的流水线</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-6.jpg" style="zoom:50%;" /></p><p>由图可以得出，此流水线的实际吞吐率为:</p><p><span class="math inline">\(TP=\frac{n}{(k+n-1)\Delta t}\)</span></p><p>最大吞吐率为：</p><p><span class="math inline">\(TP_{max} = lim_{n\rightarrow \infty} \frac{n}{(k+n-1)\Delta t} = \frac{1}{\Delta t}\)</span></p></li><li><p>各段不完全相等的流水线</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-7.jpg" style="zoom:70%;" /></p><p>实际吞吐率如下：</p><p><span class="math inline">\(TP = \frac{n}{\sum_{i=1}^{k}\Delta t_i+(n-1)max(\Delta t_1, \dots,\Delta t_k)}\)</span></p><p>同样的最大吞吐率为：</p><p><span class="math inline">\(TP_{max} = \frac{1}{max(\Delta t_1, \dots,\Delta t_k)}\)</span></p></li></ol><p>解决流水线瓶颈问题的常用方法</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-8.jpg" style="zoom:50%;" /></p><ol type="1"><li><p>细分瓶颈段</p><p>对上图<span class="math inline">\(S_3\)</span>，将其划分为3个子流水线段即可</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-9.jpg" style="zoom:50%;" /></p></li><li><p>重复设置瓶颈段</p><p>使用空间弥补的方法，对$S_3 $只需要设置3个即可</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-10.jpg" style="zoom:50%;" /></p><p>重置后的时空图如下：</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-11.jpg" style="zoom:50%;" /></p></li></ol><h4 id="加速比">加速比</h4><blockquote><p>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比</p></blockquote><p>即：<span class="math inline">\(S=\frac{T_s}{T_k}\)</span>，<span class="math inline">\(T_s\)</span>为顺序执行所用的时间，<span class="math inline">\(T_k\)</span>为流水线后的时间</p><ol type="1"><li><p>流水线各段时间相等</p><p>此时流水线实际加速比为：<span class="math inline">\(S=\frac{nk}{k+n-1}\)</span>，最大加速比为k，当<span class="math inline">\(n\rightarrow \infty\)</span>时取到</p></li><li><p>流水线的各段时间不完全相等时 <span class="math display">\[ S=\frac{n\sum_{i=1}^k \Delta t_i}{\sum_{i=1}^k \Delta t_i+(n-1)max{\Delta t_1,\dots,\Delta t_k}} \]</span></p></li></ol><h4 id="效率">效率</h4><blockquote><p>流水线中的设备实际使用时间与整个运行时间的比值，即流水线设备的利用率。由于流水线有通过时间和排空时间，所以在连续完成n个任务的时间内，各段并不是满负荷地工作</p></blockquote><p>从时空图上看，效率就是n个任务占用的时空面积和k个段总的时空面积之比</p><ol type="1"><li><p>各段时间相等：</p><p>根据面积比可以得出：<span class="math inline">\(E=\frac{n\Delta t}{(k+n-1)\Delta t} = \frac{n}{k+n-1}\)</span>，可以看出和吞吐率有关系，为<span class="math inline">\(E=TP\Delta t\)</span>，同样的和加速比也有关系，<span class="math inline">\(E = \frac{S}{k}\)</span></p></li><li><p>各段时间不相等时： <span class="math display">\[ E=\frac{n\sum_{i=1}^k \Delta t_i}{k[\sum_{i=1}^k \Delta t_i+(n-1)\times max{\Delta t_1,\dots,\Delta t_k}]} \]</span></p></li></ol><h4 id="流水线设计中的若干问题">流水线设计中的若干问题</h4><ol type="1"><li><p>瓶颈问题</p><ul><li>理想情况下，流水线在工作时，其中的任务是同步地每一个时钟周期往前流动一段</li><li>当流水线各段不均匀时，机器的时钟周期取决于瓶颈段的延迟时间</li><li>在设计流水线时，要尽可能使各段时间相等</li></ul></li><li><p>流水线的额外开销</p><ul><li>流水寄存器需要建立时间和传输延迟</li><li>时钟偏移开销</li></ul><p>注意几个细节：</p><ul><li>流水线并不能减少（而且一般是增加）单条指令的执行时间，但却能提高吞吐率</li><li>增加流水线的深度（段数）可以提高流水线的性能</li><li>流水线的深度受限于流水线的额外开销</li><li>当时钟周期小到与额外开销相同时，流水已没意义。因为这时在每一个时钟周期中已没有时间来做有用的工作</li></ul></li><li><p>冲突问题</p></li></ol><h3 id="流水线的相关与冲突">3.4 流水线的相关与冲突</h3><h4 id="经典5段流水线">经典5段流水线</h4><p>虚线代表此处仅花费时钟单元的一半时间, 可以在前半段时间写回后半段从寄存器读取</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-13.jpg" style="zoom:50%;" /></p><ol type="1"><li><p>取指令周期IF</p></li><li><p>指令译码/读寄存器周期（ID）</p></li><li><p>执行/有效地址计算周期（EX）</p><p>4种不同指令所进行的操作不同：</p><ul><li>存储器访问指令：ALU把所指定的寄存器的内容与偏移量相加，形成用于访存的有效地址</li><li>寄存器－寄存器ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读取的数据进行运算</li><li>寄存器－立即数ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读取的第一操作数和立即数进行运算</li><li>分支指令：ALU把偏移量与PC值相加，形成转移目标的地址。同时，对在前一个周期读出的操作数进行判断，确定分支是否成功</li></ul></li><li><p>存储器访问／分支完成周期（MEM）</p><p>该周期处理的指令只有load、store和分支指令（分支“成功”，就把转移目标地址送入PC）。其他类型的指令在此周期不做任何操作</p></li><li><p>写回周期（WB）</p><p>ALU运算指令和load指令在这个周期把结果数据写入通用寄存器组</p></li></ol><p>采用流水线实现时需要解决的问题：</p><ol type="1"><li>要保证不会在同一时钟周期要求同一个功能段做两件不同的工作</li><li>避免IF段的访存（取指令）与MEM段的访存（读/写数据）发生冲突</li><li>ID段和WB段都要访问同一寄存器文件，<strong>把写操作安排在时钟周期的前半拍完成，把读操作安排在后半拍完成</strong>，解决对同一寄存器的访问冲突</li><li>考虑PC的问题，在MEM段进行的分支和IF段取下一个PC的冲突</li></ol><h4 id="相关与流水线冲突">相关与流水线冲突</h4><h5 id="相关">相关</h5><blockquote><p>两条指令之间存在某种依赖关系。如果两条指令相关，则它们就有可能不能在流水线中重叠执行或者只能部分重叠执行</p></blockquote><p>有三种类型：</p><p><strong>前提条件：对于两个指令i，j且i在j前</strong></p><ul><li><p><strong>数据相关（真数据相关）</strong></p><p>满足下列条件表明j与i数据相关，数据相关具有传递性</p><ul><li>指令j使用指令i产生的结果</li><li>指令j与k数据相关，k与i数据相关</li></ul><p>寄存器的数据相关比较容易检测，单存储器检测比较复杂，因为有效地址生成的规则复杂</p></li><li><p><strong>名相关</strong></p><p>如果两条指令使用相同的名，但是它们之间并<strong>没有数据流动</strong>（不存在数据相关），则称这两条指令存在名相关，如果一条指令中的名改变了，并不影响另外一条指令的执行</p><ul><li>反相关：指令j写的名＝指令i读的名</li><li>输出相关：指令j写的名＝指令i写的名</li></ul><p>通过<strong>换名技术</strong>消除名相关：通过改变指令中操作数的名来消除名相关，对于寄存器操作数进行换名称为寄存器换名</p></li><li><p><strong>控制相关</strong></p><p>控制相关是指由分支指令引起的相关，有以下两个限制</p><ul><li>与一条分支指令控制相关的指令不能被移到该分支之前，否则这些指令就不受该分支控制了</li><li>如果一条指令与某分支指令不存在控制相关，就不能把该指令移到该分支之后</li></ul></li></ul><h5 id="流水线冲突">流水线冲突</h5><blockquote><p>是指对于具体的流水线来说，由于相关的存在，使得指令流中的下一条指令不能在指定的时钟周期执行</p></blockquote><p>带来的问题：</p><ul><li>导致错误的执行结果</li><li>流水线可能会出现停顿，从而降低流水线的效率和实际的加速比</li></ul><p>当一条指令被暂停时，在该暂停指令之后流出的所有指令都要被暂停，而在该暂停指令之前流出的指令则继续进行（否则就永远无法消除冲突）</p><p>有三种类型：</p><ul><li><p><strong>结构冲突</strong></p><p>因硬件资源满足不了指令重叠执行的要求而发生的冲突</p><p>有些流水线处理机只有一个存储器，将数据和指令放在一起，访存指令会导致访存冲突</p><p><strong>通过插入暂停周期（气泡）</strong>解决，或者设置独立的指令存储器和数据存储器或者设置独立的Cache</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-14.jpg" style="zoom:40%;" /></p><p>插入气泡后：</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-15.jpg" style="zoom:40%;" /></p><p>结构冲突有时候是允许的，可以减少硬件成本</p></li><li><p><strong>数据冲突</strong></p><p>当指令在流水线中重叠执行时，因需要用到前面指令的执行结果而发生的冲突</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-16.jpg" style="zoom:40%;" /></p><p><strong>前提条件：对于两个指令i，j且i在j前</strong>，有以下三种类型：</p><ul><li><p>写后读冲突RAW</p><p>在i写之前j去读，对于真数据相关</p></li><li><p>写后写冲突WAW</p><p>在i写入之前j先写，对应输出相关</p><p>仅发生在这样的流水线中：</p><ul><li>流水线中不只一个段可以进行写操作</li><li>当先前某条指令停顿时，允许其后续指令继续前进</li></ul><p>我们之前的5段流水线不会发生</p></li><li><p>读后写冲突WAR</p><p>在i读之前j先写，对应反相关</p><p>仅发生这样的流水线中：</p><ul><li>有些指令的写结果操作提前了，而且有些指令的读操作滞后了</li><li>指令被重新排序了</li></ul><p>我们之前的5段流水线不会发生</p></li></ul><p><strong>通过定向技术（也称为旁路或短路），减少数据冲突引起的停顿：</strong></p><p>关键思想：在某条指令产生计算结果之前，后面等待使用该结果的指令并不一定立即需要该结果，如果能够将该计算结果从其产生的地方（ALU出口）直接送到其他指令需要它的地方（ALU入口），那么就可以避免停顿。</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-17.jpg" style="zoom:40%;" /></p><p>并不是所有的数据冲突都可以用定向技术来解决，必要时需要增加<strong>暂停</strong>：</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-18.jpg" style="zoom:40%;" /></p><p><strong>通过编译器解决数据冲突</strong></p><p>改变指令的执行顺序解决数据冲突</p></li><li><p><strong>控制冲突</strong></p><p>流水线遇到分支指令和其他会改变PC值的指令所引起的冲突</p><p>处理分支指令最简单的方法：排空流水线，给流水线带来3个时钟周期的延迟</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-19.jpg" style="zoom:70%;" /></p><p>由分支指令引起的延迟为<strong>分支延迟</strong></p><p>可采取两种措施来减少分支延迟</p><ul><li>在流水线中尽早判断出分支转移是否成功</li><li>尽早计算出分支目标地址</li></ul><p>下面的讨论中，我们假设：这两步工作被提前到ID段完成，即分支指令是在ID段的末尾执行完成，所带来的分支延迟为一个时钟周期</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-20.jpg" style="zoom:50%;" /></p><p><strong>减少分支延迟的方法</strong>:</p><p>共同点:</p><ul><li>对分支的处理方法在程序的执行过程中始终是不变的，是静态的</li><li><p>要么总是预测分支成功，要么总是预测分支失败</p></li><li><p><strong>预测分支失败</strong></p><p>允许分支指令后的指令继续在流水线中流动，就好象什么都没发生似的 若确定分支失败，将分支指令看作是一条普通指令，流水线正常流动</p><p>要保证：分支结果出来之前不会改变处理机的状态，以便一旦猜错时，处理机能够回退到原先的状态</p></li></ul></li><li><p><strong>预测分支成功</strong></p><p>假设分支转移成功，并从分支目标地址处取指令执行。 起作用的前题：先知道分支目标地址，后知道分支是否成功 前述5段流水线中，这种方法没有任何好处</p></li><li><p><strong>延迟分支</strong></p><p>从逻辑上“延长”分支指令的执行时间。把延迟分支看成是由原来的分支指令和若干个延迟槽构成，不管分支是否成功，都要按顺序执行延迟槽中的指令</p><pre><code>  &lt;img src=&quot;/assets/Note/计算机系统结构-张晨曦-第二版/3-21.jpg&quot; style=&quot;zoom:70%;&quot; /&gt;</code></pre><p>分支延迟指令的调度:</p><ul><li><p>从前调度</p><ul><li>从目标处调度</li></ul></li><li><p>从失败处调度</p></li></ul><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-22.jpg" style="zoom:70%;" /></p><pre><code>  分支延迟受到两个方面的限制：</code></pre><ul><li>可以被放入延迟槽中的指令要满足一定的条件<ul><li>编译器预测分支转移方向的能力。</li></ul><p>进一步改进：分支取消机制（取消分支） 当分支的实际执行方向和事先所预测的一样时，执行分支延迟槽中的指令，否则就将分支延迟槽中的指令转化成一个空操作</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-23.jpg" style="zoom:70%;" /></p></li></ul></li></ul><h3 id="向量处理机">3.5 向量处理机</h3><blockquote><p>在流水线处理机中，设置向量数据表示和相应的向量指令，称为向量处理机。 不具有向量数据表示和相应的向量指令的流水线处理机，称为标量处理机</p></blockquote><h2 id="第四章-指令级并行">第四章 指令级并行</h2><h3 id="指令级并行的概念-ilp">4.1 指令级并行的概念 ILP</h3><p>几乎所有的处理机都利用流水线来使指令重叠并行执行，以达到提高性能的目的。这种指令之间存在的潜在并行性称为指令级并行 ILP：Instruction-Level Parallelism</p><h3 id="指令的调度">4.2 指令的调度</h3><h4 id="静态和动态调度">静态和动态调度</h4><ul><li><p>静态调度</p><p><strong>依靠编译器</strong>对代码进行静态调度，以减少相关和冲突。它不是在程序执行的过程中、而是在编译期间进行代码调度和优化。通过把相关的指令拉开距离来减少可能产生的停顿</p></li><li><p>动态调度</p><p>在程序的执行过程中，<strong>依靠专门硬件</strong>对代码进行调度，减少数据相关导致的停顿</p><p>优点：</p><ol type="1"><li>能够处理一些在编译时情况不明的相关（比如涉及到存储器访问的相关），并简化了编译器</li><li>能够使本来是面向某一流水线优化编译的代码在其他的流水线（动态调度）上也能高效地执行</li></ol><p>但增加了硬件复杂性</p></li></ul><h4 id="非线性流水线的调度问题">非线性流水线的调度问题</h4><p>非线性流水线中由于有些段需要在时间上复用，就不能像线性流水线那样逐时段连续地输入指令。把前一条指令输入开始到下一条指令输入为止的时间差，称为<strong>启动距离</strong></p><p>那些会引起冲突的启动距离，被称为禁止启动距离。将在任何时间都不会发生冲突的启动距离称为启动循环</p><h4 id="最优调度方法">最优调度方法</h4><p>为了避免冲突，就要对指令输入流水线的时间进行控制，这个任务就是流水线的无冲突调度。方案如下：</p><ol type="1"><li><p><strong>根据预约表写出禁止向量</strong></p><p>禁止向量：各个段内的X标记的差的集合</p></li><li><p><strong>由禁止向量变换成初始冲突向量</strong></p><p>使用<span class="math inline">\(初始冲突向量：C_0=(C_mC_{m-1}\dots C_2C_1)\)</span>，m为冲突向量的最大值，根据禁止向量，令<span class="math inline">\(C_m = 1\)</span>，仅当<span class="math inline">\(m \in 禁止向量\)</span></p></li><li><p><strong>根据初始冲突向量推算出全部冲突向量</strong></p><p>从初始冲突向量出发，检查其中0的位，假设初始向量中<span class="math inline">\(C_k = 0\)</span>，就将初始向量右移K位之后和初始向量执行或运算，若得到一个新的向量，继续检查0的位，执行右移运算，并和<span class="math inline">\(C_0\)</span>做或运算，直到不存在新的向量</p></li><li><p><strong>画出表示冲突向量迁移的有向图</strong></p><p>节点值为向量，边权为右移的位数，构建有向图</p></li><li><p><strong>从全部调度方案中选出最优调度法</strong></p><p>从<strong>各个闭合回路</strong>（不需要从初始向量出发）中找出平均间隔最小的一个，平均间隔为边权和除以边数</p></li></ol><p>例题：</p><p>某单功能流水线预约表如下：</p><table><thead><tr class="header"><th></th><th>t1</th><th>t2</th><th>t3</th><th>t4</th><th>t5</th><th>t6</th></tr></thead><tbody><tr class="odd"><td>S1</td><td>×</td><td></td><td></td><td></td><td>×</td><td></td></tr><tr class="even"><td>S2</td><td></td><td>×</td><td></td><td></td><td></td><td>×</td></tr><tr class="odd"><td>S3</td><td></td><td></td><td>×</td><td></td><td></td><td></td></tr><tr class="even"><td>S4</td><td></td><td></td><td></td><td>×</td><td></td><td></td></tr></tbody></table><p>请确定最佳调度方案。按此方案输入8个指令时，性能指标如何？</p><p>禁止向量为：<span class="math inline">\(F={4}\)</span>，初始冲突向量为：<span class="math inline">\(C_0 = (1000)\)</span></p><p>获取状态转换图：</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-1.jpg" style="zoom:50%;" /></p><p>其中5权值边可以看作是0C，右移5位形成的，构建成新的闭合回路</p><p>可以获得调度方案如下：</p><table><thead><tr class="header"><th>回路</th><th>平均间隔</th><th>回路</th><th>平均间隔</th></tr></thead><tbody><tr class="odd"><td>1,5</td><td>6/2</td><td>2,1,2,5</td><td>10/4</td></tr><tr class="even"><td>1,1,5</td><td>7/3</td><td>2,3,5</td><td>10/3</td></tr><tr class="odd"><td><strong>1,1,1,5</strong></td><td><strong>8/4</strong></td><td>3,5</td><td>8/2</td></tr><tr class="even"><td>1,2,5</td><td>8/3</td><td>3</td><td>3</td></tr><tr class="odd"><td>1,2,3,5</td><td>11/4</td><td>3,2,5</td><td>10/3</td></tr><tr class="even"><td>2,5</td><td>7/3</td><td>3,2,1,5</td><td>11/4</td></tr><tr class="odd"><td>2,1,5</td><td>8/3</td><td>2,3</td><td>5/2</td></tr></tbody></table><p>最佳方案为1，1，1，5，平均最少延时为2拍</p><p>8个指令进入流水线的时空图如下：</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-2.jpg" style="zoom:50%;" /></p><p>吞吐率 P = 8/(17Δt)； 加速比 S = (6Δt×8)/(17Δt)=48/17 效率 E = (6Δt×8) /(17Δt×4)=12/17</p><h4 id="动态调度的基本思想">动态调度的基本思想</h4><p>到目前为止我们所使用流水线的最大的局限性，指令必须按序流出和执行，一旦一条指令受阻，其后的指令都将停顿，可以通过乱序执行解决。动态调度的流水线支持多条指令同时处于执行当中。</p><p>指令乱序完成带来的最大问题：</p><ul><li><p>异常处理比较复杂</p></li><li><p>动态调度要保持正确的异常行为</p><p>只有那些在程序严格按程序顺序执行时会发生的异常，才能真正发生</p></li></ul><h4 id="tomasulo算法">Tomasulo算法</h4><blockquote><p>记录和检测指令相关，操作数一旦就绪就立即执行，把发生RAW冲突的可能性减少到最小通过寄存器换名来消除WAR冲突和WAW冲突</p></blockquote><p>基于MIPS的Tomasulo基本结构：</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-3.jpg" style="zoom:50%;" /></p><ul><li><p>保留站</p><p>每个保留站中保存一条已经流出并等待到本功能部件执行的指令（相关信息）包括：操作码、操作数以及用于检测和解决冲突的信息</p><p>上图有3个浮点加法器保留站，2个浮点乘法器保留站</p><p>每个保留站都有一个标识字段，唯一地标识了该保留站</p></li><li><p>公共数据总线CDB</p><p>所有功能部件的计算结果都是送到CDB上，由它把这些结果直接送到（播送到）各个需要该结果的地方。在具有多个执行部件且采用多流出（即每个时钟周期流出多条指令）的流水线中，需要采用多条CDB</p></li><li><p>load缓冲器和store缓冲器</p><p>存放读/写存储器的数据或地址 load缓冲器的作用有3个：</p><ul><li>存放用于计算有效地址的分量</li><li>记录正在进行的load访存，等待存储器的响应</li><li>保存已经完成了的load的结果（即从存储器取来的数据），等待CDB传输</li></ul><p>store缓冲器的作用有3个：</p><ul><li>存放用于计算有效地址的分量</li><li>保存正在进行的store访存的目标地址，该store正在等待存储数据的到达</li><li>保存该store的地址和数据，直到存储部件接收</li></ul></li><li><p>浮点寄存器FP</p><p>它们通过一对总线连接到功能部件，并通过CDB连接到store缓冲器</p></li><li><p>指令队列</p><p>指令部件送来的指令放入指令队列 指令队列中的指令按先进先出的顺序流出</p></li><li><p>运算部件</p></li></ul><p>Tomasulo算法具有以下两个特点:</p><ul><li>冲突检测和指令执行控制是分布的</li><li>计算结果通过CDB直接从产生它的保留站传送到所有需要它的功能部件，而不用经过寄存器</li></ul><p>指令执行的步骤：</p><ol type="1"><li><p><strong>流出：从指令队列的头部取一条指令</strong></p><ul><li>如果该指令的操作所要求的保留站有空闲的，就把该指令送到该保留站</li><li>如果其操作数在寄存器中已经就绪，就将这些操作数送入保留站</li><li>如果其操作数还没有就绪，就把将产生该操作数的保留站的标识送入保留站</li><li>一旦被记录的保留站完成计算，它将直接把数据送给保留站</li><li>完成对目标寄存器的预约工作</li><li>如果没有空闲的保留站，指令就不能流出</li></ul></li><li><p><strong>执行</strong></p><ul><li>当两个操作数都就绪后，本保留站就用相应的功能部件开始执行指令规定的操作</li><li>load和store指令的执行需要两个步骤：<ul><li>计算有效地址（要等到基地址寄存器就绪）</li><li>把有效地址放入load或store缓冲器</li></ul></li></ul></li><li><p><strong>写结果</strong></p><p>功能部件计算完毕后，就将计算结果放到CDB上，所有等待该计算结果的寄存器和保留站（包括store缓冲器）都同时从CDB上获得所需要的数据</p></li></ol><p>Tomasulo示例：</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-4.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-5.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-6.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-7.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-8.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-9.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-10.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-11.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-12.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-13.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-14.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-15.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-16.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-17.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-18.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-19.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-20.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-21.jpg" style="zoom:50%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-22.jpg" style="zoom:50%;" /></p><h3 id="动态分支预测技术">4.3 动态分支预测技术</h3><p>所开发的ILP越多，控制相关的制约就越大，分支预测就要有更高的准确度</p><p><strong>动态分支预测：</strong>在程序运行时，根据分支指令过去的表现来预测其将来的行为</p><p>分支预测的有效性取决于:</p><ul><li><p>预测的准确性</p></li><li><p>预测正确和不正确两种情况下的分支开销</p><p>决定分支开销的因素</p><ul><li>流水线的结构</li><li>预测的方法</li><li>预测错误时的恢复策略等</li></ul></li><li><p>采用动态分支预测技术的目的</p><ul><li>预测分支是否成功</li><li>尽快找到分支目标地址（或指令）</li></ul></li></ul><h4 id="采用分支历史表-bht">采用分支历史表 BHT</h4><blockquote><p>最简单的动态分支预测方法，用BHT来记录分支指令最近一次或几次的执行情况（成功或不成功），并据此进行预测</p></blockquote><ul><li><p>只有1个预测位的分支预测缓冲</p><p>记录分支指令最近一次的历史，BHT中只需要1位二进制位</p></li><li><p>采用两位二进制位来记录历史</p><p>提高预测的准确度，研究结果表明：两位分支预测的性能与n位（n&gt;2）分支预测的性能差不多</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-23.jpg" style="zoom:50%;" /></p></li></ul><p>适用情况：</p><p><strong>判定分支是否成功所需的时间大于确定分支目标地址所需的时间</strong></p><p>由于判定分支是否成功和计算分支目标地址都是在ID段完成，所以BHT方法不会给该流水线带来好处。</p><h4 id="采用分支目标缓冲器btb">采用分支目标缓冲器BTB</h4><p>目标：将分支的开销降为 0</p><p>方法：分支目标缓冲</p><ul><li>将分支成功的分支指令的地址和它的分支目标地址都放到一个缓冲区中保存起来，缓冲区以分支指令的地址作为标识</li><li>这个缓冲区就是分支目标缓冲器（Branch-Target Buffer，简记为BTB，或者Branch-Target Cache）</li></ul><p>结构如下：</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-24.jpg" style="zoom:50%;" /></p><p>看成是用专门的硬件实现的一张表格。 表格中的每一项至少有两个字段：</p><ul><li>执行过的成功分支指令的地址；（作为该表的匹配标识 ）</li><li>预测的分支目标地址</li></ul><p>执行流程如下：</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-25.jpg" style="zoom:50%;" /></p><p>BTB的另一种形式:</p><p>在分支目标缓冲器中存放一条或者多条分支目标处的指令，有三个好处：</p><ul><li>更快地获得分支目标处的指令</li><li>可以一次提供分支目标处的多条指令，这对于多流出处理器是很有必要的</li><li>使我们可以进行称为分支折叠（branch folding）的优化</li></ul><h4 id="基于硬件的前瞻执行">基于硬件的前瞻执行</h4><p>基本思想（延迟写入）：</p><p>对分支指令的结果进行猜测，并假设这个猜测总是对的，然后按这个猜测结果继续取、流出和执行后续的指令。只是执行指令的结果不是写回到寄存器或存储器，而是放到一个称为ROB（ReOrder Buffer）的缓冲器中。等到相应的指令得到“确认”（commit）（即确实是应该执行的）之后，才将结果写入寄存器或存储器</p><ol type="1"><li><p>基于硬件的前瞻执行结合了三种思想</p><ul><li>动态分支预测。用来选择后续执行的指令</li><li>在控制相关的结果尚未出来之前，前瞻地执行后续指令</li><li>用动态调度对基本块的各种组合进行跨基本块的调度</li></ul></li><li><p>对Tomasulo算法加以扩充，就可以支持前瞻执行</p><p>把Tomasulo算法的写结果和指令完成加以区分，分成两个不同的段：</p><ul><li><p>写结果段</p><p>把前瞻执行的结果写到ROB中通过CDB在指令之间传送结果，供需要用到这些结果的指令使用</p></li><li><p>指令确认段</p><p>在分支指令的结果出来后，对相应指令的前瞻执行给予确认。如果前面所做的猜测是对的，把在ROB中的结果写到寄存器或存储器。如果发现前面对分支结果的猜测是错误的，那就不予以确认，并从那条分支指令的另一条路径开始重新执行。</p></li></ul></li></ol><p><strong>实现前瞻的关键思想</strong>：允许指令乱序执行，但必须顺序确认</p><p>符合前瞻执行的结构：</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-26.jpg" style="zoom:50%;" /></p><p>ROB中的每一项由以下4个字段组成：</p><ul><li><p>指令类型</p><p>指出该指令是分支指令、store指令或寄存器操作指令</p></li><li><p>目标地址 给出指令执行结果应写入的目标寄存器号（如果是load和ALU指令）或存储器单元的地址（如果是store指令）</p></li><li><p>数据值字段 用来保存指令前瞻执行的结果，直到指令得到确认</p></li><li><p>就绪字段 指出指令是否已经完成执行并且数据已就绪</p></li></ul><p>Tomasulo算法中保留站的换名功能是由ROB来完成的</p><p><strong>采用前瞻执行机制后，指令的执行步骤</strong>：</p><ol type="1"><li><p>流出</p><ul><li>从浮点指令队列的头部取一条指令</li><li>如果有空闲的保留站（设为r）且有空闲的ROB项（设为b），就流出该指令，并把相应的信息放入保留站r和ROB项b</li><li>如果保留站或ROB全满，便停止流出指令，直到它们都有空闲的项</li></ul></li><li><p>执行</p><ul><li>如果有操作数尚未就绪，就等待，并不断地监测CDB。(检测RAW冲突)</li><li>当两个操作数都已在保留站中就绪后，就可以执行该指令的操作</li></ul></li><li><p>写结果</p><ul><li>当结果产生后，将该结果连同本指令在流出段所分配到的ROB项的编号放到CDB上，经CDB写到ROB以及所有等待该结果的保留站</li><li>释放产生该结果的保留站</li><li>store指令在本阶段完成，其操作为：<ul><li>如果要写入存储器的数据已经就绪，就把该数据写入分配给该store指令的ROB项。</li><li>否则，就监测CDB，直到那个数据在CDB上播送出来，这时才将之写入分配给该store指令的ROB项。</li></ul></li></ul></li><li><p>确认</p><p>对分支指令、store指令以及其他指令的处理不同</p><ul><li><p>其他指令（除分支指令和store指令）</p><p>当该指令到达ROB队列的头部而且其结果已经就绪时，就把该结果写入该指令的目标寄存器，并从ROB中删除该指令</p></li><li><p>store指令</p><p>处理与上面类似，只是它把结果写入存储器</p></li><li><p>分支指令</p><ul><li>当预测错误的分支指令到达ROB队列的头部时，清空ROB，并从分支指令的另一个分支重新开始执行（错误的前瞻执行）</li><li>当预测正确的分支指令到达ROB队列的头部时，该指令执行完毕</li></ul></li></ul></li></ol><h3 id="多指令流出技术">4.4 多指令流出技术</h3><ol type="1"><li>多流出处理机有两种基本风格<ul><li>超标量<ul><li>在每个时钟周期流出的指令条数不固定，依代码的具体情况而定。（有上限）</li><li>设这个上限为n，就称该处理机为n流出</li><li>可以通过编译器进行静态调度，也可以基于Tomasulo算法进行动态调度</li></ul></li><li>超长指令字VLIW<ul><li>在每个时钟周期流出的指令条数是固定的，这些指令构成一条长指令或者一个指令包。</li><li>指令包中，指令之间的并行性是通过指令显式地表示出来的。</li><li>指令调度是由编译器静态完成的</li></ul></li></ul></li><li>超标量处理机与VLIW处理机相比有两个优点<ul><li>超标量结构对程序员是透明的，因为处理机能自己检测下一条指令能否流出，从而不需要重新排列指令来满足指令的流出。</li><li>即使是没有经过编译器针对超标量结构进行调度优化的代码或是旧的编译器生成的代码也可以运行，当然运行的效果不会很好</li></ul></li></ol><h4 id="基于动态调度的多流出技术">基于动态调度的多流出技术</h4><p>扩展Tomasulo算法：支持两路超标量</p><ul><li>每个时钟周期流出两条指令</li><li>一条是整数指令，另一条是浮点指令</li></ul><ol type="1"><li><p>采用一种比较简单的方法</p><ul><li>指令按顺序流向保留站，否则会破坏程序语义</li><li>将整数所用的表结构与浮点用的表结构分离开，分别进行处理，这样就可以同时地流出一条浮点指令和一条整数指令到各自的保留站</li></ul></li><li><p>有两种不同的方法可以实现多流出</p><p>关键在于：对保留站的分配和对流水线控制表格的修改</p><ul><li>在半个时钟周期里完成流出步骤，这样一个时钟周期就能处理两条指令。</li><li>设置一次能同时处理两条指令的逻辑电路</li></ul></li></ol><h4 id="超长指令字技术vliw">超长指令字技术（VLIW）</h4><ul><li>把能并行执行的多条指令组装成一条很长的指令。（100多位到几百位）</li><li>设置多个功能部件</li><li>指令字被分割成一些字段，每个字段称为一个操作槽，直接独立地控制一个功能部件</li><li>在VLIW处理机中，所有的处理和指令安排都是由编译器完成的</li></ul><p>VLIW存在的一些问题</p><ul><li><p>程序代码长度增加了</p><ul><li>提高并行性而进行的大量的循环展开</li><li>指令字中的操作槽并非总能填满</li></ul></li><li><p>采用了锁步机制</p><p>任何一个操作部件出现停顿时，整个处理机都要停顿</p></li><li><p>机器代码的不兼容性</p></li></ul><h4 id="多流出处理器受到的限制">多流出处理器受到的限制</h4><ol type="1"><li>程序所固有的指令级并行性</li><li>硬件实现上的困难</li><li>超标量和超长指令字处理器固有的技术限制</li></ol><h5 id="超流水线处理机">超流水线处理机</h5><ul><li>将每个流水段进一步细分，这样在一个时钟周期内能够分时流出多条指令。这种处理机称为超流水线处理机。</li><li>对于一台每个时钟周期能流出n条指令的超流水线计算机来说，这n条指令不是同时流出的，而是每隔1/n个时钟周期流出一条指令实际上该超流水线计算机的流水线周期为1/n个时钟周期</li></ul><h2 id="第5章-存储层次">第5章 存储层次</h2><h3 id="存储器的层次结构">5.1 存储器的层次结构</h3><p>假设：S（容量），<span class="math inline">\(T_A\)</span>（访问时间），C（每位价格）</p><p>假设由M1和M2构成的两级存储层次</p><p>M1的参数为：<span class="math inline">\(S_1,T_{A1},C_1\)</span></p><p>M2的参数为：<span class="math inline">\(S_1,T_{A1},C_1\)</span></p><ol type="1"><li><p>每位价格：<span class="math inline">\(C=\frac{C_1S_1+C_2S_2}{S_1+S_2}\)</span></p></li><li><p>命中率和失效率</p><ul><li>命中率：<span class="math inline">\(H=\frac{N_1}{N_1+N_2}\)</span>，N1为访问M1的次数，N2为访问M2的次数</li><li>失效率：<span class="math inline">\(F=1-H\)</span></li></ul></li><li><p>平均访问时间 <span class="math display">\[ \begin{align} T_A &amp;= HT_{A1}+(1-H)(T_{A1}+T_M) \nonumber \\ &amp;= T_{A1}+(1-H)T_M \nonumber \\ &amp;= T_A1+FT_M \nonumber \\ \end{align} \nonumber \\ T_M 为失效开销，从向M_2发出访问请求到把整个数据块调入M_1中所需的时间 \\ T_M = T_{A2} + T_B \\ T_B为传送一个信息块所需的时间 \]</span></p></li></ol><ul><li>“Cache－主存”层次：弥补主存速度的不足</li><li>“主存－辅存”层次： 弥补主存容量的不足</li></ul><h3 id="cache的基本知识">5.2 Cache的基本知识</h3><h4 id="映像规则">映像规则</h4><ul><li><p>全相联规则</p><p>主存中的任一块可以被放置到Cache中的任意一个位置</p></li><li><p>直接映像</p><p>主存中的每一块只能被放置到Cache中唯一的一个位置，取模运算（模Cache的块数）</p></li><li><p>组相联映像</p><p>主存中的每一块可以被放置到Cache中唯一的一个组中的任何一个位置</p><p>若主存第i 块映象到第k 组，则：$K=i G $，G为Cache的组数</p><p>n路组相联，每组中有n个块，n也称为相联度，相联度越高，Cache空间的利用率就越高，块冲突概率就越低，失效率也就越低</p></li></ul><h4 id="查找算法">查找算法</h4><p>通过查找目录表来实现</p><p>目录表结构：</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-1.png" style="zoom:48%;" /></p><h4 id="替换算法">替换算法</h4><ul><li><p>随机法</p></li><li><p>先进先出法FIFO</p></li><li><p>最近最少使用法LRU</p><p>选择近期最少被访问的块作为被替换的块，选择最久没有被访问过的块作为被替换的块，失效率低</p></li></ul><h4 id="写策略">写策略</h4><p>“写”在所有访存操作中所占的比例：</p><p>统计结果表明，对于一组给定的程序：</p><ul><li>load指令：26％</li><li>store指令：9％</li></ul><p>“写”在所有访存操作中所占的比例：9％/(100％＋26％＋9％)≈7％（100%指：取指令的指令访存） “写”在访问数据Cache操作中所占的比例：9％/(26％＋9％)≈25％</p><p>“写”操作必须在确认是命中后才可进行，“写”访问有可能导致Cache和主存内容的不一致</p><p>两种写策略：</p><ul><li><p>写直达法：</p><p>执行“写”操作时，不仅写入Cache，而且也写入下一级存储器</p><p>易于实现，一致性好</p></li><li><p>写回法：</p><p>执行“写”操作时，只写入Cache。仅当Cache中相应的块被替换时，才写回主存</p><p>速度快，所使用的存储器带宽较低</p></li></ul><p>采用写直达法时，若在进行“写”操作的过程中CPU必须等待，直到“写”操作结束，则称CPU写停顿，减少写停顿的一种常用的优化技术：<strong>采用写缓冲器</strong></p><p>“写”操作时的调块：</p><ul><li><p>按写分配(写时取)</p><p>写失效时，先把所写单元所在的块调入Cache，再行写入</p></li><li><p>不按写分配(绕写法)</p><p>写失效时，直接写入下一级存储器而不调块</p></li></ul><p>写策略与调块：</p><ul><li>写回法 ── 按写分配</li><li>写直达法 ── 不按写分配</li></ul><h4 id="cache的性能分析">Cache的性能分析</h4><ul><li><p>失效率</p><ul><li>与硬件速度无关</li><li>容易产生一些误导</li></ul></li><li><p>平均访存时间</p><p><strong>平均访存时间 ＝ 命中时间＋失效率×失效开销</strong></p></li><li><p>程序执行时间</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-2.png" style="zoom:48%;" /></p></li></ul><p>Cache失效对于一个CPI较小而时钟频率较高的CPU来说，影响是双重的：</p><ul><li><p>CPIexecution越低，固定周期数的Cache失效开销的相对影响就越大</p></li><li><p>在计算CPI时，失效开销的单位是时钟周期数。因此，即使两台计算机的存储层次完全相同，时钟频率较高的CPU的失效开销较大，其CPI中存储器停顿这部分也就较大</p><p><strong>存储器停顿时钟周期数＝访存次数×失效率×失效开销</strong></p></li></ul><p>因此Cache对于低CPI、高时钟频率的CPU来说更加重要</p><h4 id="改进cache的性能">改进Cache的性能</h4><ul><li><strong>平均访存时间＝命中时间＋失效率×失效开销</strong></li><li>可以从三个方面改进Cache的性能：<ul><li>降低失效率</li><li>减少失效开销</li><li>减少Cache命中时间</li></ul></li></ul><h3 id="降低cache失效率的方法">5.3 降低Cache失效率的方法</h3><p>三种失效：</p><ul><li><p>强制失效</p><p>当第一次访问一个块时，该块不在Cache中，需从下一级存储器中调入Cache</p></li><li><p>容量失效</p><p>如果程序执行时所需的块不能全部调入Cache中，则当某些块被替换后，若又重新被访问，就会发生失效</p></li><li><p>冲突失效</p><p>在组相联或直接映象Cache中，若太多的块映象到同一组(块)中，则会出现该组中某个块被别的块替换(即使别的组或块有空闲位置)，然后又被重新访问的情况</p></li></ul><p>失效和Cache容量大小的关系：</p><ul><li>相联度越高，冲突失效就越少</li><li>强制性失效和容量失效不受相联度的影响</li><li>强制性失效不受Cache容量的影响，但容量失效却随着容量的增加而减少</li><li>大小为N的直接映象Cache的失效率约等于大小为N/2的2路组相联Cache的失效率</li></ul><p>减少三种失效的方法：</p><ul><li>强制性失效：增加块大小，预取</li><li>容量失效：增加容量</li><li>冲突失效：提高相联度</li></ul><p><strong>许多降低失效率的方法会增加命中时间或失效开销</strong></p><h4 id="增加cache块大小">1. 增加Cache块大小</h4><p>对于给定的Cache容量，当块大小增加时，失效率开始是下降，后来反而上升了</p><p>原因：</p><ul><li>一方面它减少了强制性失效</li><li>另一方面，由于增加块大小会减少Cache中块的数目，所以有可能会增加冲突失效</li></ul><p>Cache容量越大，使失效率达到最低的块大小就越大</p><p>增加块大小会增加失效开销</p><h4 id="提高相联度">2. 提高相联度</h4><p>采用相联度超过8的方案的实际意义不大</p><p>2:1 Cache经验规则：容量为N的直接映象Cache的失效率和容量为N/2的2路组相联Cache的失效率差不多相同</p><p>提高相联度是以增加命中时间为代价</p><h4 id="增加cache的容量">3. 增加Cache的容量</h4><p>最直接的方法是增加Cache的容量 缺点:</p><ul><li>增加成本</li><li>可能增加命中时间</li></ul><p>这种方法在片外Cache中用得比较多</p><h4 id="victim-cache">4. Victim Cache</h4><p>一种能减少冲突失效次数而又不影响时钟频率的方法 基本思想：</p><p>在Cache和它从下一级存储器调数据的通路之间设置一个全相联的小Cache，用于存放被替换出去的块(称为Victim)，以备重用</p><p>作用：对于减小冲突失效很有效，特别是对于小容量的直接映象数据Cache，作用尤其明显</p><h4 id="伪相联-cache">5. 伪相联 Cache</h4><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-3.png" style="zoom:60%;" /></p><p>伪相联Cache的优点：</p><ul><li>命中时间小</li><li>失效率低</li></ul><p>基本思想及工作原理：</p><p>在逻辑上把直接映象Cache的空间上下平分为两个区。对于任何一次访问，伪相联Cache先按直接映象Cache的方式去处理。若命中，则其访问过程与直接映象Cache的情况一样。若不命中，则再到另一区相应的位置去查找。若找到，则发生了伪命中，否则就只好访问下一级存储器</p><h4 id="硬件预取">6. 硬件预取</h4><ul><li>指令和数据都可以预取</li><li>预取内容既可放入Cache，也可放在外缓冲器中。例如：指令流缓冲器</li><li>指令预取通常由Cache之外的硬件完成</li></ul><p>平均访存时间预取 ＝命中时间＋失效率×预取命中率×1＋失效率×（1－预取命中率）×失效开销</p><h4 id="编译器控制的预取">7. 编译器控制的预取</h4><p>在编译时加入预取指令，在数据被用到之前发出预取请求</p><h4 id="编译器优化">8. 编译器优化</h4><p>在编译时，对程序中的指令和数据进行重新组织，以降低Cache失效率</p><p>数组合并技术、内外循环交换技术、循环融合技术</p><h3 id="减少cache失效开销">5.4 减少Cache失效开销</h3><h4 id="让读失效优先于写">1. 让读失效优先于写</h4><p>Cache中的写缓冲器导致对存储器访问的复杂化：</p><p>写缓冲器进行的写入操作是滞后进行的，所以该缓冲器也被称为后行写数缓冲器</p><p>解决问题的方法(读失效的处理)：</p><ul><li>推迟对读失效的处理：（缺点：读失效的开销增加，如50％）</li><li>检查写缓冲器中的内容</li></ul><p>在写回法Cache中，也可采用写缓冲器</p><h4 id="写缓冲合并">2. 写缓冲合并</h4><ul><li>提高写缓冲器的效率</li><li>写直达Cache：依靠写缓冲来减少对下一级存储器写操作的时间</li><li>如果写缓冲器为空，就把数据和相应地址写入该缓冲器</li><li>如果写缓冲器中已经有了待写入的数据，就要把这次的写入地址与写缓冲器中已有的所有地址进行比较，看是否有匹配的项。如果有地址匹配而对应的位置又是空闲的，就把这次要写入的数据与该项合并。这就叫写缓冲合并</li><li>如果写缓冲器满且又没有能进行写合并的项，就必须等待</li></ul><p><strong>提高了写缓冲器的空间利用率，而且还能减少因写缓冲器满而要进行的等待时间</strong></p><h4 id="请求字处理技术">3. 请求字处理技术</h4><ul><li>请求字：从下一级存储器调入Cache的块中，只有一个字是立即需要的</li><li>应尽早把请求字发送给CPU：<ul><li>尽早重启动：调块时，从块的起始位置开始读起。一旦请求字到达，就立即发送给CPU，让CPU继续执行</li><li>请求字优先：调块时，从请求字所在的位置读起。这样，第一个读出的字便是请求字。将之立即发送给CPU</li></ul></li></ul><p>这种技术在以下情况下效果不大：</p><ul><li>Cache块较小</li><li>下一条指令正好访问同一Cache块的另一部分</li></ul><h4 id="非阻塞cache技术">4. 非阻塞Cache技术</h4><p>即为：Cache失效时仍允许CPU进行其他的命中访问。即允许“失效下命中”</p><h4 id="采用两级cache">5. 采用两级Cache</h4><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-4.png" style="zoom:60%;" /></p><p>局部失效率与全局失效率：</p><ul><li><p>局部失效率：</p><p>该级Cache的失效次数/到达该级Cache的访问次数</p></li><li><p>全局失效率</p><p>该级Cache的失效次数/CPU发出的访存的总次数</p><p>全局失效率L2＝部分失效率L1×部分失效率L2</p></li></ul><p>对于第二级Cache，我们有以下结论：</p><ul><li>在第二级Cache比第一级 Cache大得多的情况下，两级Cache的全局失效率和容量与第二级Cache相同的单级Cache的失效率非常接近。</li><li>局部失效率不是衡量第二级Cache的一个好指标，因此，在评价第二级Cache时，应用全局失效率这个指标</li></ul><p>第二级Cache的参数：</p><ul><li><p>容量</p><p>第二级Cache的容量一般比第一级的大许多</p></li><li><p>相联度</p><p>第二级Cache可采用较高的相联度或伪相联方法</p></li></ul><h3 id="减少命中时间">5.5 减少命中时间</h3><p>命中时间直接影响到处理器的时钟频率。在当今的许多计算机中，往往是Cache的访问时间限制了处理器的时钟频率</p><h4 id="容量小结构简单的cache">1. 容量小、结构简单的Cache</h4><p>硬件越简单，速度就越快。应使Cache足够小，以便可以与CPU一起放在同一块芯片上</p><p>某些设计采用了一种折中方案：</p><p>把Cache的标识放在片内，而把Cache的数据存储器放在片外</p><h4 id="虚拟cache">2.虚拟Cache</h4><ul><li>虚拟Cache：访问Cache的索引以及Cache中的标识都是虚拟地址(一部分)</li><li>物理Cache：使用物理地址的传统Cache</li></ul><p>虚拟索引＋物理标识：</p><ul><li>优点：兼得虚拟Cache和物理Cache的好处</li><li>局限性：Cache容量受到限制（Cache容量≤页大小×相联度）</li></ul><h4 id="cache访问流水化">3. Cache访问流水化</h4><ul><li>对第一级Cache的访问按流水方式组织</li><li>访问Cache需要多个时钟周期才可以完成</li></ul><h4 id="trace-cache">4. Trace Cache</h4><ul><li>开发指令级并行性所遇到的一个挑战是： 当要每个时钟周期流出超过4条指令时，要提供足够多条彼此互不相关的指令是很困难的</li><li>一个解决方法：采用Trace Cache 存放CPU所执行的动态指令序列包含了由分支预测展开的指令，该分支预测是否正确需要在取到该指令时进行确认</li></ul><p>优缺点：</p><ul><li>地址映象机制复杂。</li><li>相同的指令序列有可能被当作条件分支的不同选择而重复存放。</li><li>能够提高指令Cache的空间利用率</li></ul><h4 id="cache优化技术总结">5. Cache优化技术总结</h4><p>“＋”号：表示改进了相应指标 “－”号：表示它使该指标变差 空格栏：表示它对该指标无影响 复杂性：0表示最容易，3表示最复杂</p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-5.png" style="zoom:60%;" /></p><p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-6.png" style="zoom:60%;" /></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Github：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL1dlaWp1bi1MaW4vTm90ZXMvdHJlZS9tYXN0ZXIv6K6h566X5py657O757uf57uT5p6ELeW8oOaZqOabpi3nrKzkuozniYg=&quot;&gt;笔记-计算机系统结构-张晨曦-第二版&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="Note" scheme="https://weijun-lin.top/categories/Computer-Science/Note/"/>
    
    
      <category term="计算机系统结构" scheme="https://weijun-lin.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1060 Are They Equal （模拟）</title>
    <link href="https://weijun-lin.top/2020/05/23/2020-05-23-PAT-Advanced-1060/"/>
    <id>https://weijun-lin.top/2020/05/23/2020-05-23-PAT-Advanced-1060/</id>
    <published>2020-05-22T16:00:00.000Z</published>
    <updated>2020-05-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MTM1MjA3MTk4NzI=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>给定有效数字位数，以及两个浮点数，判断浮点数转换为科学计数法后判断是否相同</p><a id="more"></a><h2 id="简单思路">简单思路</h2><p>思路其实挺清楚的，有效数字就是从第一个非零数开始算，不足设定有效位数的需要在后面补零，然后根据小数点的位置和第一个非零值的位置，判断是几次方。</p><p>但是坑是真的狠，注意前导0的情况以及输入0的情况。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">format</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">string</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = a.find(<span class="string">&#x27;.&#x27;</span>);  <span class="comment">// pos为点的位置</span></span><br><span class="line">    <span class="comment">// 保证字符串有小数部分</span></span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        a += <span class="string">&quot;.0&quot;</span>;</span><br><span class="line">        pos = a.length() - <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = a.length();</span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">int</span> temp_pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp_pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temp_pos 记录前导0的位置 注意对00.1这样的判断</span></span><br><span class="line">    <span class="keyword">if</span>(temp_pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[temp_pos+<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            temp_pos--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除前导0 并更新长度和点的位置</span></span><br><span class="line">        a.erase(<span class="number">0</span>, temp_pos+<span class="number">1</span>);</span><br><span class="line">        pos -= temp_pos+<span class="number">1</span>;</span><br><span class="line">        length -= temp_pos+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, non_zero = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 取n个有效数字 并且记录第一个非0值的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == n) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(non_zero &lt; <span class="number">0</span> &amp;&amp; a[i] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; a[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            non_zero = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; non_zero != <span class="number">-1</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            res.push_back(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">0</span>;    <span class="comment">// if non_zero = 0说明是000.000这样的 那么exp = 0</span></span><br><span class="line">    <span class="keyword">if</span>(non_zero != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 指数的判断 需要分大于小于1</span></span><br><span class="line">        <span class="keyword">if</span>(non_zero &gt; pos) &#123;</span><br><span class="line">            <span class="built_in">exp</span> = pos - non_zero + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">exp</span> = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有效数不足的要补零</span></span><br><span class="line">    res.insert(res.end(), n-cnt, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    res = <span class="string">&quot;0.&quot;</span> + res + <span class="string">&quot;*10^&quot;</span> + <span class="built_in">std</span>::to_string(<span class="built_in">exp</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> A, B;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    A = format(n, A);</span><br><span class="line">    B = format(n, B);</span><br><span class="line">    <span class="keyword">if</span>(A == B) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES &quot;</span> &lt;&lt; A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO &quot;</span> &lt;&lt; A &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; B;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MTM1MjA3MTk4NzI=&quot;&gt;题目地址&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;给定有效数字位数，以及两个浮点数，判断浮点数转换为科学计数法后判断是否相同&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="OJ" scheme="https://weijun-lin.top/categories/Computer-Science/OJ/"/>
    
      <category term="PAT" scheme="https://weijun-lin.top/categories/Computer-Science/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://weijun-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Python 正则替换 Markdown 图像路径前缀</title>
    <link href="https://weijun-lin.top/2020/05/22/2020-05-22-blog-image-replace/"/>
    <id>https://weijun-lin.top/2020/05/22/2020-05-22-blog-image-replace/</id>
    <published>2020-05-21T16:00:00.000Z</published>
    <updated>2020-05-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>在博客网站下直接写文章时，会涉及到图像的路径，一般采用的相对路径。但是这样子在最后部署的时候的路径一般都会出现问题（或者自己另外写好的文章放到网站上就不可避免的重新编辑图像地址）。</p><p>一种解决方法是把所有图片放在图床上，就不存在上面的问题了。但本人一般喜欢本地写，图片资源直接放在GitHub上，或者博客网站的相应位置，所以将本地路径转换为 GitHub /网站 路径就显的很重要。</p><p>这里采用的是 Python 正则替换实现此功能</p><a id="more"></a><h2 id="解决方案">解决方案</h2><p>这里采用的是Python的正则匹配方案。</p><p>Markdown 中的图像都是以 <code>![text](./img_directory/sub_path)</code> 或者 <code>![text](img_directory/sub_path)</code> 这样的形式，而目标则色把他们的公共前缀路径替换为超链接前缀，如 <code>![text](https://site/sub_path)</code>，所以简单的思路就是把图像中的路径 <code>****prefix/img.jpg</code> 替换为 <code>site_path/img.jpg</code> 即把 prefix 及其前面的部分替换为网址前缀，防止图像路径有的使用 <code>./</code> 有的不适用的格式。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author : Weijun Lin</span></span><br><span class="line"><span class="comment"># @File : change-img-path.py</span></span><br><span class="line"><span class="comment"># @Software: VS Code</span></span><br><span class="line"><span class="comment"># @Version: python 3.7.3</span></span><br><span class="line"><span class="comment"># @Desc: 使用方式 python change-img-path.py tar-markdown-file prefix newprefix</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">4</span>:</span><br><span class="line">    print(<span class="string">&quot;amount of parameters must be 4&quot;</span>)</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line">all_prefix = sys.argv[<span class="number">2</span>]</span><br><span class="line">patter1 = <span class="string">&#x27;\!\[.*?\]\((?P&lt;tar&gt;.*&#123;&#125;).*?.*?\)&#x27;</span>.<span class="built_in">format</span>(all_prefix)</span><br><span class="line">patter1 = re.<span class="built_in">compile</span>(patter1)</span><br><span class="line">patter2 = <span class="string">&#x27;\&lt;img src=&quot;(?P&lt;tar&gt;.*&#123;&#125;).*?\..*?\&gt;&#x27;</span>.<span class="built_in">format</span>(all_prefix)</span><br><span class="line">patter2 = re.<span class="built_in">compile</span>(patter2)</span><br><span class="line">file_path, prefix =sys.argv[<span class="number">1</span>], sys.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> file_in, <span class="built_in">open</span>(<span class="string">&quot;out-&quot;</span>+file_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> file_out:</span><br><span class="line">    line = file_in.readline()</span><br><span class="line">    <span class="keyword">while</span> line:</span><br><span class="line">        <span class="comment"># 获取所有匹配的Match对象</span></span><br><span class="line">        matched1 = patter1.finditer(line)</span><br><span class="line">        matched2 = patter2.finditer(line)</span><br><span class="line">        pos_list = []</span><br><span class="line">        <span class="keyword">if</span> matched1 != <span class="literal">None</span>:</span><br><span class="line">            pos_list += [(x.start(<span class="string">&quot;tar&quot;</span>), x.end(<span class="string">&quot;tar&quot;</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(matched1)]</span><br><span class="line">        <span class="keyword">if</span> matched2 != <span class="literal">None</span>:</span><br><span class="line">            pos_list += [(x.start(<span class="string">&quot;tar&quot;</span>), x.end(<span class="string">&quot;tar&quot;</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(matched2)]</span><br><span class="line">        pos_list.sort() <span class="comment"># 按开始位置从小到大排序</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> pos_list[::<span class="number">-1</span>]: <span class="comment"># 逆序遍历</span></span><br><span class="line">            st, ed = v</span><br><span class="line">            <span class="comment"># 替换掉原来的</span></span><br><span class="line">            <span class="keyword">if</span> st == ed:</span><br><span class="line">                line = line[:st] + prefix + line[st:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                line = line[:st] + prefix + line[ed:]</span><br><span class="line">        file_out.write(line);</span><br><span class="line">        line = file_in.readline()</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>使用方式为 <code>python change-img-path.py tar-markdown-file prefix newprefix</code></p><p>使用 <code>newprefix</code> 替换图像路径中的 <code>prefix</code></p><p>其中一些函数的解释可以参考：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy9saWJyYXJ5L3JlLmh0bWw=">正则表达式操作<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;在博客网站下直接写文章时，会涉及到图像的路径，一般采用的相对路径。但是这样子在最后部署的时候的路径一般都会出现问题（或者自己另外写好的文章放到网站上就不可避免的重新编辑图像地址）。&lt;/p&gt;
&lt;p&gt;一种解决方法是把所有图片放在图床上，就不存在上面的问题了。但本人一般喜欢本地写，图片资源直接放在GitHub上，或者博客网站的相应位置，所以将本地路径转换为 GitHub /网站 路径就显的很重要。&lt;/p&gt;
&lt;p&gt;这里采用的是 Python 正则替换实现此功能&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="Tool" scheme="https://weijun-lin.top/categories/Computer-Science/Tool/"/>
    
    
      <category term="Python" scheme="https://weijun-lin.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>VERCEL（原名为ZEIT）DNS 记录的修改</title>
    <link href="https://weijun-lin.top/2020/05/17/2020-05-17-VERCEL-DNS-EDIT/"/>
    <id>https://weijun-lin.top/2020/05/17/2020-05-17-VERCEL-DNS-EDIT/</id>
    <published>2020-05-16T16:00:00.000Z</published>
    <updated>2020-05-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>VERCEL提供静态网站的部署和CDN的加速，十分优秀的工具（适合白嫖）</p></blockquote><h2 id="问题简述">问题简述</h2><p>在部署自己的静态网站后（从GITHUB），VERCEL提供了他们的子域名，当然可以使用自己的域名。可以用CNAME将域名导向VERCEL的子域名，也可以直接使用我们自己的域名（不通过CNAME）。具体配置参考：<span class="exturl" data-url="aHR0cHM6Ly92ZXJjZWwuY29tL2RvY3MvdjIvY3VzdG9tLWRvbWFpbnM=">Custom Domain<i class="fa fa-external-link-alt"></i></span></p><p>但直接使用自己的域名会出现一个问题，使用VERCEL提供的DNS服务器后，原来配置的DNS解析失效了。原来我使用的是阿里云的云解析，在更改为VERCEL的DNS服务后，子域名的A记录失效。</p><a id="more"></a><h2 id="解决方案">解决方案</h2><p>既然域名解析失效，因为DNS服务器改成了VERCEL的，所以我们想要改回来需要通过VERCEL修改DNS记录。这需要通过VERCEL的CLI工具实现。下载地址为：https://vercel.com/download</p><p>需要先登录，执行：<code>vercel login</code>，登录好之后，就可以修改DNS解析了。（这里我登录验证了好久……）</p><p>跟着vercel的官方教程即可：https://vercel.com/docs/cli#commands/domains</p><p><code>vercel dns add [domain] [subdomain] [A || AAAA || ALIAS || CNAME || TXT] [value]</code></p><p>便可以修改记录</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;VERCEL提供静态网站的部署和CDN的加速，十分优秀的工具（适合白嫖）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题简述&quot;&gt;问题简述&lt;/h2&gt;
&lt;p&gt;在部署自己的静态网站后（从GITHUB），VERCEL提供了他们的子域名，当然可以使用自己的域名。可以用CNAME将域名导向VERCEL的子域名，也可以直接使用我们自己的域名（不通过CNAME）。具体配置参考：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly92ZXJjZWwuY29tL2RvY3MvdjIvY3VzdG9tLWRvbWFpbnM=&quot;&gt;Custom Domain&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但直接使用自己的域名会出现一个问题，使用VERCEL提供的DNS服务器后，原来配置的DNS解析失效了。原来我使用的是阿里云的云解析，在更改为VERCEL的DNS服务后，子域名的A记录失效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="Tool" scheme="https://weijun-lin.top/categories/Computer-Science/Tool/"/>
    
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1059 Prime Factors（素数）</title>
    <link href="https://weijun-lin.top/2020/05/16/2020-05-16-PAT-Advanced-1059/"/>
    <id>https://weijun-lin.top/2020/05/16/2020-05-16-PAT-Advanced-1059/</id>
    <published>2020-05-15T16:00:00.000Z</published>
    <updated>2020-05-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MTUwMDU1MDM0ODg=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>将一个数分解为一系列素数相乘的结果，如<code>97532468=2^2*11*17*101*1291</code></p><a id="more"></a><h2 id="简单思路">简单思路</h2><p>网上很多建立素数表的（使用<a href="https://Weijun-Lin.top/2020/03/24/2020-03-24-prime-sieve/">素数筛</a>)，但这道题应该是没有必要的。</p><p>从最简单的<a href="https://Weijun-Lin.top/2020/03/24/2020-03-24-prime-sieve/#试除法">一个个除的方法求素数</a>可以解决这道题目。从2开始除，除到2不能除的时候用3除，之后用4，用5……，当然这里4是不能除的，即4不做如何处理跳转到用5除，因为前面2已经将2的倍数全部给除掉了，也就不可能被4除了，这里面也就隐含了<a href="https://Weijun-Lin.top/2020/03/24/2020-03-24-prime-sieve/#埃氏筛">埃氏筛</a>的特点。</p><p>参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld=&quot;</span>, n);</span><br><span class="line">    <span class="keyword">int</span> sqr = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        m[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= sqr;) &#123;</span><br><span class="line">        <span class="comment">// 一个因子</span></span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">            n = n/i;</span><br><span class="line">            sqr = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n != <span class="number">1</span>) &#123;</span><br><span class="line">        m[n]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = m.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v.second != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d^%d&quot;</span>, v.first, v.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MTUwMDU1MDM0ODg=&quot;&gt;题目地址&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将一个数分解为一系列素数相乘的结果，如&lt;code&gt;97532468=2^2*11*17*101*1291&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="OJ" scheme="https://weijun-lin.top/categories/Computer-Science/OJ/"/>
    
      <category term="PAT" scheme="https://weijun-lin.top/categories/Computer-Science/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://weijun-lin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>PAT Advanced 1057 Stack （树状数组）</title>
    <link href="https://weijun-lin.top/2020/05/14/2020-05-14-PAT-Advanced-1057/"/>
    <id>https://weijun-lin.top/2020/05/14/2020-05-14-PAT-Advanced-1057/</id>
    <published>2020-05-13T16:00:00.000Z</published>
    <updated>2020-05-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MTc5NDU3MTA1OTI=">题目地址<i class="fa fa-external-link-alt"></i></span></p><p>给定栈的一系列 POP，PUSH 操作，求执行这些操作后的栈中从小到大排序的中位数（询问中位数的操作是多次的）</p><a id="more"></a><h2 id="基本思路">基本思路</h2><p>栈的模拟并不难处理，主要是对中位数的判断。在不断的更改之中还需要寻找一组数的中位数（范围特征），并且修改每次修改一个具体的数（单点修改），这两个特征符合<a href="/2020/05/13/2020-05-13-Binary-Index-Tree/">树状数组</a>的特征。但还是很难将题目与树状数组联系起来（是真的想不到）。</p><p>数组数组的最大特征就是<strong>区间和的计算（前缀和）和高效率的单点修改</strong>，这如何与题目的中位数联系起来，中位数即中间位置的数，也就说明从开始到该数的个数为总数的一半。所以我们使用树状数组维护X这个数的个数，求中位数也就是求目标X，满足1-X范围内的前缀和为总数的一半。这就与树状数组相联系了。</p><p>题目给定的条件N为正数，并且小于 <span class="math inline">\(10^5\)</span> 满足使用树状数组的条件。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOWBIT(x) ((x)&amp;(-(x)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nums[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示值x的数量加1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt; maxn) &#123;</span><br><span class="line">        nums[x] += v;   </span><br><span class="line">        x += LOWBIT(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取&lt;x的所有个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        res += nums[x];</span><br><span class="line">        x -= LOWBIT(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(nums, <span class="number">0</span>, <span class="keyword">sizeof</span>(nums));</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, cmd);</span><br><span class="line">        <span class="keyword">if</span>(cmd[<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Invalid\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> x = s.top(); s.pop();</span><br><span class="line">                add(x, <span class="number">-1</span>); <span class="comment">// 减少一个了</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Invalid\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tar = (s.size() + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">1</span>, right = maxn<span class="number">-1</span>, mid;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                    mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(getsum(mid) &lt; tar) &#123;</span><br><span class="line">                        left = mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        right = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            s.push(x);</span><br><span class="line">            add(x, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MTc5NDU3MTA1OTI=&quot;&gt;题目地址&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;给定栈的一系列 POP，PUSH 操作，求执行这些操作后的栈中从小到大排序的中位数（询问中位数的操作是多次的）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Science" scheme="https://weijun-lin.top/categories/Computer-Science/"/>
    
      <category term="OJ" scheme="https://weijun-lin.top/categories/Computer-Science/OJ/"/>
    
      <category term="PAT" scheme="https://weijun-lin.top/categories/Computer-Science/OJ/PAT/"/>
    
    
      <category term="C/C++" scheme="https://weijun-lin.top/tags/C-C/"/>
    
  </entry>
  
</feed>
