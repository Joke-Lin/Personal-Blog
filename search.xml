<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Retro Snake Easyx版本</title>
    <url>/2018/09/15/2018-09-15-Retro-Snake/</url>
    <content><![CDATA[<h2 id="部分文件说明">部分文件说明</h2>
<h3 id="snakeprev.h"><strong>Snakeprev.h</strong></h3>
<ol type="1">
<li>蛇节点声明 <code>struct snake;</code></li>
<li>蛇存储结构链表 <code>snake * snakelist(int,int*);</code></li>
<li>增加节点方法 <code>void addsnake(snake *);</code></li>
<li>绘画蛇身 <code>void drawsnake(snake *,char);</code></li>
<li>清空蛇 <code>void clearsnake(snake *);</code></li>
</ol>
<a id="more"></a>
<h3 id="mapgraph.h"><strong>mapgraph.h</strong></h3>
<p>主要是页面布局 背景（box map)的制作 布局</p>
<h3 id="main.cpp"><strong>main.cpp</strong></h3>
<p>主要方法如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcomegraph</span><span class="params">()</span></span>;<span class="comment">//欢迎界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Finish</span><span class="params">()</span></span>;<span class="comment">//结束界面</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clickcontrol</span><span class="params">()</span></span>;<span class="comment">//鼠标控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Movingsnake</span><span class="params">(<span class="keyword">char</span>)</span></span>;<span class="comment">//蛇身移动控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Changesnakebody</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">int</span> )</span></span>;<span class="comment">//蛇身改变控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eating</span><span class="params">()</span></span>;<span class="comment">//吃到食物的操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Deadjudge</span><span class="params">()</span></span>;<span class="comment">//死亡判断</span></span><br></pre></td></tr></table></figure>
<h3 id="运行截图">运行截图</h3>
<ul>
<li><strong>Start</strong></li>
</ul>
<figure>
<img src="https://github.com/LWJ9527/Retro-Snake/blob/master/%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/start.png?raw=true" alt="Start" /><figcaption>Start</figcaption>
</figure>
<ul>
<li><strong>Run</strong></li>
</ul>
<figure>
<img src="https://github.com/LWJ9527/Retro-Snake/blob/master/%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/run.png?raw=true" alt="Run" /><figcaption>Run</figcaption>
</figure>
<ul>
<li><strong>Over</strong></li>
</ul>
<figure>
<img src="https://github.com/LWJ9527/Retro-Snake/blob/master/%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/over.png?raw=true" alt="Over" /><figcaption>Over</figcaption>
</figure>
<h3 id="注意事项及运行说明">注意事项及运行说明</h3>
<p><strong>WASD：</strong>　来操控蛇的上下左右移动 注意打开英文输入<br />
<strong>初始界面：</strong> 用户名及密码只是模拟 回车键确定输入<br />
<strong>EXE目录：</strong> exe文件在debug目录下 release发布因为其优化运行出错<br />
<strong>源代码下载：</strong> <code>https://github.com/LWJ9527/Retro-Snake.git</code><br />
<strong>C控制台源代码：</strong> <code>https://blog.csdn.net/qq_40953281/article/details/79315254</code><br />
<strong>To Be Continue...</strong> &gt; Easyx 下载地址 <code>https://www.easyx.cn/downloads/</code><br />
&gt; 更新 2018-9-10</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Game</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串算法</title>
    <url>/2018/10/01/2018-10-01-manacher/</url>
    <content><![CDATA[<blockquote>
<p>leetcode5:<code>https://leetcode-cn.com/problems/longest-palindromic-substring/description/</code><br />
可以自己提交看看对不对</p>
</blockquote>
<h2 id="暴力搜索">暴力搜索</h2>
<p>这个应该是最容易的方法了，但是一看复杂度O(n<sup>3</sup>)，还是放弃好了。</p>
<p>但是这个方法也是遍历所有字符串字串的一种方法。下面是暴力搜索的代码：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力循环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">maxPalindromeStringForce</span><span class="params">(<span class="keyword">final</span> String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> BeginIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; target.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindromeString(target.substring(i, j + <span class="number">1</span>)) &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                BeginIndex = i;</span><br><span class="line">                maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.substring(BeginIndex, BeginIndex + maxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindromeString</span><span class="params">(<span class="keyword">final</span> String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = target.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.charAt(l) != target.charAt(r)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中心拓展法">中心拓展法</h2>
<p>这个比暴力搜索复杂度要少一个数量级<br />
为什么呢？它用到了回文串的一个特性左右对称<br />
其实在暴力搜索的判断是否为回文串的时候我们已经用了这个特性了<br />
但是我们是对每一段字串用这个特性<u><strong>即用它去判断而不是去获取</strong></u><br />
所以我们对每一个字符从中间向外展开以获取以此字符为中心的最长回文字串<br />
这样外循环为字符串遍历 内循环为获得回文子串 复杂度最差意思就是O(n<sup>2</sup>)<br />
但是有一个地方必须注意，<u><strong><em>中心拓展</em></strong></u>中心一词是相对于长度为奇数的串的，<br />
对于偶数串我们要单独判断，方法也很简单看看该字符后一个字符是不是一样就行，代码里有解释<br />
代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中心向外拓展</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">maxPalindromeStringCenter</span><span class="params">(<span class="keyword">final</span> String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target; <span class="comment">// 如果是空字符串则直接返回</span></span><br><span class="line">    <span class="keyword">int</span> beg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = i;</span><br><span class="line">        <span class="keyword">int</span> r = i;</span><br><span class="line">        <span class="comment">// 回文串是奇数</span></span><br><span class="line">        <span class="keyword">while</span> (target.charAt(l) == target.charAt(r)) &#123;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">if</span> (l == -<span class="number">1</span> || r == target.length())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">        <span class="keyword">if</span> (r - l &gt; end - beg) &#123;</span><br><span class="line">            beg = l;</span><br><span class="line">            end = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回文串是偶数</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; target.length() - <span class="number">1</span> &amp;&amp; target.charAt(i + <span class="number">1</span>) == target.charAt(i)) &#123;</span><br><span class="line">            r = i + <span class="number">1</span>;</span><br><span class="line">            l = i;</span><br><span class="line">            <span class="keyword">while</span> (target.charAt(l) == target.charAt(r)) &#123;</span><br><span class="line">                l--;</span><br><span class="line">                r++;</span><br><span class="line">                <span class="keyword">if</span> (l == -<span class="number">1</span> || r == target.length())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">if</span> (r - l &gt; end - beg) &#123;</span><br><span class="line">                beg = l;</span><br><span class="line">                end = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.substring(beg, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dp动态规划">Dp动态规划</h2>
<p>字符串类的题目怎么可能少了动态规划呢<br />
那么状态该怎么转移呢</p>
<p><strong><em>dp[i][j] = true ,if dp[i+1][j-1] == true &amp;&amp; str[i]==str[j]</em></strong><br />
否则 <strong><em>dp[i][j] = false</em></strong></p>
<p>至于为什么，因为我们在已经知道串[i,j]是回文字串的时候<br />
只要 <strong><em>str[i-1] == str[j+1]</em></strong> 那么[i-1,j+1]也是一个回文子串<br />
为了更好找到最长所以这里将微循环设置为长度循环，内循环为字串头地址<br />
需要注意的是预处理，每个字母都是一个长度为1 的回文串<br />
和中心拓展类似偶数串中心是两个相同的字母所以还要考虑相邻字母相同的情况<br />
复杂度虽然和中心拓展一个数量级但是还是要比它快许多哦<br />
代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dp动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">maxPalindromeStringDp</span><span class="params">(<span class="keyword">final</span> String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    <span class="keyword">int</span> len = target.length();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    <span class="keyword">int</span> beginIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] isPalindrom = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            isPalindrom[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        isPalindrom[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len - <span class="number">1</span> &amp;&amp; target.charAt(i) == target.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">            isPalindrom[i][i + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">            beginIndex = i;</span><br><span class="line">            maxLen = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> strlen = <span class="number">3</span>; strlen &lt;= len; strlen++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len - strlen; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> end = i + strlen - <span class="number">1</span>; <span class="comment">// 字串结束的位置</span></span><br><span class="line">            <span class="keyword">if</span> (isPalindrom[i + <span class="number">1</span>][end - <span class="number">1</span>] == <span class="keyword">true</span> &amp;&amp; target.charAt(i) == target.charAt(end)) &#123;</span><br><span class="line">                isPalindrom[i][end] = <span class="keyword">true</span>;</span><br><span class="line">                maxLen = strlen;</span><br><span class="line">                beginIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.substring(beginIndex, beginIndex + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="manacher算法">Manacher算法</h2>
<p>很多人也许和我一样听到最长回文子串还有O(n)解法的时候是不相信的<br />
但是事实就是如此，这个算法也叫马拉车算法（只是谐音哦）<br />
我认为它也是一种动态规划思想 但是用的更加的巧妙<br />
在某种程度上和KMP算法有异曲同工之处</p>
<h3 id="统一格式化源字符串">1.统一格式化源字符串</h3>
<p>不知道是否有人注意到了上面几种算法在某些方面都考虑奇数串和偶数串的情况<br />
为了简化考虑情况设置一下规则：</p>
<p><span class="math inline">\(abcd\rightarrow \#a\#b\#c\#d\#\)</span></p>
<p>这样所有的字符串就都是奇数串了</p>
<h3 id="设置映射关系">2.设置映射关系</h3>
<p>我们需要的是源字符串啊<br />
处理成那种乱七八糟的字符串，即使得到了结果还要将所有 <strong>#</strong> 取代<br />
所以我们看看能不能找到新串和原串之间的关系<br />
这样处理后表达一个回文串最好的方式就是中心mid（也就是为什么统一为奇数串的原因）和半径来表示r<br />
在我们知道mid和r的时候怎么确定原串呢。<br />
假设有串 <strong><em>#c#a#b#a#</em></strong> 原串是 <strong><em>caba</em></strong><br />
显而易见的是 <strong><em>aba</em></strong> 是回文串a在原串的下标是1<br />
在新串中下标是5，也就是 <strong><em>mid = 5 , r = 4</em></strong><br />
乍一看就是 <strong><em>beginIndex = mid-r</em></strong><br />
但是 <strong><em>#a#b#a# 此时 mid = 3， r = 4</em></strong> 那么 <strong><em>beginIndex = -1</em></strong><br />
显然不对所以我们在最开始处加上一个与#不同的符号$，那么新串即是 $#a#b#a#<br />
此时 <strong><em>mid = 4 r = 4</em></strong> 那就很符合了<br />
但是对 <strong><em>#c#a#b#a#</em></strong> 又不符合了，所以我们找到了新的关系 <strong><em>beginIndex = (mid-r)/2</em></strong> 这是最符合的 感兴趣的小伙伴可以自己推一推</p>
<h3 id="找到-mid-以及-r">3.找到 <strong>mid</strong> 以及 <strong>r</strong></h3>
<p><strong><em>p[i] = mostRight &gt; i ? min(p[2 * mid - i], mostRight - i) : 1;</em></strong><br />
p[i] 为以i为中心的半径 mostRight是已知的回文串右端点最右的那个的下标 mid则是其中心<br />
由于回文串的对称性 <strong><em>p[i] = min(p[2 * mid - i], mostRight - i)</em></strong> p[2*mid-i]是其对称中心点下标<br />
他们两个在以mid为中心的<u><strong>回文串内</strong></u>对称部分相同也就是半径相同(一定注意是回文串内)<br />
在外面的部分我们无从得知只能老老实实匹配 也就是置为1（自己就是回文串）</p>
<h3 id="复杂度">4.复杂度</h3>
<p>因为每次循环内要不是用到以前的结论（对于的中心点）要么就是向右拓展<br />
所以复杂度是O(n)<br />
并不是有两个循环复杂度就是O(n<sup>2</sup>)</p>
<h3 id="代码如下其实先看代码可能更好理解">5.代码如下（其实先看代码可能更好理解）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// manacher</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">maxPalindromeStringManacher</span><span class="params">(<span class="keyword">final</span> String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    StringBuffer temp = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;$#&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.length(); i++) &#123;</span><br><span class="line">        temp.append(target.charAt(i) + <span class="string">&quot;#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止$#a#b#a# 读到最后a的时候向两边扩散的时候溢出 C++则不需要C++字符串有/0结束符最后加的字符不能为$否则还是会溢出</span></span><br><span class="line">    temp.append(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[temp.length() + <span class="number">1</span>]; <span class="comment">//以i为中心的半径</span></span><br><span class="line">    <span class="keyword">int</span> mostRight = <span class="number">0</span>; <span class="comment">// 已知回文串所能达到的最右边的下标</span></span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>; <span class="comment">// 已知最右边的回文串的中心下标</span></span><br><span class="line">    <span class="keyword">int</span> resLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> resMid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; temp.length() - <span class="number">1</span>; i++) &#123; <span class="comment">// 注意是从1开始第一个字符不算在内</span></span><br><span class="line">        <span class="comment">// 最关键一步 初始化已知的 p[i]</span></span><br><span class="line">        p[i] = mostRight &gt; i ? Math.min(p[<span class="number">2</span> * mid - i], mostRight - i) : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp.charAt(i + p[i]) == temp.charAt(i - p[i]))</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="keyword">if</span> (mostRight &lt; i + p[i]) &#123;</span><br><span class="line">            mostRight = i + p[i];</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resLen &lt; p[i]) &#123;</span><br><span class="line">            resLen = p[i];</span><br><span class="line">            resMid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.substring((resMid - resLen) / <span class="number">2</span>, (resMid - resLen) / <span class="number">2</span> + resLen - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果还有疑惑 可以参考下面两篇文章（我觉得很不错的）：<br />
<code>https://www.cnblogs.com/grandyang/p/4475985.html</code>(我也是这里学习的) <code>https://mp.weixin.qq.com/s/Zrj35DrnQKtAENiR5llrcw</code>(漫画的形式讲的很清楚) 不好的地方 欢迎提出(￣▽￣)&quot;</p>
</blockquote>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬取有道翻译</title>
    <url>/2018/09/18/2018-09-18-youdao/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/sss4/p/7809821.html"><strong>爬虫原理</strong></a></p>
<blockquote>
<p>Attention: Python3 将urlib2 urlib3 结合为urlib</p>
</blockquote>
<ul>
<li><strong>Urlib</strong>:<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGlhby1hcHBsZTM2L3AvODQzMzQwMC5odG1s">Python3中urllib详细使用方法(header,代理,超时,认证,异常处理)<i class="fa fa-external-link-alt"></i></span></li>
<li><strong>urlib2</strong> :<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA0MDk0NDUvYXJ0aWNsZS9kZXRhaWxzLzczNDM4ODE2">python urllib2详解及实例(从底层说起)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="基本原理">基本原理</h2>
<ul>
<li><p>通过给网页提供一个数据，然后获取其反馈</p></li>
<li>使用到的模块
<ul>
<li><strong>urllib.request:</strong> 访问网站，提出请求，获取反馈</li>
<li><strong>urllib.parse:</strong> 格式化请求数据</li>
<li><strong>json:</strong> 格式化反馈信息，使其格式化为字典</li>
</ul></li>
<li><p>新版有道翻译爬取实现比较复杂 这里是对老的版本的爬取</p></li>
</ul>
<a id="more"></a>
<h2 id="实现过程及代码">实现过程及代码</h2>
<h3 id="分步解释">分步解释</h3>
<p><strong>1.</strong> 获取处理翻译信息的网页（这里采用的是谷歌浏览器）<br />
打开有道翻译网页 进入开发者模式<br />
选择Network <img src="/assets/ArticleImg/2018/Youdao1.png" alt="Youdao1" /><br />
然后在左边的输入框随便输入一个单词 会发现多了很多文件 <img src="/assets/ArticleImg/2018/Youdao2.png" alt="Youdao2" /> <strong>Headers</strong> 里面就是我们需要发送给他的信息<br />
其中 <strong>Request Url</strong> 就是真正处理翻译的网页<br />
由于我们采用旧版所以将url里的 <strong>&quot;translate_o&quot;</strong> 改为 <strong>&quot;translate&quot;</strong></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 真正翻译的网址 Request Url</span></span><br><span class="line">url = <span class="string">&#x27;http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2.</strong> 发送信息包 如下 <img src="/assets/ArticleImg/2018/Youdao3.png" alt="Youdao3" /> 将其包装成字典 并且格式化为网页可以识别的格式</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建列表 模拟传入数据</span></span><br><span class="line">data = &#123;&#125;</span><br><span class="line">data[<span class="string">&#x27;i&#x27;</span>] = String</span><br><span class="line">data[<span class="string">&#x27;from&#x27;</span>] = <span class="string">&#x27;AUTO&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;to&#x27;</span>] = <span class="string">&#x27;AUTO&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;smartresult&#x27;</span>] = <span class="string">&#x27;dict&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;client&#x27;</span>] = <span class="string">&#x27;fanyideskweb&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;doctype&#x27;</span>] = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;version&#x27;</span>] = <span class="string">&#x27;2.1&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;keyfrom&#x27;</span>] = <span class="string">&#x27;fanyi.web&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;action&#x27;</span>] = <span class="string">&#x27;FY_BY_REALTIME&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;typoResult&#x27;</span>] = <span class="string">&#x27;false&#x27;</span></span><br><span class="line"><span class="comment">#该变格式</span></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>3.</strong> 获取反馈并处理<br />
<img src="/assets/ArticleImg/2018/Youdao4.png" alt="Youdao4" /></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = urllib.request.urlopen(url, data)  <span class="comment"># 得到回复</span></span><br><span class="line">html = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># 重新编码</span></span><br><span class="line">result = json.loads(html)  <span class="comment"># json 字典化</span></span><br><span class="line"><span class="comment"># return result[&quot;translateResult&quot;][0][0][&quot;tgt&quot;] 返回结果</span></span><br></pre></td></tr></table></figure></p>
<h3 id="全部代码如下">全部代码如下</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Author: Joke-R</span></span><br><span class="line"><span class="string">    IDE: python3.6</span></span><br><span class="line"><span class="string">    Purpose: translate words by youdao</span></span><br><span class="line"><span class="string">    Time: 2018-09-18</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Translate</span>(<span class="params">String</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        String: str</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 真正翻译的网址 Request Url</span></span><br><span class="line">    url = <span class="string">&#x27;http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&#x27;</span></span><br><span class="line">    <span class="comment"># 新建列表 模拟传入数据</span></span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    data[<span class="string">&#x27;i&#x27;</span>] = String</span><br><span class="line">    data[<span class="string">&#x27;from&#x27;</span>] = <span class="string">&#x27;AUTO&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;to&#x27;</span>] = <span class="string">&#x27;AUTO&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;smartresult&#x27;</span>] = <span class="string">&#x27;dict&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;client&#x27;</span>] = <span class="string">&#x27;fanyideskweb&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;doctype&#x27;</span>] = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;version&#x27;</span>] = <span class="string">&#x27;2.1&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;keyfrom&#x27;</span>] = <span class="string">&#x27;fanyi.web&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;action&#x27;</span>] = <span class="string">&#x27;FY_BY_REALTIME&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;typoResult&#x27;</span>] = <span class="string">&#x27;false&#x27;</span></span><br><span class="line"></span><br><span class="line">    data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    response = urllib.request.urlopen(url, data)  <span class="comment"># 得到回复</span></span><br><span class="line">    html = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># 重新编码</span></span><br><span class="line">    result = json.loads(html)  <span class="comment"># json 字典化</span></span><br><span class="line">    <span class="keyword">return</span> result[<span class="string">&quot;translateResult&quot;</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="string">&quot;tgt&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(__doc__)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            String = <span class="built_in">input</span>(<span class="string">&quot;please input a string:\n&quot;</span>)</span><br><span class="line">            print(<span class="string">&quot;result:&quot;</span>, Translate(String))</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> reason:</span><br><span class="line">            print(reason + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的二进制阅读器</title>
    <url>/2018/11/02/2018-11-02-BinaryFileReader/</url>
    <content><![CDATA[<blockquote>
<p>在学习BMP位图的构成时，对网上的收费16进制查看器很是烦躁，notepad查看时卡到放弃人生</p>
<p>因为只是为了初步学习图片知识，以及查看2进制文件内部构成的话，可以自己实现一个</p>
</blockquote>
<h2 id="思路">思路</h2>
<ul>
<li><p>使用C++的文件操作进行二进制的读操作，这里默认以1个字节为单位（2位16进制）</p></li>
<li><p>每次读一个字节，就将其转化位16进制，读取的时候需要注意有符号数和无符号数的区别，我这里用<strong>unsigned Char</strong> 来存取每一个字节的内容</p></li>
<li><p>对于C++的文件读写网上很多介绍</p></li>
<li><p>对于每一个读取的数写入文本文件内（.txt文件）便于查看</p></li>
<li><p>计算文件大小 通过C++的文件指针移动即首尾文件指针差除以1024即文件大小（KB）</p></li>
</ul>
<a id="more"></a>
<h2 id="代码如下">代码如下</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> HEX[<span class="number">16</span>] = &#123; <span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfrom</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span>* hexNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		hexNumber[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">while</span> (num != <span class="number">0</span> &amp;&amp; index &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		hexNumber[index--] = HEX[num % <span class="number">16</span>];</span><br><span class="line">		num = num / <span class="number">16</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getFileName</span><span class="params">(<span class="built_in">string</span>&amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = filename.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (filename[i] == <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			index = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> filename.substr(index + <span class="number">1</span>, filename.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;    <span class="comment">//The Byte have been read</span></span><br><span class="line">	<span class="built_in">string</span> path_r;</span><br><span class="line">	<span class="built_in">string</span> path_w;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please input the File for read and write&#x27;s name: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	ifstream in;</span><br><span class="line">	ofstream out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The file path to read: &quot;</span>;</span><br><span class="line">		getline(<span class="built_in">cin</span>, path_r);</span><br><span class="line">		in = ifstream(path_r, ios::binary);</span><br><span class="line">		<span class="keyword">if</span> (!in.is_open())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Error: File Path is Wrong&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Get the file path to Write</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The File Path to save(.txt): &quot;</span>;</span><br><span class="line">	getline(<span class="built_in">cin</span>, path_w);</span><br><span class="line">	out = ofstream(path_w);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Get the File size</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> Beg = in.tellg();</span><br><span class="line">	in.seekg(<span class="number">0</span>, ios::end);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> End = in.tellg();</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> fileSize = End - Beg;</span><br><span class="line">	in.seekg(<span class="number">0</span>, ios::beg);</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;\t\t&quot;</span> &lt;&lt; getFileName(path_r) &lt;&lt; <span class="string">&quot;\tFile Size: &quot;</span> &lt;&lt; fileSize / <span class="number">1024.0</span> &lt;&lt; 	<span class="string">&quot;KB&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//The index of every row</span></span><br><span class="line">	<span class="keyword">char</span> hexNumber[<span class="number">9</span>] = <span class="string">&quot;00000000&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Print the first row&#x27;s index</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> temp;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;\t\t&quot;</span>; <span class="comment">//Format index</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) out &lt;&lt; HEX[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	out &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Read and Write File</span></span><br><span class="line">	<span class="keyword">while</span> (in.read((<span class="keyword">char</span>*)&amp;temp, <span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (num % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			out &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			transfrom(num, hexNumber);</span><br><span class="line">			out &lt;&lt; hexNumber &lt;&lt; <span class="string">&quot;:\t&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		num++;</span><br><span class="line">		<span class="keyword">int</span> hex = (<span class="keyword">unsigned</span>)temp;</span><br><span class="line">		<span class="keyword">char</span> a = HEX[hex / <span class="number">16</span>];</span><br><span class="line">		<span class="keyword">char</span> b = HEX[hex % <span class="number">16</span>];</span><br><span class="line">		out &lt;&lt; a &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	out.seekp(<span class="number">0</span>,ios::beg);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Close file</span></span><br><span class="line">	in.close();</span><br><span class="line">	out.close();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read Successfully&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行说明">运行说明</h2>
<ul>
<li>不能输入输出文件名一致（可以自己试试ㄟ( ▔, ▔ )ㄏ）</li>
<li>首先输入需要读的文件（可以直接将文件拖入黑框 系统会自动输入绝对路径）</li>
<li>然后输入用于保存结果的 TXT 文件（如果不存在则在当前目录新建）</li>
</ul>
<h2 id="运行截图">运行截图</h2>
<blockquote>
<p>以读取Bmp图像为例</p>
</blockquote>
<p><img src="/assets/ArticleImg/2018/BinaryInput.jpg" /></p>
<p><img src="/assets/ArticleImg/2018/BinaryOutput.jpg" /></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径的三种算法以及路径还原与负圈判断</title>
    <url>/2018/12/07/2018-12-07-ShortestPath/</url>
    <content><![CDATA[<blockquote>
<p>图的基础，最短路径的几种解答</p>
<p>单源最短路： Bellman-Ford &amp; Dijkstra 及其简单优化 以及负圈的判断</p>
<p>多源最短路：Floyd-Warshall 算法的简单理解</p>
<p>路径还原问题</p>
<p>算法代码及思路主要参考：《挑战程序设计竞赛》</p>
</blockquote>
<p>在此之前读者应对图已经有基础的概念，以及图的邻接表 &amp; 邻接矩阵的表示方法</p>
<a id="more"></a>
<h2 id="bellman-ford">Bellman-Ford</h2>
<p>单源最短路问题是固定一个起点，然后求这个点到其他各个顶点的最短路（最小权值和）</p>
<p>设起点s到其他顶点i的距离为 <strong>d[i]</strong> 则很容易可以得到下面这个结论： <span class="math display">\[
d[i] = min\{d[j] + edge(j,i)\} edge(j,i) \in E 
\]</span> 设置初始状态d[s] = 0 else d[i] = INF 然后只要在循环里不断更新这些值</p>
<p>如果不再更新说明所有路都已达到最短 代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> from, to, cost;&#125;; <span class="comment">// 定义从点from指向to权值为cost的边</span></span><br><span class="line">Edge edges[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[MAXN]; <span class="comment">// 最短距离</span></span><br><span class="line"><span class="keyword">int</span> V,E; <span class="comment">// V: 顶点数 E: 边数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从点s到其他点的最小距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; V;i++) d[i] = INF;</span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">// 到自己为0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> isUpdate = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Edge temp = edges[i];</span><br><span class="line">            <span class="keyword">if</span>(d[temp.from] != INF &amp;&amp; d[temp.to] &gt; d[temp.from]+temp.cost)</span><br><span class="line">            &#123;</span><br><span class="line">                d[temp.to] = d[temp.from] + temp.cost;</span><br><span class="line">                isUpdate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isUpdate) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果图中不存在s可达的负圈，那么最短路不会经过一个顶点两次，也就是说 最多通过V-1条边，也可以这样理</p>
<p>解，每一次更新都会有更短的路径产生，那么在V个点的图中，两个点的最远距离只能是V-1条边，所以循环最多</p>
<p>只会执行V-1次，这个特性将是我们判断是否存在负圈的重要性质</p>
<p>所以我们也可以将上面的代码简单化为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="comment">// 不存在负圈的情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; V;i++) d[i] = INF;</span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">// 到自己为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; V<span class="number">-1</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Edge temp = edges[i];</span><br><span class="line">            d[temp.to] = min(d[temp.to],d[temp.from]+temp.cost)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很容易可以看出来Bellman算法的复杂度为 **O(V*E)**</p>
<h3 id="负圈的判断">负圈的判断</h3>
<p>在这里，首先要明确<strong>负圈（负权环）</strong>和<strong>负权边</strong>的区别</p>
<p>负圈是指一条环状路径上的综合权值为负的，负权边是指权值为负数的边，在算法中如果图是无向图的话，</p>
<p><strong>负权边</strong>和<strong>负圈</strong>是<strong>等价</strong>的。如下图：也就是在A与B之间形成了一个环，这个环的权值为-2</p>
<p><img src="/assets/ArticleImg/2018/shortpath1.png" /></p>
<p>所以在无向图中负边的存在也就是负圈的存在。所以Bellman主要是可以用来判断有向图中是否存在负圈。</p>
<p>只要存在了负圈，那么Bellman的松弛操作（也就是那个每次更新的内容）将会永远的执行下去。</p>
<p>相当于没走一个这个负圈总的权值（路径长度）就会减少。但是我们上面已经得到在不存在负圈的图中最多执行</p>
<p>V-1次循环，所以我们只要判断在第V次仍然更新了，那么就存在负圈了。代码只要更改一点点就行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="comment">// 不存在负圈的情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; V;i++) d[i] = INF;</span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">// 到自己为0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; V;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Edge temp = edges[i];</span><br><span class="line">            <span class="keyword">if</span>(d[temp.from] != INF &amp;&amp; d[temp.to] &gt; d[temp.from]+temp.cost)</span><br><span class="line">            &#123;</span><br><span class="line">                d[temp.to] = d[temp.from] + temp.cost;</span><br><span class="line">                <span class="comment">// 只要再次加上到第V-1次的特判</span></span><br><span class="line">                <span class="keyword">if</span>(j == V<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;存在负圈&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dijkstra">Dijkstra</h2>
<p>我们先考虑不存在负边的情况，在Bellman算法中每一次都要全部遍历所有的边，而且如果d[i]本身不是最短路径</p>
<p>那么进行那个松弛操作之后的d[i]依然不是最短，所以可以对此进行优化：</p>
<ul>
<li><p>找到最短路径已经确定的顶点，更新从他出发相邻顶点的最短距离</p></li>
<li><p>从此不需要在更新上面已经确定的哪些顶点（即不需要遍历）</p></li>
</ul>
<p>这就衍生出了Dijkstra算法。上面两点用图来描述就是：</p>
<p><img src="/assets/ArticleImg/2018/shortpath2.png" /></p>
<p>假设初始点为A首先AC &lt; AB</p>
<p>很清楚的我们可以得出结论AC就是A到C的最短路径，因为如果从AB方向走的话，AB ＞AC 而且我们的图是</p>
<p>没有负边的，所以BD &gt; 0 也就是说AB + BD.... &gt; AC 是必然成立的。 所以A-&gt;C的最短路径已经确定了，之后就</p>
<p>需要再去管C点了。算法总的描述如下：</p>
<blockquote>
<p>在最开始时，只有起点的最短距离是确定的（而且所有点都未曾使用）。而在尚未使用的顶点中，距离d[i]最小的顶点就是最短距离已经确定的顶点。因为不存在负边，所以d[i]不会在以后的更新中变小。这就是Dijkstra算法</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cost[MAXN][MAXN]; <span class="comment">// cost[i][j] 表示从i到j之间的权值（不存在是为INF）</span></span><br><span class="line"><span class="keyword">int</span> d[MAXN]; <span class="comment">// 从起点到其他点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> used[MAXN]; <span class="comment">// 已经使用过的图（已经确定最短距离的点）</span></span><br><span class="line"><span class="keyword">int</span> V; <span class="comment">// 点的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d,d+V,INF); <span class="comment">// algorithm中的函数 将d数组全部赋为INF</span></span><br><span class="line">    fill(used,used+V,<span class="literal">false</span>);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// c从未使用过的点集中取一个距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; V;u++)</span><br><span class="line">        	<span class="keyword">if</span>(!used[u] &amp;&amp; (v == <span class="number">-1</span> || d[u] &lt; d[v])) v = u;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 所有的点的最短路径确定则退出</span></span><br><span class="line">       	used[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; V;u++)</span><br><span class="line">        &#123;</span><br><span class="line">            d[u] = min(d[u],d[v]+cost[v][u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简单的优化">简单的优化</h3>
<p>上面代码的时间复杂度是 O(V<sup>2</sup>) , 我们可以通过堆（优先队列）降为O(E*log(V))</p>
<p>上面有一个操作是找到距离最小的点和标记是否使用，这个就可以使用堆来优化</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P; <span class="comment">// first 是最短距离 second 是顶点编号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to, cost&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[MAXN]; <span class="comment">// 使用邻接表存图</span></span><br><span class="line"><span class="keyword">int</span> d[MAXN]; <span class="comment">// 从起点到其他点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> used[MAXN]; <span class="comment">// 已经使用过的图（已经确定最短距离的点）</span></span><br><span class="line"><span class="keyword">int</span> V; <span class="comment">// 点的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;P,<span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que; <span class="comment">// 定义一个堆 从按最短距离小到的大排</span></span><br><span class="line">    fill(d,d+V,INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    que.push(P(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) <span class="comment">// 为空就说明所有节点都已经用过</span></span><br><span class="line">    &#123;</span><br><span class="line">        P temp = que.top(); que.pop();</span><br><span class="line">        <span class="keyword">int</span> v = temp.second;</span><br><span class="line">        <span class="keyword">if</span>(d[v] &lt; temp.first) <span class="keyword">continue</span>; <span class="comment">// 没必要更新了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[v].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            edge e = G[v][i];</span><br><span class="line">            <span class="keyword">if</span>(d[e.to] &gt; d[v]+e.cost)</span><br><span class="line">            &#123;</span><br><span class="line">                d[e.to] = d[v]+e.cost;</span><br><span class="line">                que.push(P(d[e.to],e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floyd-warshall">Floyd-Warshall</h2>
<blockquote>
<p>Floyd算法简单暴力，主要用于求多源最短路径（任意两个点的最短路径）</p>
</blockquote>
<p>核心代码十分短小精悍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[MAXN][MAXN]; <span class="comment">// d[u][v] 表示从u -&gt; v的权值 不存在的时候为0</span></span><br><span class="line"><span class="keyword">int</span> V; <span class="comment">// 顶点个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; V;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; V;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; V;j++)</span><br><span class="line">                d[i][j] = min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>十分暴力复杂度可想而知O(V<sup>3</sup>)</p>
<p>那么这几行代码是什么意思呢？ 这其实还是DP</p>
<p>我们用<strong>d[k+1][i][j]</strong> 来表示只使用<strong>0~k和i,j</strong>顶点的情况下的最短路</p>
<p>初始状态为<strong>d[0][i][j] = cost[i][j]</strong> 所以我们可以得到下面这个式子： <span class="math display">\[
d[k][i][j] = 
\begin{cases}
d[k-1][i][j] 　(不经过点K)\\
d[k-1][i][k] + d[k-1][k][j]　（经过K点）\\
\end{cases}　＝　min(d[k-1][i][j],d[k-1][i][k] + d[k-1][k][j])
\]</span> 当然 我们可以稍微优化一下，时间以及到极限了，我们可以想办法把空间复杂度降下来</p>
<p>也就是我们上面那个形式，也就是为什么K必须放在最外面的原因</p>
<p>我们观察三维的那个式子与K相关的就只有K与K-1所以我们可以进行降维操作</p>
<p>也就是当K=s的时候，在执行状态压缩之前d[i][j]的值存都是的d[k-1][i][j]</p>
<p>也就是将上一个状态动态保存起来了 所以才有上面的简短的代码</p>
<h2 id="路径还原">路径还原</h2>
<p>最后的问题就是当我们知道最短路径多少的时候，难免有时候需要知道该怎么走才有这条最短路径呢</p>
<p>用 Dijkstra来演示路径还原 其他的算法也都可以用这个来解决</p>
<p>在此算法中满足 d[j] = d[k] + cost[k][j]的点K我们称为j的前驱结点，也就是在到j之前必须经过点K</p>
<p>我们用一个数组prev来存相应节点的前驱结点，不断寻找前驱结点就可以找到最短路了，不过这是从后往前找</p>
<p>最后需要反转一下得到最后的答案。</p>
<p>示例代码如下： 注意第25行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cost[MAXN][MAXN]; <span class="comment">// cost[i][j] 表示从i到j之间的权值（不存在是为INF）</span></span><br><span class="line"><span class="keyword">int</span> d[MAXN]; <span class="comment">// 从起点到其他点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> used[MAXN]; <span class="comment">// 已经使用过的图（已经确定最短距离的点）</span></span><br><span class="line"><span class="keyword">int</span> V; <span class="comment">// 点的个数</span></span><br><span class="line"><span class="keyword">int</span> prev[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d,d+V,INF); <span class="comment">// algorithm中的函数 将d数组全部赋为INF</span></span><br><span class="line">    fill(used,used+V,<span class="literal">false</span>);</span><br><span class="line">    fill(prev,prev+V,<span class="number">-1</span>); <span class="comment">// -1表示到头了 即没有前驱结点</span></span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// c从未使用过的点集中取一个距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; V;u++)</span><br><span class="line">        	<span class="keyword">if</span>(!used[u] &amp;&amp; (v == <span class="number">-1</span> || d[u] &lt; d[v])) v = u;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 所有的点的最短路径确定则退出</span></span><br><span class="line">       	used[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; V;u++)</span><br><span class="line">        &#123;</span><br><span class="line">            d[u] = min(d[u],d[v]+cost[v][u]);</span><br><span class="line">            prev[u] = v; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到顶点t的最短路</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">get_path</span><span class="params">(<span class="keyword">int</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">for</span>(; t != <span class="number">-1</span>;t = prev[t]) path.push_pack(t);</span><br><span class="line">    reverse(path.begin(),path.end());</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>The end</strong> !!!</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtual Box 配置虚拟机 Ubuntu</title>
    <url>/2019/02/14/2019-02-14-VirtualBox_Ubuntu/</url>
    <content><![CDATA[<h2 id="虚拟机的简单概念">虚拟机的简单概念</h2>
<blockquote>
<p>摘自百度百科</p>
</blockquote>
<p>​ 虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。 ​ 虚拟系统通过生成现有操作系统的全新虚拟镜像，它具有真实windows系统完全一样的功能，进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响 ，而且具有能够在现有系统与虚拟镜像之间灵活切换的一类操作系统。虚拟系统和传统的虚拟机（Parallels Desktop ，Vmware，VirtualBox，Virtual pc）不同在于：虚拟系统不会降低电脑的性能，启动虚拟系统不需要像启动windows系统那样耗费时间，运行程序更加方便快捷；虚拟系统只能模拟和现有操作系统相同的环境，而虚拟机则可以模拟出其他种类的操作系统；而且虚拟机需要模拟底层的硬件指令，所以在应用程序运行速度上比虚拟系统慢得多。</p>
<a id="more"></a>
<h2 id="下载-virtual-box">1. 下载 Virtual Box</h2>
<h3 id="下载位置">下载位置</h3>
<p><code>https://www.virtualbox.org/wiki/Downloads</code></p>
<p>下载相应的版本即可</p>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_1.jpg" alt="Download_Virtual_Box" /><figcaption>Download_Virtual_Box</figcaption>
</figure>
<h2 id="下载ubuntu镜像文件">2. 下载Ubuntu镜像文件</h2>
<h3 id="下载位置-1">下载位置</h3>
<p><strong>官方网站：</strong><code>https://www.ubuntu.com/download/desktop</code></p>
<p><strong>网易镜像：</strong><code>http://mirrors.163.com/ubuntu-releases/</code> =&gt; <strong>ubuntu-18.10-desktop-amd64.iso</strong></p>
<p>选一个合适的版本即可 这里采用的是Ubuntu-18.10, 国内镜像可能会快一些，你也可以采用其他镜像源</p>
<h2 id="开始安装">3. 开始安装</h2>
<h3 id="新建虚拟机">- 新建虚拟机</h3>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_2.jpg" alt="add a VM" /><figcaption>add a VM</figcaption>
</figure>
<p>后面都只需要默认即可</p>
<h3 id="配置选项">- 配置选项</h3>
<p>在这里设置内存大小，处理器等设置，内存、处理器酌情增加，太小巨卡</p>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_3.jpg" alt="set VM" /><figcaption>set VM</figcaption>
</figure>
<p>在第二个小光盘出点击选择一个虚拟光盘文件，也就是前面下载的Ubuntu镜像文件</p>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_4.jpg" alt="set VM" /><figcaption>set VM</figcaption>
</figure>
<h3 id="双击开启安装">- 双击开启安装</h3>
<p>语言可以先设置为中文简体，后面都只需要默认即可</p>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_5.jpg" alt="apply" /><figcaption>apply</figcaption>
</figure>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_9.jpg" alt="apply" /><figcaption>apply</figcaption>
</figure>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_6.jpg" alt="apply" /><figcaption>apply</figcaption>
</figure>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_7.jpg" alt="apply" /><figcaption>apply</figcaption>
</figure>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_8.jpg" alt="apply" /><figcaption>apply</figcaption>
</figure>
<h3 id="最后重启即可">- 最后重启即可</h3>
<h3 id="注意事项">- 注意事项</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9qaW5neWFuLmJhaWR1LmNvbS9hcnRpY2xlL2FiMGI1NjMwNWYyODgyYzE1YWZhN2RkYS5odG1s">BIOS可能未开启虚拟化<i class="fa fa-external-link-alt"></i></span></p>
<p>一般不行就删掉重新来一遍，一般都可以</p>
<p>处理器最好选择2个以上，不然容易中途安装失败</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Life Record 1</title>
    <url>/2019/02/21/2019-02-21-Life/</url>
    <content><![CDATA[<blockquote>
<p>2019正月至开学前一天</p>
</blockquote>
<ul>
<li><p>2018下学期的离散70+</p></li>
<li><p>老弟学会吞药</p></li>
<li><p>没有钱是万万不能的</p></li>
<li><p>人老了是真的可怜</p></li>
<li><p>呆在家里真好</p></li>
</ul>
<a id="more"></a>
<h2 id="新年flag">新年Flag</h2>
<p>是时候真正努力了，自己还是很自私的，</p>
<p>改掉这些毛病，做一件事就认真去做，马上去做，时间是真的会消磨人</p>
<p>自以为自我控制能力很好，也就是自欺欺人罢了</p>
<p>坦白吧，多去图书馆，学习为什么怕别人知道呢</p>
<p>再加一条，多锻炼</p>
<p>做个爱学习的人吧 ：）</p>
<p>—— 2019-2-21 绿皮火车</p>
]]></content>
      <categories>
        <category>Life Record</category>
      </categories>
  </entry>
  <entry>
    <title>IF I STAY</title>
    <url>/2019/01/12/2019-01-12-If_I_Stay/</url>
    <content><![CDATA[<blockquote>
<p>A Song To Share And Save</p>
</blockquote>
<a id="more"></a>
<h1 id="if-i-stay">IF I STAY</h1>
<figure>
<img src="/assets/ArticleImg/Life/If_I_Stay.jpg" alt="if i stay" /><figcaption>if i stay</figcaption>
</figure>
<p>作曲 : <strong><em>逃跑计划</em></strong></p>
<p>作词 : <strong><em>Shaun Gibson</em></strong></p>
<p><a href="http://music.163.com/song?id=37782201&amp;userid=592448485"><strong>Click To Listening</strong></a></p>
<p><strong>Don’t you ever question why</strong></p>
<p>你从未问过我</p>
<p><strong>I’m by your side</strong></p>
<p>为何我会陪伴在你左右</p>
<p><strong>I’m here when you cry</strong></p>
<p>你哭泣时我在你身旁</p>
<p><strong>Cause he told you lies so slyly</strong></p>
<p>因为他那么狡猾 对你说尽谎言</p>
<p><strong>I run my fingers through your hair</strong></p>
<p>我的手指穿过你的秀发</p>
<p><strong>And show I care</strong></p>
<p>对你表明我多么在乎你</p>
<p><strong>But I’m not the one</strong></p>
<p>而我却不是那个</p>
<p><strong>That your heart belongs to nightly</strong></p>
<p>你每晚牵挂的唯一</p>
<p><strong>But if I stay would you kiss me in the summer rain</strong></p>
<p>但我若留在你身边你会不会在夏日细雨中吻我</p>
<p><strong>Or let me wash away into the sand</strong></p>
<p>还是让我如雨水涤荡的尘沙 就此疏淡</p>
<p><strong>Would we lie together underneath the burning sun</strong></p>
<p>我们会不会一同躺在骄阳之下</p>
<p><strong>And let our two hearts beat as one</strong></p>
<p>两颗心跳动如一</p>
<p><strong>If I stay would you let me hold you in my arms</strong></p>
<p>若我留在你身边 你会让我拥你入怀吗</p>
<p><strong>And later take a walk beneath the stars</strong></p>
<p>然后我们漫步在星空之下</p>
<p><strong>Woah, tell me someday this could all be real</strong></p>
<p>喔 告诉我终有一天这一切都会成真</p>
<p><strong>And end this heartache I’m pained to feel</strong></p>
<p>结束这让我难熬的心痛</p>
<p><strong>I’ve loved you without regret</strong></p>
<p>我爱你无怨无悔</p>
<p><strong>Since the day we met</strong></p>
<p>自从我们相遇的那一天起</p>
<p><strong>If what you see’s what you get</strong></p>
<p>如果眼前的人就是你终会拥有的人</p>
<p><strong>Well I’ve had nothing yet</strong></p>
<p>那我认了 我依然一无所有</p>
<p><strong>For these past years</strong></p>
<p>即使过去了这么多年</p>
<p><strong>Tell me will you ever feel the same</strong></p>
<p>告诉我 你是否有过和我同样的感受</p>
<p><strong>If my love won’t tame?</strong></p>
<p>如果我的爱永不消减</p>
<p><strong>Or just like cellophane</strong></p>
<p>或者它就如玻璃纸一般脆弱</p>
<p><strong>Will I call your name unto deaf ears?</strong></p>
<p>我是否会在你耳畔轻唤你名字 就算你置若罔闻</p>
<p><strong>And if I stay would you kiss me in the summer rain</strong></p>
<p>但我若留在你身边你会不会在夏日细雨中吻我</p>
<p><strong>Or let me wash away into the sand</strong></p>
<p>还是让我如雨水涤荡的尘沙 就此疏淡</p>
<p><strong>Would we lie together underneath the burning sun</strong></p>
<p>我们会不会一同躺在骄阳之下</p>
<p><strong>And let our two hearts beat as one</strong></p>
<p>两颗心跳动如一</p>
<p><strong>If I stay would you let me hold you in my arms</strong></p>
<p>若我留在你身边 你会让我拥你入怀吗</p>
<p><strong>And later take a walk beneath the stars</strong></p>
<p>然后我们漫步在星空之下</p>
<p><strong>Woah, tell me someday this could all be real</strong></p>
<p>喔 告诉我终有一天这一切都会成真</p>
<p><strong>And end this heartache I’m pained to feel</strong></p>
<p>结束这让我难熬的心痛</p>
<p><strong>If I stay would you kiss me in the summer rain</strong></p>
<p>但我若留在你身边你会不会在夏日细雨中吻我</p>
<p><strong>Or let me wash away into the sand</strong></p>
<p>还是让我如雨水涤荡的尘沙 就此疏淡</p>
<p><strong>Would we lie together underneath the burning sun</strong></p>
<p>我们会不会一同躺在骄阳之下</p>
<p><strong>And let our two hearts beat as one</strong></p>
<p>两颗心跳动如一</p>
<p><strong>If I stay would you let me hold you in my arms</strong></p>
<p>若我留在你身边 你会让我拥你入怀吗</p>
<p><strong>And later take a walk beneath the stars</strong></p>
<p>然后我们漫步在星空之下</p>
<p><strong>Woah, tell me someday this could all be real</strong></p>
<p>喔 告诉我终有一天这一切都会成真</p>
<p><strong>And end this heartache I’m pained to feel</strong></p>
<p>结束这让我难熬的心痛</p>
<p><strong>But if I stay would you kiss me in the summer rain</strong></p>
<p>但我若留在你身边你会不会在夏日细雨中吻我</p>
<p><strong>Or let me wash away into the sand</strong></p>
<p>还是让我如雨水涤荡的尘沙 就此疏淡</p>
<p><strong>Would we lie together underneath the burning sun</strong></p>
<p>我们会不会一同躺在骄阳之下</p>
<p><strong>And let our two hearts beat as one</strong></p>
<p>两颗心跳动如一</p>
<p><strong>If I stay would you let me hold you in my arms</strong></p>
<p>若我留在你身边 你会让我拥你入怀吗</p>
<p><strong>And later take a walk beneath the stars</strong></p>
<p>然后我们漫步在星空之下</p>
<p><strong>Woah, tell me someday this could all be real</strong></p>
<p>喔 告诉我终有一天这一切都会成真</p>
<p><strong>And end this heartache I’m pained to feel</strong></p>
<p>结束这让我难熬的心痛</p>
]]></content>
      <categories>
        <category>Life Record</category>
      </categories>
  </entry>
  <entry>
    <title>CYK Algorithm</title>
    <url>/2019/05/03/2019-05-03-CYK/</url>
    <content><![CDATA[<blockquote>
<p>原理参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NzYWFsa2poZ2YvYXJ0aWNsZS9kZXRhaWxzLzgwNDM1Njc2">https://blog.csdn.net/ssaalkjhgf/article/details/80435676<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<a id="more"></a>
<h3 id="实现过程">实现过程</h3>
<h4 id="类说明">类说明</h4>
<h5 id="cnf">CNF</h5>
<p>由一个字典初始化，输入为规范的范式</p>
<p><code>find_product</code>方法实现输入一个变元组合返回其生成变元</p>
<h5 id="cyk">CYK</h5>
<p>由一个CNF初始化，<code>find</code>方法用于判断字符串是否在CNF中</p>
<p>并保存推导过程，即动态规划数组</p>
<h5 id="input">Input</h5>
<p>实现自己的输入函数，一直等待输入直到输入EOF（Ctrl + Z）</p>
<p>并对输入字符串进行简单处理，切分</p>
<p>输入字符串格式为：<span class="math display">\[A -&gt; BC|AD|b \]</span></p>
<p>其中空格可含可不含</p>
<h5 id="visualization">Visualization</h5>
<p>可视化类，将推导过程输出到<code>.csv</code>文件中</p>
<p>将<code>.csv</code>文件使用<strong>Excel</strong>打开便可查看完整推导过程</p>
<p>代码中已有完整注释和使用说明</p>
<h4 id="代码">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Used for judging a string whether be in the CFL (presented in CNF) using CYK algorithm</span></span><br><span class="line"><span class="string">Author: Weijun-Lin</span></span><br><span class="line"><span class="string">Time: 2019-4-27</span></span><br><span class="line"><span class="string">Introduction: </span></span><br><span class="line"><span class="string">    For reading CNF you should use the format &quot;A -&gt; BC|a|b&quot; (the blank space is allowed except &quot;-&gt;&quot;)</span></span><br><span class="line"><span class="string">    The first character will be considered as CFL&#x27;s Start Symbol</span></span><br><span class="line"><span class="string">    And end inputing by input &quot;Ctrl + Z&quot;</span></span><br><span class="line"><span class="string">    For testing strings, you can input as many as strings you want</span></span><br><span class="line"><span class="string">    And exit by using &quot;ctrl + Z&quot;</span></span><br><span class="line"><span class="string">    For Output, the output format is the .csv file whcih should be checked by Excel</span></span><br><span class="line"><span class="string">    The output file name can be changed in codes (the default is &quot;result.csv&quot;)</span></span><br><span class="line"><span class="string">Attention:</span></span><br><span class="line"><span class="string">    When you test a new string, you must closed the last .csv file</span></span><br><span class="line"><span class="string">    Otherwise you will meet a I/O Error because the read-write conflict</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNF</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cnf: <span class="built_in">dict</span></span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; cnf: [str:list] &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.cnf = cnf</span><br><span class="line">        self.S = <span class="built_in">list</span>(cnf.keys())[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_product</span>(<span class="params">self, target: <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; find the productor  &#x27;&#x27;&#x27;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> self.cnf.items():</span><br><span class="line">            <span class="keyword">if</span> target <span class="keyword">in</span> value:</span><br><span class="line">                res.append(key)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CYK</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cnf: CNF</span>):</span></span><br><span class="line">        self.cnf = cnf</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, target: <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; judge if the target is in the CNF &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.dp_mat = [[<span class="string">&quot;&quot;</span>]*<span class="built_in">len</span>(target) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target))]</span><br><span class="line">        <span class="comment"># initialize</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target)):</span><br><span class="line">            self.dp_mat[i][i] = <span class="built_in">list</span>(<span class="built_in">set</span>(self.cnf.find_product(target[i])))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(target) + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># i,j are the position in dp_mat</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target) - length + <span class="number">1</span>):</span><br><span class="line">                j = i + length - <span class="number">1</span></span><br><span class="line">                temp = []</span><br><span class="line">                <span class="comment"># split the sub_target</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, j):</span><br><span class="line">                    list1 = self.dp_mat[i][k]</span><br><span class="line">                    list2 = self.dp_mat[k+<span class="number">1</span>][j]</span><br><span class="line">                    temp += self.find_product(list1, list2)</span><br><span class="line">                self.dp_mat[i][j] = <span class="built_in">list</span>(<span class="built_in">set</span>(temp))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.cnf.S <span class="keyword">in</span> self.dp_mat[<span class="number">0</span>][<span class="built_in">len</span>(target) - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_product</span>(<span class="params">self, list1: <span class="built_in">list</span>, list2: <span class="built_in">list</span></span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; find all productions from Cartesian product of two lists &#x27;&#x27;&#x27;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list2)):</span><br><span class="line">                temp = self.cnf.find_product(list1[i]+list2[j])</span><br><span class="line">                <span class="keyword">if</span> temp != <span class="literal">None</span>:</span><br><span class="line">                    res += temp</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span>:</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; my input class for reading the CNF &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDictItemFromInput</span>(<span class="params">self, s: <span class="built_in">str</span></span>):</span></span><br><span class="line">        s = s.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)  <span class="comment"># delete extra blank spacing</span></span><br><span class="line">        temp = s.split(<span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> temp[<span class="number">0</span>], temp[<span class="number">1</span>].split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getInput</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; return a dict CNF &#x27;&#x27;&#x27;</span></span><br><span class="line">        res = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                s = <span class="built_in">input</span>()</span><br><span class="line">                dict_item = self.getDictItemFromInput(s)</span><br><span class="line">                res[dict_item[<span class="number">0</span>]] = dict_item[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visualization</span>:</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    make the deduction visualized</span></span><br><span class="line"><span class="string">    use dp_mat from class CYK to initialize</span></span><br><span class="line"><span class="string">    and creat .csv file to show in Excel</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data: <span class="built_in">list</span></span>):</span></span><br><span class="line">        self.data = [[<span class="string">&quot;&quot;</span>]*<span class="built_in">len</span>(data) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">            temp = data[i][i:]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - i):</span><br><span class="line">                self.data[<span class="built_in">len</span>(data) - j - <span class="number">1</span>][i] = temp[j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">seeAsCsv</span>(<span class="params">self, filename: <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; write data to filename as .csv &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.data)):</span><br><span class="line">                line = <span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.data[i])):</span><br><span class="line">                    temp = <span class="string">&quot;&quot;</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">type</span>(self.data[i][j]) == <span class="built_in">str</span>:</span><br><span class="line">                        temp = self.data[i][j]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        temp = <span class="string">&quot;\&quot;X&#123;&#125;,&#123;&#125;=&quot;</span>.<span class="built_in">format</span>(j+<span class="number">1</span>,<span class="built_in">len</span>(self.data)-i)+<span class="string">&quot;&#123;&quot;</span></span><br><span class="line">                        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.data[i][j])):</span><br><span class="line">                            temp = temp + self.data[i][j][k]</span><br><span class="line">                            <span class="keyword">if</span> k != <span class="built_in">len</span>(self.data[i][j]) - <span class="number">1</span>:</span><br><span class="line">                                temp = temp + <span class="string">&quot;,&quot;</span></span><br><span class="line">                        temp = temp + <span class="string">&quot;&#125;\&quot;&quot;</span></span><br><span class="line">                    line = line + temp + <span class="string">&quot;,&quot;</span></span><br><span class="line">                f.write(line + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(<span class="string">&quot;Please Input the CNF: (The First Character must be Start symbol until Ctrl+Z )&quot;</span>)</span><br><span class="line">    myinput = Input()</span><br><span class="line">    <span class="comment"># get the CNF read until miss ctrl + Z</span></span><br><span class="line">    data_dict = myinput.getInput()</span><br><span class="line">    <span class="comment"># creat my CYK algorithm</span></span><br><span class="line">    cyk = CYK(CNF(data_dict))</span><br><span class="line">    print(<span class="string">&quot;input the string: (until Ctrl+Z)&quot;</span>)</span><br><span class="line">    <span class="comment"># test the input string until read the ctrl + z</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            target_str = <span class="built_in">input</span>()</span><br><span class="line">            <span class="keyword">if</span> cyk.find(target_str):</span><br><span class="line">                print(<span class="string">&quot;Yes&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">&quot;No&quot;</span>)</span><br><span class="line">            visual = Visualization(cyk.dp_mat)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                visual.seeAsCsv(<span class="string">&quot;result.csv&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                print(<span class="string">&quot;Write Error: Please Close Last csv file&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>图像库stb_image &amp; stb_image_write</title>
    <url>/2019/02/24/2019-02-24-stb_image/</url>
    <content><![CDATA[<blockquote>
<p>Github: https://github.com/nothings/stb/</p>
</blockquote>
<h2 id="stb_image">stb_image</h2>
<blockquote>
<p>stb的库像素数据都是从左到右，从上到下存储</p>
<p>使用 stbi_set_flip_vertically_on_load(true); 上下翻转</p>
<p>使用 stbi_flip_vertically_on_write(true); 在写数据的时候翻转 （在stb_write_image中）</p>
</blockquote>
<a id="more"></a>
<h3 id="使用库">- 使用库</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;...&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_IMPLEMENTATION	<span class="comment">// include之前必须定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stb_image.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="局限">- 局限</h3>
<ul>
<li>no 12-bit-per-channel JPEG</li>
<li>no JPEGs with arithmetic coding</li>
<li>GIF always returns *comp=4</li>
</ul>
<h3 id="基础用法">- 基础用法</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y,n;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">&quot;filename&quot;</span>,&amp;x,&amp;y,&amp;n,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// filename : 文件名</span></span><br><span class="line"><span class="comment">// x : 图片宽 </span></span><br><span class="line"><span class="comment">// y : 图片高</span></span><br><span class="line"><span class="comment">// n : 颜色通道个数</span></span><br><span class="line"><span class="comment">// 最后一个为自己设置的颜色通道个数，如果非0就按照此数值读取图像</span></span><br><span class="line"><span class="comment">// 返回值非NULL说明导入成功</span></span><br><span class="line"><span class="comment">// Do Something</span></span><br><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure>
<h4 id="颜色通道">颜色通道</h4>
<ul>
<li>1： 灰度图</li>
<li>2： 灰度Alpha图</li>
<li>3： 红绿蓝三色图</li>
<li>4： 红绿蓝三色Alpha图</li>
</ul>
<h4 id="错误信息">错误信息</h4>
<figure class="highlight plain"><figcaption><span>char* stbi_failure_reason()```返回错误信息字符串</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 定义 STBI_NO_FAILURE_STRINGS  避免编译这些字符串</span><br><span class="line">- 定义 STBI_FAILURE_USERMSG 使错误信息更加容易阅读</span><br><span class="line"></span><br><span class="line">#### Unicode</span><br><span class="line"></span><br><span class="line">Windows环境下可能需要满足Unicode的文件名</span><br><span class="line"></span><br><span class="line">&#96;#define STBI_WINDOWS_UTF8&#96;可以使文件名满足Unicode</span><br><span class="line"></span><br><span class="line">也可以使用&#96;stbiw_convert_wchar_to_utf8&#96;将&#96;Windows wchar_t&#96; 转换为 &#96;utf8&#96;.</span><br><span class="line"></span><br><span class="line">#### Addition</span><br><span class="line"></span><br><span class="line">- 预编译取消对某个格式的解析 ：#define STBI_NO_PNG....</span><br><span class="line">- 预编译限制只能某个格式解析 ：#define STBI_ONLY_PNG...</span><br><span class="line"></span><br><span class="line">### Else</span><br><span class="line"></span><br><span class="line">获取x,y位置的像素信息，data为图像指针,n为颜色通道数</span><br><span class="line"></span><br><span class="line">data[w\*n\*x+n\*y+i] (i &#x3D; 0,1,..,n-1)</span><br><span class="line"></span><br><span class="line">作者还介绍了 SIMD支持， HDR图像支持， Iphone PNG支持</span><br><span class="line"></span><br><span class="line">## stb_image_write</span><br><span class="line"></span><br><span class="line">### - 使用库</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">#include &lt;...&gt;</span><br><span class="line">#define #define STB_IMAGE_WRITE_IMPLEMENTATION	&#x2F;&#x2F; include之前必须定义</span><br><span class="line">#include &quot;stb_image_write.h&quot;</span><br></pre></td></tr></table></figure>
<h3 id="简单的使用">- 简单的使用</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stbi_write_png</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *filename, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> comp, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">int</span> stride_in_bytes)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stbi_write_bmp</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *filename, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> comp, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stbi_write_tga</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *filename, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> comp, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stbi_write_jpg</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *filename, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> comp, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">int</span> quality)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stbi_write_hdr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *filename, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> comp, <span class="keyword">const</span> <span class="keyword">float</span> *data)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="else">- Else</h3>
<p>作者还提到了PNG压缩，可提供自己的压缩函数，还有JPG质量的参数</p>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stb_image.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stb_image_write.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span> alpha, <span class="keyword">unsigned</span> <span class="keyword">char</span> *data)</span> </span>&#123;</span><br><span class="line">	data[w*n*x + y * n + n - <span class="number">1</span>] = alpha;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *filepath = <span class="string">&quot;demo.png&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> w, h, n;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(filepath, &amp;w, &amp;h, &amp;n, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROE_FILE_NOT_LOAD&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; h &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">// 将上半身设置为透明</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h / <span class="number">2</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">				setAlpha(i, j, n, w, <span class="number">0</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 写的时候翻转</span></span><br><span class="line">		stbi_flip_vertically_on_write(<span class="literal">true</span>);</span><br><span class="line">		stbi_write_png(<span class="string">&quot;out.png&quot;</span>, w, h, n, data, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">        stbi_image_free(data);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原图像 <img src="https://img-blog.csdnimg.cn/20190224135232798.png" alt="在这里插入图片描述" /></li>
<li>处理后 <img src="https://img-blog.csdnimg.cn/20190224135301289.png" alt="在这里插入图片描述" /></li>
</ul>
<p>作者还有一个<code>stb_image_resize.h</code>支持对图像的简单放缩平移等操作</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《30天自制操作系统》 笔记目录</title>
    <url>/2020/01/24/2020-01-24-30OSMakeNoteAll/</url>
    <content><![CDATA[<h1 id="daysmakeos-note">30DaysMakeOS-Note</h1>
<blockquote>
<p>《30天自制操作系统》（川合秀实）阅读笔记</p>
</blockquote>
<h2 id="笔记目录">笔记目录</h2>
<ul>
<li><a href="https://Weijun-Lin.top/2020/01/24/2020-01-24-30OSMakeNote01-03/">第一天到第三天——从汇编到C语言</a></li>
<li><a href="https://Weijun-Lin.top/2020/01/26/2020-01-26-30OSMakeNote04/">第四天——C语言和画面显示的练习</a></li>
</ul>
<hr />
<a id="more"></a>
<p>书本实现了一个名为OSASK的只有80KB的简单操作系统，效果图如下</p>
<p><img src="/assets/Note/30DaysOs/Screen.png" style="zoom:50%;" /></p>
<h2 id="书本各章内容概要摘自原文">书本各章内容概要（摘自原文）</h2>
<h3 id="第一周第1天-第7天">第一周（第1天 ～ 第7天）</h3>
<p>一开始首先要考虑怎么来写一个“只要一通电就能运行的程序”。 这部分用C语言写 起来有些困难， 所以主要还是用汇编语言来写。 这步完成之后， 下一步就要写一个从磁盘读取操作系统的程序。 这时即便打开电脑 电源， 它也不会自动地将操作系统全部都读进来， 它只能读取磁盘上最开始的512 字节的内容， 所以我们要编写剩余部分的载入程序。 这个程序也要用汇编语言编 写。 一旦完成了这一步， 以后的程序就可以用C语言来编写了。 我们就尽快使用C语言 来学习开发显示画面的程序。 同时， 我们也能慢慢熟悉C语言语法。 这个时候我们 好像在做自己想做的事， 但事实上我们还没有自由操纵C语言。 接下来， 为了实现“移动鼠标”这一雄心， 我们要对CPU进行细致的设定， 并掌握中 断处理程序的写法。 从全书总体看来， 这一部分是水平相当高的部分， 笔者也觉得 放在这里有些不妥， 但从本书条理上讲， 这些内容必须放在这里， 所以只好请大家 忍耐一下了。 在这里， CPU的规格以及电脑复杂的规格都会给我们带来各种各样的 麻烦。 而且开发语言既有C语言， 又有汇编语言， 这又给我们造成了更大的混乱。 这个时候我们一点儿也不会觉得这是在做自己想做的事， 怎么看都像是在“受人摆 布”。 渡过这个痛苦的时期， 第一周就该结束了。</p>
<h3 id="第二周第8天-第14天">第二周（第8天 ～ 第14天）</h3>
<p>一周的苦战还是很有意义的， 回头一看， 我们就会发现自己还是斩获颇丰的。 这时 我们已经基本掌握了C语言的语法， 连汇编语言的水平也能达到本书的要求了。 所以现在我们就可以着手开发像样的操作系统了。 但是这一次我们又要为算法头痛 了。 即使掌握了编程语言的语法， 如果不懂得好的算法的话， 也还是不能开发出来 自己想要的操作系统。 所以这一周我们就边学习算法边慢慢地开发操作系统。 不过 到了这一阶段， 我们就能感觉到基本上不会再受技术问题限制了。</p>
<h3 id="第三周第15天-第21天">第三周（第15天 ～ 第21天）</h3>
<p>现在我们的技术已经相当厉害了， 可以随心所欲地开发自己的操作系统了。 首先是 要支持多任务， 然后是开发命令行窗口， 之后就可以着手开发应用程序了。 到本周 结束时， 就算还不够完备， 我们也能拿出一个可以称之为操作系统的软件了。</p>
<h3 id="第四周第22天-第28天">第四周（第22天 ～ 第28天）</h3>
<p>在这个阶段， 我们可以尽情地给操作系统增加各种各样的功能， 同时还可以开发出 大量像模像样的应用程序来。 这个阶段我们已经能做得很好了， 这可能也是我们最 高兴的时期。 这部分要讲解的内容很少， 笔者也不用再煞费苦心地去写那些文字说 明了， 可以把精力都集中在编程上（笑） 。 对了， 说起文字才想起来， 正好在这个 时期可以让我们的操作系统显示文字了。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>30天自制操作系统</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《30天自制操作系统》 01-03 从汇编到C语言</title>
    <url>/2020/01/24/2020-01-24-30OSMakeNote01-03/</url>
    <content><![CDATA[<h1 id="day-note">01-03-Day-Note</h1>
<blockquote>
<p>第一天到第三天的笔记</p>
</blockquote>
<a id="more"></a>
<h2 id="运行环境准备">1. 运行环境准备</h2>
<p>中文源码（包含每章节最终的翻译代码）：https://github.com/yourtion/30dayMakeOS</p>
<p>可以直接在作者提供的开发包中执行作者提供的文件，执行过程如下：</p>
<ol type="1">
<li>将对应<code>project</code>中包含源代码的目录复制到<code>tolset</code>中</li>
<li>执行对应的<code>Makefile</code>指令</li>
</ol>
<p><strong>需要在Windows的Shell环境下执行，在Git Bash执行会存在命令的不一致问题</strong></p>
<p>作者在<code>nasm</code>的基础上开发了名为<code>nask</code>的汇编编译器，然后通过<code>imgtol</code>制作img镜像文件，最后通过<code>qemu</code>虚拟机运行此镜像文件，作者已经写好所有样例代码以及运行的脚本文件（批处理文件和Makefile）</p>
<p>上面所有的作者工具都在书本配套文件的<code>tolset</code>中</p>
<p>当然以上基础编译工具都可以使用已有工具代替（作者的类似很古老了）</p>
<h4 id="其他工具替代">其他工具替代</h4>
<ul>
<li><p>使用<code>nasm</code>替代<code>nask</code></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nasm infile.asm -o outfile.img</span><br></pre></td></tr></table></figure></p></li>
<li><p>使用最新的 <code>qemu</code> 替代（此处为qemu4)</p>
<p><code>qemu</code>基本命令行参数参考 https://www.datarelab.com/blog/Technical_literature/562.html</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-i386 -fda youros.img</span><br></pre></td></tr></table></figure></p></li>
<li><p>代替作者的<code>imgtol</code></p>
<p>可以使用Linux的<code>dd</code>命令替换 Windows 下可在此处下载：http://www.chrysocome.net/download</p>
<p><code>dd</code>是类似<code>cp</code>的一个工具，不过<code>dd</code>针对的是块而cp针对的是文件</p>
<p>可参考：http://blackblog.tech/2018/07/19/CreateOSDay3/#comments</p></li>
</ul>
<h2 id="汇编">2. 汇编</h2>
<h3 id="i.-寄存器">i. 寄存器</h3>
<h4 id="位寄存器">16 位寄存器</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">名字</th>
<th style="text-align: left;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">AX</td>
<td style="text-align: left;">accumulator， 累加寄存器</td>
</tr>
<tr class="even">
<td style="text-align: left;">CX</td>
<td style="text-align: left;">counter， 计数寄存器</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DX</td>
<td style="text-align: left;">data， 数据寄存器</td>
</tr>
<tr class="even">
<td style="text-align: left;">BX</td>
<td style="text-align: left;">base， 基址寄存器</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SP</td>
<td style="text-align: left;">stack pointer， 栈指针寄存器</td>
</tr>
<tr class="even">
<td style="text-align: left;">BP</td>
<td style="text-align: left;">base pointer， 基址指针寄存器</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SI</td>
<td style="text-align: left;">source index， 源变址寄存器</td>
</tr>
<tr class="even">
<td style="text-align: left;">DI</td>
<td style="text-align: left;">destination index， 目的变址寄存器</td>
</tr>
</tbody>
</table>
<h4 id="位寄存器-1">8 位寄存器</h4>
<table>
<thead>
<tr class="header">
<th>名字</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AL</td>
<td>累加寄存器低位（accumulator low）</td>
</tr>
<tr class="even">
<td>CL</td>
<td>计数寄存器低位（counter low）</td>
</tr>
<tr class="odd">
<td>DL</td>
<td>数据寄存器低位（data low）</td>
</tr>
<tr class="even">
<td>BL</td>
<td>基址寄存器低位（base low）</td>
</tr>
<tr class="odd">
<td>AH</td>
<td>累加寄存器高位（accumulator high）</td>
</tr>
<tr class="even">
<td>CH</td>
<td>计数寄存器高位（counter high）</td>
</tr>
<tr class="odd">
<td>DH</td>
<td>数据寄存器高位（data high）</td>
</tr>
<tr class="even">
<td>BH</td>
<td>基址寄存器高位（base high）</td>
</tr>
</tbody>
</table>
<h4 id="段寄存器">段寄存器</h4>
<table>
<thead>
<tr class="header">
<th>名字</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ES</td>
<td>附加段寄存器（extra segment）</td>
</tr>
<tr class="even">
<td>CS</td>
<td>代码段寄存器（code segment）</td>
</tr>
<tr class="odd">
<td>SS</td>
<td>栈段寄存器（stack segment）</td>
</tr>
<tr class="even">
<td>DS</td>
<td>数据段寄存器（data segment）</td>
</tr>
<tr class="odd">
<td>FS</td>
<td>没有名称（segment part 2）</td>
</tr>
<tr class="even">
<td>GS</td>
<td>没有名称（segment part 3）</td>
</tr>
</tbody>
</table>
<h4 id="位拓展寄存器">32 位拓展寄存器</h4>
<p>EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI （加了个extend拓展的标签）</p>
<h3 id="ii.-基础指令">ii. 基础指令</h3>
<ul>
<li><p>DB：按字节定义类似的还有DW（定义字），DD（定义双字）</p></li>
<li><p>MOV：移动指令<code>mov A, B</code>意为<code>A = B</code>, <code>mov</code>后的寄存器或者字面量加上<code>[]</code>则代表引用此地址的值</p>
<p>如：<code>MOV AL, BYTE [BX]</code>，会将指定段寄存器乘16倍将上BX的值形成目标地址</p>
<p>BX、 BP、 SI、 DI这几个。 剩下的AX、 CX、 DX、 SP不能用来指定内存地址</p></li>
<li><p>JMP：跳转指令 跳转到指定内存地址</p></li>
<li><p>INT：软件中断指令 后接中断号，调用BIOS预设的函数（功能）</p></li>
<li><p>JE：相等则跳转（工具FLAGS寄存器的标志寄存器的值跳转）</p></li>
<li><p>CMP：比较两个寄存器（书面量）的值，修改对应的标志寄存器</p></li>
<li><p>HLT：让CPU进入待机状态只要外部发生变化， 比如按下键盘， 或是移动鼠标， CPU就会醒过来， 继续执行程序</p></li>
<li><p>RESB：填充指定数量字节的0x00</p></li>
<li><p>ORG：将指令加载到指定位置，详情可见：https://blog.csdn.net/yuduoluogongwu/article/details/7359242</p></li>
</ul>
<h3 id="iii.-nasm-和-nask-的区别">iii. NASM 和 NASK 的区别</h3>
<p>nask 和 nasm 部分语法不同，差别如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">NASK代码</th>
<th style="text-align: left;">NASM代码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">JMP entry</td>
<td style="text-align: left;">JMP SHORT entry</td>
</tr>
<tr class="even">
<td style="text-align: right;">RESB <填充字节数></td>
<td style="text-align: left;">TIMES <填充字节数> DB <填充数据></td>
</tr>
<tr class="odd">
<td style="text-align: right;">RESB 0x7dfe-$</td>
<td style="text-align: left;">TIMES 0x1fe-($-$$) DB 0</td>
</tr>
<tr class="even">
<td style="text-align: right;">ALIGNB 16</td>
<td style="text-align: left;">ALIGN 16, DB 0</td>
</tr>
</tbody>
</table>
<p>在文中出现了美元符代表的意思如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ 是当前位置</span><br><span class="line">$$ 是段开始位置</span><br><span class="line">$ - $$ 是当前位置在段内的偏移</span><br></pre></td></tr></table></figure>
<h2 id="makefile">3. Makefile</h2>
<p>Makefile就像是一个非常聪明的批处理文件</p>
<p>具体操作说明可参考：http://www.ruanyifeng.com/blog/2015/02/make.html</p>
<h2 id="ipl">4. IPL</h2>
<h3 id="软盘-fat12">软盘 FAT12</h3>
<p>作者使用的是格式为<code>FAT12</code>格式的软盘</p>
<p>用Windows或MS-DOS格式化出来的软盘就是这种格式。 作者的helloos也采用了这种格式， 其中容纳了作者开发的操作系统。 这个格式兼容性好， 在Windows上也能用， 而且剩余的磁盘空间还可以用来保存自己喜欢的文件。</p>
<p>1张软盘有80个柱面， 2个磁头， 18个扇区， 且一个扇区有512字节。 所以， 一张软盘的容量是： 80×2×18×512 = 1474560 Byte = 1440KB</p>
<h3 id="启动区">启动区</h3>
<p>（boot sector） 软盘第一个的扇区称为启动区。 那么什么是扇区呢？ 计算机读写软盘的时候， 并不是一个字节一个字节地读写的， 而是以512字节为一个单位进行读写。 因此,软盘的512字节就称为一个扇区。 一张软盘的空间共有1440KB， 也就是1474560字节， 除以512得2880， 这也就是说一张软盘共有2880个扇区。 那为什么第一个扇区称为启动区呢？ 那是因为计算机首先从最初一个扇区开始读软盘， 然后去检查这个扇区最后2个字节的内容。如果这最后2个字节不是0x55 AA， 计算机会认为这张盘上没有所需的启动程序， 就会报一个不能启动的错误。 （也许有人会问为什么一定是0x55AA呢？ 那是当初的设计者随便定的， 笔者也没法解释） 。 如果计算机确认了第一个扇区的最后两个字节正好是0x55 AA， 那它就认为这个扇区的开头是启动程序， 并开始执行这个程序。</p>
<h3 id="ipl-启动程序装载器">IPL 启动程序装载器</h3>
<p>initial program loader的缩写。 启动程序加载器。 启动区只有区区512字节， 实际的操作系统不像hello-os这么小， 根本装不进去。 所以几乎所有的操作系统， 都是把加载操作系统本身的程序放在启动区里的。 有鉴于此， 有时也将启动区称为IPL。 但hello-os没有加载程序的功能， 所以HELLOIPL这个名字不太顺理成章。 如果有人正义感特别强， 觉得“这是撒谎造假， 万万不能容忍！ ”， 那也可以改成其他的名字。 但是必须起一个8字节的名字， 如果名字长度不到8字节的话， 需要在最后补上空格</p>
<h3 id="制作-ipl">制作 IPL</h3>
<p>计算机加载操作系统的流程如下：</p>
<ol type="1">
<li>从特定位置读取操作系统数据（USB或者软盘，软盘已经淘汰了），但这里使用的是软盘</li>
<li>软盘的第一个512字节的扇区作为启动区，执行此启动区指令</li>
<li>该启动区将软盘内容加载到内存指定位置(0x7c00)运行，根据最后两字节判断是否是启动区</li>
</ol>
<p>文中的IPL加载了软盘的10个柱面</p>
<p>文中的IPL如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; haribote-ipl</span><br><span class="line">; TAB&#x3D;4</span><br><span class="line"></span><br><span class="line">CYLS	EQU		10				; 声明CYLS&#x3D;10</span><br><span class="line"></span><br><span class="line">		ORG		0x7c00			; 指明程序装载地址</span><br><span class="line"></span><br><span class="line">; 标准FAT12格式软盘专用的代码 Stand FAT12 format floppy code</span><br><span class="line"></span><br><span class="line">		JMP		entry</span><br><span class="line">		DB		0x90</span><br><span class="line">		DB		&quot;HARIBOTE&quot;		; 启动扇区名称（8字节）</span><br><span class="line">		DW		512				; 每个扇区（sector）大小（必须512字节）</span><br><span class="line">		DB		1				; 簇（cluster）大小（必须为1个扇区）</span><br><span class="line">		DW		1				; FAT起始位置（一般为第一个扇区）</span><br><span class="line">		DB		2				; FAT个数（必须为2）</span><br><span class="line">		DW		224				; 根目录大小（一般为224项）</span><br><span class="line">		DW		2880			; 该磁盘大小（必须为2880扇区1440*1024&#x2F;512）</span><br><span class="line">		DB		0xf0			; 磁盘类型（必须为0xf0）</span><br><span class="line">		DW		9				; FAT的长度（必??9扇区）</span><br><span class="line">		DW		18				; 一个磁道（track）有几个扇区（必须为18）</span><br><span class="line">		DW		2				; 磁头数（必??2）</span><br><span class="line">		DD		0				; 不使用分区，必须是0</span><br><span class="line">		DD		2880			; 重写一次磁盘大小</span><br><span class="line">		DB		0,0,0x29		; 意义不明（固定）</span><br><span class="line">		DD		0xffffffff		; （可能是）卷标号码</span><br><span class="line">		DB		&quot;HARIBOTEOS &quot;	; 磁盘的名称（必须为11字?，不足填空格）</span><br><span class="line">		DB		&quot;FAT12   &quot;		; 磁盘格式名称（必??8字?，不足填空格）</span><br><span class="line">		RESB	18				; 先空出18字节</span><br><span class="line"></span><br><span class="line">; 程序主体</span><br><span class="line"></span><br><span class="line">entry:</span><br><span class="line">		MOV		AX,0			; 初始化寄存器</span><br><span class="line">		MOV		SS,AX</span><br><span class="line">		MOV		SP,0x7c00</span><br><span class="line">		MOV		DS,AX</span><br><span class="line"></span><br><span class="line">; 读取磁盘</span><br><span class="line"></span><br><span class="line">		MOV		AX,0x0820</span><br><span class="line">		MOV		ES,AX</span><br><span class="line">		MOV		CH,0			; 柱面0</span><br><span class="line">		MOV		DH,0			; 磁头0</span><br><span class="line">		MOV		CL,2			; 扇区2</span><br><span class="line"></span><br><span class="line">readloop:</span><br><span class="line">		MOV		SI,0			; 记录失败次数寄存器</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">		MOV		AH,0x02			; AH&#x3D;0x02 : 读入磁盘</span><br><span class="line">		MOV		AL,1			; 1个扇区</span><br><span class="line">		MOV		BX,0</span><br><span class="line">		MOV		DL,0x00			; A驱动器</span><br><span class="line">		INT		0x13			; 调用磁盘BIOS</span><br><span class="line">		JNC		next			; 没出错则跳转到fin</span><br><span class="line">		ADD		SI,1			; 往SI加1</span><br><span class="line">		CMP		SI,5			; 比较SI与5</span><br><span class="line">		JAE		error			; SI &gt;&#x3D; 5 跳转到error</span><br><span class="line">		MOV		AH,0x00</span><br><span class="line">		MOV		DL,0x00			; A驱动器</span><br><span class="line">		INT		0x13			; 重置驱动器</span><br><span class="line">		JMP		retry</span><br><span class="line">next:</span><br><span class="line">		MOV		AX,ES			; 把内存地址后移0x200（512&#x2F;16十六进制转换）</span><br><span class="line">		ADD		AX,0x0020</span><br><span class="line">		MOV		ES,AX			; ADD ES,0x020因为没有ADD ES，只能通过AX进行</span><br><span class="line">		ADD		CL,1			; 往CL里面加1</span><br><span class="line">		CMP		CL,18			; 比较CL与18</span><br><span class="line">		JBE		readloop		; CL &lt;&#x3D; 18 跳转到readloop</span><br><span class="line">		MOV		CL,1</span><br><span class="line">		ADD		DH,1</span><br><span class="line">		CMP		DH,2</span><br><span class="line">		JB		readloop		; DH &lt; 2 跳转到readloop</span><br><span class="line">		MOV		DH,0</span><br><span class="line">		ADD		CH,1</span><br><span class="line">		CMP		CH,CYLS</span><br><span class="line">		JB		readloop		; CH &lt; CYLS 跳转到readloop</span><br><span class="line"></span><br><span class="line">; 读取完毕，跳转到haribote.sys执行！</span><br><span class="line">		MOV		[0x0ff0],CH		; IPLがどこまで読んだのかをメモ</span><br><span class="line">		JMP		0xc200</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">		MOV		SI,msg</span><br><span class="line"></span><br><span class="line">putloop:</span><br><span class="line">		MOV		AL,[SI]</span><br><span class="line">		ADD		SI,1			; 给SI加1</span><br><span class="line">		CMP		AL,0</span><br><span class="line">		JE		fin</span><br><span class="line">		MOV		AH,0x0e			; 显示一个文字</span><br><span class="line">		MOV		BX,15			; 指定字符颜色</span><br><span class="line">		INT		0x10			; 调用显卡BIOS</span><br><span class="line">		JMP		putloop</span><br><span class="line"></span><br><span class="line">fin:</span><br><span class="line">		HLT						; 让CPU停止，等待指令</span><br><span class="line">		JMP		fin				; 无限循环</span><br><span class="line"></span><br><span class="line">msg:</span><br><span class="line">		DB		0x0a, 0x0a		; 换行两次</span><br><span class="line">		DB		&quot;load error&quot;</span><br><span class="line">		DB		0x0a			; 换行</span><br><span class="line">		DB		0</span><br><span class="line"></span><br><span class="line">		RESB	0x7dfe-$		; 填写0x00直到0x001fe</span><br><span class="line"></span><br><span class="line">		DB		0x55, 0xaa</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后以0x55aa结尾说明是启动区</p>
<p>该启动区代码包含了试错，循环读取扇区和柱面</p>
<p>主要注意：</p>
<ol type="1">
<li><p>第41行：<code>MOV        AX,0x0820</code></p>
<p>这段是把第一个柱面的第二个扇区（第一个为启动扇区），加载到内存<code>0x8200</code>的位置，0x13通过段寄存器ES和BX设置，这里ES为<code>0x0820</code>需要扩大16倍即为<code>0x8200</code></p>
<p>这里BIOS将系统启动代码（第一个扇区）加载到<code>0x8000</code>处，然后我们的IPL加载之后的扇区，所以将AX赋值为<code>0x0820</code>然后在赋值给ES</p></li>
<li><p>第82行：<code>JMP        0xc200</code></p>
<p>这里是启动区代码执行成功后，跳转到<code>0xc200</code>处执行代码</p>
<p>我们的真正的OS代码保留在软盘的<code>0x4200</code>的位置，软盘的第一个扇区的位置是<code>0x8000</code>所以有<code>0x8000+0x4200 = 0xc200</code>，所以跳转到此位置</p>
<p><code>0x4200</code>是因为向软盘写文件时一帮保存到此位置</p></li>
<li><p>第107行：<code>RESB  0x7dfe-$        ; 填写0x00直到0x001fe</code></p>
<p>只是将启动区后续部分填充为0</p>
<p><code>0x7dfe = 0x7c00 + 511</code>得到，表示512字节的启动区</p></li>
</ol>
<h2 id="导入c语言">5. 导入C语言</h2>
<p>文章中将C语言代码<code>bootpack.c</code>编译为32位汇编，要使用C语言，在操作系统中必然是C语言和汇编是混合复用的，所以需要专门的代码进行链接，文章中给出的是<code>asmhead.nas</code>,这里进行了对显卡显示模式的设置，以及对C语言的导入操作，可以到此文件中看一看，作者给出了很清楚的注释。（中文代码：https://github.com/yourtion/30dayMakeOS/blob/master/03_day/）</p>
<p>对C语言的处理作者分为以下几步：</p>
<ul>
<li>使用cc1.exe从bootpack.c生成bootpack.gas</li>
<li>使用gas2nask.exe从bootpack.gas生成bootpack.nas</li>
<li>使用nask.exe从bootpack.nas生成bootpack.obj</li>
<li>使用obj2bim.exe从bootpack.obj生成bootpack.bim</li>
<li>使用bim2hrb.exe从bootpack.bim生成bootpack.hrb</li>
<li>这样就做成了机器语言， 再使用copy指令将asmhead.bin与bootpack.hrb单纯结合到起来， 就成了haribote.sys</li>
</ul>
<p><code>cc1</code>是C编译器， 将C语言代码编译为32位的GAS的汇编代码</p>
<p><code>gas2nask</code>是将gas汇编编译为nasm识别的汇编格式了,通过nask（nasm）编译位OBJ目标文件</p>
<p><code>obj2bim</code>将目标文件编译为二进制镜像文件，方便不同的目标文件进行合并</p>
<p><code>bim2hrb</code>将最后的合并目标文件编译为<code>hrb</code>文件（这个是适合作者的这个编译环境的最终二进制文件）</p>
<h3 id="c语言调用汇编">C语言调用汇编</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; naskfunc</span><br><span class="line">; TAB&#x3D;4</span><br><span class="line"></span><br><span class="line">[FORMAT &quot;WCOFF&quot;]				; 制作目标文件的模式	</span><br><span class="line">[BITS 32]						; 制作32位模式用的机器语言</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 制作目标文件的信息</span><br><span class="line"></span><br><span class="line">[FILE &quot;naskfunc.nas&quot;]			; 源文件名信息</span><br><span class="line"></span><br><span class="line">		GLOBAL	_io_hlt			; 程序中包含的函数名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 以下是实际的函数</span><br><span class="line"></span><br><span class="line">[SECTION .text]		; 目标文件中写了这些后再写程序</span><br><span class="line"></span><br><span class="line">_io_hlt:	; void io_hlt(void);</span><br><span class="line">		HLT</span><br><span class="line">		RET</span><br></pre></td></tr></table></figure>
<p>将此文件的<code>obj</code>文件和C语言的<code>obj</code>文件一起编译为<code>bim</code>即可(使用作者自带的工具)</p>
<p>有几个需要注意的地方：</p>
<ol type="1">
<li>需要和C语言链接的函数都需要标识为<code>GLOBAL</code>，反义为<code>LOCAL</code></li>
<li>导出的函数需要前加<code>_</code>，这样才能和C语言链接，C语言编译后的函数会加<code>_</code></li>
</ol>
<p>可以看看作者的<code>Makefile</code>可以更好的明白整个编译的过程</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>30天自制操作系统</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>图像旋转算法实现 Python</title>
    <url>/2019/05/12/2019-05-13-Img_Rotation/</url>
    <content><![CDATA[<h3 id="旋转原理">旋转原理</h3>
<blockquote>
<p>参考博客：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXVhbjAyL2FydGljbGUvZGV0YWlscy82NzUwODI4">https://blog.csdn.net/liyuan02/article/details/6750828<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<a id="more"></a>
<p>如下图，推导点<span class="math inline">\((x_0,y_0)\)</span>旋转<span class="math inline">\(\theta\)</span>到到点<span class="math inline">\((x,y)\)</span>，半径为R</p>
<p><img src="/assets/ArticleImg/2019/ImgRotation_1.png" /></p>
<p>对于两点坐标可以这样表示：</p>
<p><span class="math display">\[
\begin{align}
x_0 =&amp; R*\cos\alpha \\
y_0 =&amp; R*\sin\alpha \\
For:x\\
x =&amp; R*\cos(\alpha-\theta) \\
=&amp; R*(\cos\alpha\cos\theta+\sin\alpha\sin\theta) \\
=&amp; x_0\cos\theta+y_0\sin\theta \\
For:y\\
y =&amp; R*(\sin(\alpha-\theta)) \\
=&amp; R*(\sin\alpha\cos\theta-\cos\alpha\sin\theta) \\
=&amp; y_0\cos\theta-x_0\sin\theta
\end{align}
\]</span></p>
<p>使用矩阵表示有：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix} \right]=
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
\cos\theta &amp; -\sin\theta &amp; 0 \\
\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{matrix} \right]
\]</span></p>
<p>此为顺时针旋转<span class="math inline">\(\theta\)</span> ，逆时针旋转<span class="math inline">\(\theta\)</span>只需要将 <span class="math inline">\(\theta=-\theta\)</span> 即可，易得：<span class="math inline">\((x,y)\rightarrow(x_0,y_0)\)</span></p>
<p><span class="math display">\[
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix} \right]=
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
\cos\theta &amp; \sin\theta &amp; 0 \\
-\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{matrix} \right]
\]</span></p>
<h3 id="用于实际的旋转矩阵">用于实际的旋转矩阵</h3>
<p>上一部分的旋转矩阵是以数字坐标系推导的，而图像坐标系是以左上角为原点的图像坐标系，我们需要将图像坐标系转换为数字坐标系，方便的也需要从数字坐标系到图像坐标系的逆转换</p>
<p>假设原图片大小为<span class="math inline">\(W,H\)</span>，旋转后所包含图片的最小矩形大小为<span class="math inline">\(W^{&#39;},H^{&#39;}\)</span></p>
<p>设数字坐标系点为<span class="math inline">\((x,y)\)</span>其相应的图像坐标系点为 <span class="math inline">\((x_0,y_0)\)</span> 有如下表达式：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix} \right]=
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
-0.5W &amp; 0.5H &amp; 1
\end{matrix} \right]
\]</span></p>
<p><span class="math display">\[
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix} \right]=
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
0.5W^{&#39;} &amp; 0.5H^{&#39;} &amp; 1
\end{matrix} \right]
\]</span></p>
<p>假设在图像坐标系中有点<span class="math inline">\((x_0,y_0)\)</span>顺时针旋转<span class="math inline">\(\theta\)</span> 到<span class="math inline">\((x,y)\)</span>处转换后大小为<span class="math inline">\(W^{&#39;},H^{&#39;}\)</span>，转换公式有：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix}
\right]=
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix}
\right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp;0 \\
-0.5W &amp; 0.5H &amp; 0 \\
\end{matrix}
\right]
*
\left[
\begin{matrix}
\cos\theta &amp; -\sin\theta &amp; 0 \\
\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
0.5W^{&#39;} &amp; 0.5H^{&#39;} &amp; 1
\end{matrix} \right]\tag{1}
\]</span></p>
<p><span class="math display">\[
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix}
\right]=
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix}
\right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
-0.5W^{&#39;} &amp; 0.5H^{&#39;} &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
\cos\theta &amp; \sin\theta &amp; 0 \\
-\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp;0 \\
0.5W &amp; 0.5H &amp; 0 \\
\end{matrix}
\right]\tag{2}
\]</span></p>
<p>(1)式为前向映射（直接从原图映射到旋转后的图），（2）式为后向映射（用于旋转后映射到旋转前）</p>
<h4 id="为什么需要后向映射而不是前向映射">为什么需要后向映射而不是前向映射</h4>
<p>之所以有<strong>后向映射</strong>是因为在<strong>前向映射</strong>中获取的旋转后坐标是浮点数，但是像素只能是整数，所以就产生了像素缺失</p>
<p>而从后向前映射像素信息都是存在的，但又存在映射到原图中的浮点坐标改如何选择颜色信息的问题</p>
<p>这就有内插值的问题，提供的解决办法有三个，<strong>最邻近内插</strong>、<strong>双线性内插</strong>、<strong>双三次内插</strong>，最邻近就是直接对浮点坐标取整，取最接近它的像素值，双线性内插就是取与它相邻的4个点，求线性渲染值</p>
<p>其本质就是：假设在数轴上有两个点A，B（A&lt;B) AB中间有个点X，那么双线性内插就和知道X到点A的距离求X的值是一个道理，不过双线性需要对X和Y两个方向求值</p>
<p>双三次内插有点麻烦，这里。。我也不清楚，嘿嘿</p>
<p>可以参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nhb21pbjFoYW8vYXJ0aWNsZS9kZXRhaWxzLzgxMDkyMTM0">https://blog.csdn.net/caomin1hao/article/details/81092134<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="python-实践">Python 实践</h3>
<p>所需外部库：</p>
<ul>
<li>numpy（矩阵计算）</li>
<li>matplotlib (效果演示)</li>
<li>skimage （只读取使用其内置图片 换cv2读自己图片也可以）</li>
</ul>
<blockquote>
<p>使用按像素遍历，比较耗时</p>
</blockquote>
<p>后向映射中使用最邻近内插和双线性内插（双三次内插暂未处理）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> skimage.data</span><br><span class="line"><span class="keyword">import</span> skimage.io</span><br><span class="line"></span><br><span class="line">angle = <span class="number">30</span>*np.pi/<span class="number">180</span></span><br><span class="line"><span class="comment"># 读取库图片 Attention 转换 默认为int8 运算时可能会溢出</span></span><br><span class="line">img = skimage.data.chelsea().astype(<span class="built_in">int</span>)</span><br><span class="line"><span class="comment"># 设置新的图像大小</span></span><br><span class="line">h,w = img.shape[<span class="number">0</span>],img.shape[<span class="number">1</span>]</span><br><span class="line">newW = <span class="built_in">int</span>(w*<span class="built_in">abs</span>(np.cos(angle)) + h*<span class="built_in">abs</span>(np.sin(angle)))+<span class="number">1</span></span><br><span class="line">newH = <span class="built_in">int</span>(w*<span class="built_in">abs</span>(np.sin(angle)) + h*<span class="built_in">abs</span>(np.cos(angle)))+<span class="number">1</span></span><br><span class="line"><span class="comment"># Attention dtype</span></span><br><span class="line">newimg1 = np.zeros((newH,newW,<span class="number">3</span>),dtype = <span class="built_in">int</span>)</span><br><span class="line">newimg2 =  np.zeros((newH,newW,<span class="number">3</span>),dtype = <span class="built_in">int</span>)</span><br><span class="line">newimg3 =  np.zeros((newH,newW,<span class="number">3</span>),dtype = <span class="built_in">int</span>)</span><br><span class="line"><span class="comment"># 设置旋转矩阵 scr -&gt; dex</span></span><br><span class="line">trans1 = np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">-0.5</span>*w,<span class="number">0.5</span>*h,<span class="number">1</span>]])</span><br><span class="line">trans1 = trans1.dot(np.array([[np.cos(angle),-np.sin(angle),<span class="number">0</span>],[np.sin(angle),np.cos(angle),<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]))</span><br><span class="line">trans1 = trans1.dot(np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">0.5</span>*newW,<span class="number">0.5</span>*newH,<span class="number">1</span>]]))</span><br><span class="line"><span class="comment"># des -&gt; src</span></span><br><span class="line">trans2 = np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">-0.5</span>*newW,<span class="number">0.5</span>*newH,<span class="number">1</span>]])</span><br><span class="line">trans2 = trans2.dot(np.array([[np.cos(angle),np.sin(angle),<span class="number">0</span>],[-np.sin(angle),np.cos(angle),<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]))</span><br><span class="line">trans2 = trans2.dot(np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">0.5</span>*w,<span class="number">0.5</span>*h,<span class="number">1</span>]]))</span><br><span class="line"><span class="comment"># 开始旋转</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">        newPos = np.array([x,y,<span class="number">1</span>]).dot(trans1)</span><br><span class="line">        newimg1[<span class="built_in">int</span>(newPos[<span class="number">1</span>])][<span class="built_in">int</span>(newPos[<span class="number">0</span>])] = img[y][x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(newW):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(newH):</span><br><span class="line">        srcPos = np.array([x,y,<span class="number">1</span>]).dot(trans2)</span><br><span class="line">        <span class="keyword">if</span> srcPos[<span class="number">0</span>] &gt;= <span class="number">0</span> <span class="keyword">and</span> srcPos[<span class="number">0</span>] &lt; w <span class="keyword">and</span> srcPos[<span class="number">1</span>] &gt;= <span class="number">0</span> <span class="keyword">and</span> srcPos[<span class="number">1</span>] &lt; h:</span><br><span class="line">            <span class="comment"># 最邻近内插</span></span><br><span class="line">            newimg2[y][x] = img[<span class="built_in">int</span>(srcPos[<span class="number">1</span>])][<span class="built_in">int</span>(srcPos[<span class="number">0</span>])]</span><br><span class="line">            <span class="comment"># 双线性内插</span></span><br><span class="line">            bix,biy = <span class="built_in">int</span>(srcPos[<span class="number">0</span>]),<span class="built_in">int</span>(srcPos[<span class="number">1</span>]) <span class="comment"># 取左上角坐标</span></span><br><span class="line">            <span class="comment"># 避免最后一行溢出</span></span><br><span class="line">            <span class="keyword">if</span> bix &lt; w<span class="number">-1</span> <span class="keyword">and</span> biy &lt; h<span class="number">-1</span>:</span><br><span class="line">                <span class="comment"># 沿 X 方向线性内插</span></span><br><span class="line">                rgbX1 = img[biy][bix] + (img[biy][bix+<span class="number">1</span>] - img[biy][bix])*(srcPos[<span class="number">0</span>]-bix)</span><br><span class="line">                rgbX2 = img[biy+<span class="number">1</span>][bix] + (img[biy+<span class="number">1</span>][bix+<span class="number">1</span>] - img[biy+<span class="number">1</span>][bix])*(srcPos[<span class="number">0</span>]-bix)</span><br><span class="line">                <span class="comment"># 沿 Y  方向内插</span></span><br><span class="line">                rgb = rgbX1 + (rgbX2-rgbX1)*(srcPos[<span class="number">1</span>]-biy)</span><br><span class="line">                newimg3[y][x] = rgb</span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">sub = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">sub.set_title(<span class="string">&quot;Src Img&quot;</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">sub = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">sub.set_title(<span class="string">&quot;Src-&gt;Des&quot;</span>)</span><br><span class="line">plt.imshow(newimg1)</span><br><span class="line">sub = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">sub.set_title(<span class="string">&quot;Des-&gt;Src &amp; Nearest&quot;</span>)</span><br><span class="line">plt.imshow(newimg2)</span><br><span class="line">sub = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">sub.set_title(<span class="string">&quot;Des-&gt;Src &amp; Bilinear&quot;</span>)</span><br><span class="line">plt.imshow(newimg3)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="效果图展示">效果图展示</h3>
<p><img src="\assets\ArticleImg\2019\ImgRotation_2.png" /></p>
<p>可以看出来双线性比最邻近好的多了</p>
<p><img src="\assets\ArticleImg\2019\ImgRotation_3.png" /></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>DIP</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>《30天自制操作系统》 04 C语言和画面显示的练习</title>
    <url>/2020/01/26/2020-01-26-30OSMakeNote04/</url>
    <content><![CDATA[<h1 id="c语言和画面显示的练习">04 C语言和画面显示的练习</h1>
<p>原文中作者花了很大的力气讲解C语言的有关知识，这里就不多赘述了。。</p>
<a id="more"></a>
<h2 id="显示模式和显存">1. 显示模式和显存</h2>
<p>前一天的内容作者就将我们的操作系统的显示设置为<code>VGA 320*200 8 位调色板</code>模式，8位意味着我们可以使用256种颜色，但本质上VGA还是RGB成色模式，需要3个字节表示一个完整的颜色，我们只能设置色号，就是一个8位数到24位颜色的映射，设置的方法后面介绍。</p>
<p>并且将显示的分辨率设置为<code>320*200</code>，每一个像素都需要一个字节（8位）来表示颜色</p>
<p>此模式下显存的地址范围为<code>0xa0000 -0xaffff</code>，但是一个像素存储一个字节只需要<code>320*200</code>字节，但是显存范围是64K比存储像素的大一些，也不知是什么原因。。</p>
<h2 id="汇编实现内存写入">2. 汇编实现内存写入</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_write_mem8: ; void write_mem8(int addr, int data);</span><br><span class="line">    MOV ECX,[ESP+4] ; [ESP + 4]中存放的是地址， 将其读入ECX</span><br><span class="line">    MOV AL,[ESP+8] ; [ESP + 8]中存放的是数据， 将其读入AL</span><br><span class="line">    MOV [ECX],AL</span><br><span class="line">RET</span><br></pre></td></tr></table></figure>
<p>这里是32位模式所以我们使用的寄存器都是拓展寄存器，这里C语言编译器函数参数是从右到左压入栈，所以这里只是简单的把一个32位的数据写到指定的32位地址的内存中去</p>
<h2 id="色号设定">3. 色号设定</h2>
<p>前面提到过我们的显示模式是VGA 8位调色板模式，需要自己对不同的256个颜色编号指定不同的颜色。作者使用了16种颜色来绘制他的操作系统，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> table_rgb[<span class="number">16</span> * <span class="number">3</span>] = &#123;</span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,	<span class="comment">/*  0:黑 */</span></span><br><span class="line">	<span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,	<span class="comment">/*  1:梁红 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0x00</span>,	<span class="comment">/*  2:亮绿 */</span></span><br><span class="line">	<span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x00</span>,	<span class="comment">/*  3:亮黄 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xff</span>,	<span class="comment">/*  4:亮蓝 */</span></span><br><span class="line">	<span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0xff</span>,	<span class="comment">/*  5:亮紫 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,	<span class="comment">/*  6:浅亮蓝 */</span></span><br><span class="line">	<span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,	<span class="comment">/*  7:白 */</span></span><br><span class="line">	<span class="number">0xc6</span>, <span class="number">0xc6</span>, <span class="number">0xc6</span>,	<span class="comment">/*  8:亮灰 */</span></span><br><span class="line">	<span class="number">0x84</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,	<span class="comment">/*  9:暗红 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0x00</span>,	<span class="comment">/* 10:暗绿 */</span></span><br><span class="line">	<span class="number">0x84</span>, <span class="number">0x84</span>, <span class="number">0x00</span>,	<span class="comment">/* 11:暗黄 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x84</span>,	<span class="comment">/* 12:暗青 */</span></span><br><span class="line">	<span class="number">0x84</span>, <span class="number">0x00</span>, <span class="number">0x84</span>,	<span class="comment">/* 13:暗紫 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0x84</span>,	<span class="comment">/* 14:浅暗蓝 */</span></span><br><span class="line">	<span class="number">0x84</span>, <span class="number">0x84</span>, <span class="number">0x84</span>	<span class="comment">/* 15:暗灰 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同时作者提供了许多帮助写如端口的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_hlt</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 之前出现过的悬停CPU</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_cli</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 中断标识位清零</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_out8</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> data)</span></span>;	<span class="comment">// 输出8位数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_load_eflags</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">// 返回表示寄存器值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_store_eflags</span><span class="params">(<span class="keyword">int</span> eflags)</span></span>; <span class="comment">// 使用eflags重载表示寄存器</span></span><br></pre></td></tr></table></figure>
<p>其汇编实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; naskfunc</span><br><span class="line">; TAB&#x3D;4</span><br><span class="line"></span><br><span class="line">[FORMAT &quot;WCOFF&quot;]				; 制作目标文件的模式	</span><br><span class="line">[INSTRSET &quot;i486p&quot;]				; 使用到486为止的指令</span><br><span class="line">[BITS 32]						; 3制作32位模式用的机器语言</span><br><span class="line">[FILE &quot;naskfunc.nas&quot;]			; 文件名</span><br><span class="line"></span><br><span class="line">		GLOBAL	_io_hlt, _io_cli, _io_sti, _io_stihlt</span><br><span class="line">		GLOBAL	_io_in8,  _io_in16,  _io_in32</span><br><span class="line">		GLOBAL	_io_out8, _io_out16, _io_out32</span><br><span class="line">		GLOBAL	_io_load_eflags, _io_store_eflags</span><br><span class="line"></span><br><span class="line">[SECTION .text]</span><br><span class="line"></span><br><span class="line">_io_hlt:	; void io_hlt(void);</span><br><span class="line">		HLT</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_cli:	; void io_cli(void);</span><br><span class="line">		CLI</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_sti:	; void io_sti(void);</span><br><span class="line">		STI</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_stihlt:	; void io_stihlt(void);</span><br><span class="line">		STI</span><br><span class="line">		HLT</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_in8:	; int io_in8(int port);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		EAX,0</span><br><span class="line">		IN		AL,DX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_in16:	; int io_in16(int port);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		EAX,0</span><br><span class="line">		IN		AX,DX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_in32:	; int io_in32(int port);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		IN		EAX,DX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_out8:	; void io_out8(int port, int data);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		AL,[ESP+8]		; data</span><br><span class="line">		OUT		DX,AL</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_out16:	; void io_out16(int port, int data);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		EAX,[ESP+8]		; data</span><br><span class="line">		OUT		DX,AX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_out32:	; void io_out32(int port, int data);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		EAX,[ESP+8]		; data</span><br><span class="line">		OUT		DX,EAX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_load_eflags:	; int io_load_eflags(void);</span><br><span class="line">		PUSHFD		; PUSH EFLAGS </span><br><span class="line">		POP		EAX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_store_eflags:	; void io_store_eflags(int eflags);</span><br><span class="line">		MOV		EAX,[ESP+4]</span><br><span class="line">		PUSH	EAX</span><br><span class="line">		POPFD		; POP EFLAGS </span><br><span class="line">		RET</span><br></pre></td></tr></table></figure>
<p>代码中右<code>IN OUT</code>指令，这两个指令是CPU和其他输入输出设备交互的必备指令，<code>IN</code>从指定端口读入数据，<code>OUT</code>则是写数据，注意汇编中（C语言编译后）函数的返回值都是通过EAX寄存器</p>
<p>接下来要开始真正设置色号，VGA 调色板模式设置流程如下：</p>
<ol type="1">
<li>首先在一连串的访问中屏蔽中断（比如CLI） 。</li>
<li>将想要设定的调色板号码写入0x03c8， 紧接着， 按R， G， B的顺序写入 0x03c9。 如果还想继续设定下一个调色板， 则省略调色板号码， 再按照RGB的 顺序写入0x03c9就行了。</li>
<li>如果想要读出当前调色板的状态， 首先要将调色板的号码写入0x03c7， 再从 0x03c9读取3次。 读出的顺序就是R， G， B。 如果要继续读出下一个调色板， 同 样也是省略调色板号码的设定， 按RGB的顺序读出。</li>
<li>如果最初执行了CLI， 那么最后要执行STI</li>
</ol>
<p>对应的C语言代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_hlt</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_cli</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_out8</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_load_eflags</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_store_eflags</span><span class="params">(<span class="keyword">int</span> eflags)</span></span>;</span><br><span class="line"><span class="comment">/*就算写在同一个源文件里， 如果想在定义前使用， 还是必须事先声明一下。 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_palette</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_palette</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">unsigned</span> <span class="keyword">char</span> *rgb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HariMain</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i; <span class="comment">/* 声明变量。 变量i是32位整数型 */</span></span><br><span class="line">	<span class="keyword">char</span> *p; <span class="comment">/* 变量p是BYTE [...]用的地址 */</span></span><br><span class="line">	init_palette(); <span class="comment">/* 设定调色板 */</span></span><br><span class="line">    p = (<span class="keyword">char</span> *) <span class="number">0xa0000</span>; <span class="comment">/* 指定地址 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">0xffff</span>; i++) &#123;</span><br><span class="line">    	p[i] = i &amp; <span class="number">0x0f</span>;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		io_hlt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_palette</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> table_rgb[<span class="number">16</span> * <span class="number">3</span>] = &#123;</span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">/* 0:黑 */</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">/* 1:亮红 */</span></span><br><span class="line">    	<span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0x00</span>, <span class="comment">/* 2:亮绿 */</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x00</span>, <span class="comment">/* 3:亮黄 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="comment">/* 4:亮蓝 */</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="comment">/* 5:亮紫 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="comment">/* 6:浅亮蓝 */</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="comment">/* 7:白 */</span></span><br><span class="line">        <span class="number">0xc6</span>, <span class="number">0xc6</span>, <span class="number">0xc6</span>, <span class="comment">/* 8:亮灰 */</span></span><br><span class="line">        <span class="number">0x84</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">/* 9:暗红 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0x00</span>, <span class="comment">/* 10:暗绿 */</span></span><br><span class="line">        <span class="number">0x84</span>, <span class="number">0x84</span>, <span class="number">0x00</span>, <span class="comment">/* 11:暗黄 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="comment">/* 12:暗青 */</span></span><br><span class="line">        <span class="number">0x84</span>, <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="comment">/* 13:暗紫 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0x84</span>, <span class="comment">/* 14:浅暗蓝 */</span></span><br><span class="line">        <span class="number">0x84</span>, <span class="number">0x84</span>, <span class="number">0x84</span> <span class="comment">/* 15:暗灰 */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	set_palette(<span class="number">0</span>, <span class="number">15</span>, table_rgb);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/* C语言中的static char语句只能用于数据， 相当于汇编中的DB指令 */</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_palette</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">unsigned</span> <span class="keyword">char</span> *rgb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, eflags;</span><br><span class="line">    eflags = io_load_eflags(); <span class="comment">/* 记录中断许可标志的值*/</span></span><br><span class="line">    io_cli(); <span class="comment">/* 将中断许可标志置为0， 禁止中断 */</span></span><br><span class="line">    io_out8(<span class="number">0x03c8</span>, start);</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i++) &#123;</span><br><span class="line">    	io_out8(<span class="number">0x03c9</span>, rgb[<span class="number">0</span>] / <span class="number">4</span>);</span><br><span class="line">    	io_out8(<span class="number">0x03c9</span>, rgb[<span class="number">1</span>] / <span class="number">4</span>);</span><br><span class="line">    	io_out8(<span class="number">0x03c9</span>, rgb[<span class="number">2</span>] / <span class="number">4</span>);</span><br><span class="line">		rgb += <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    io_store_eflags(eflags); <span class="comment">/* 复原中断许可标志 */</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/assets/Note/30DaysOs/04_1.png" style="zoom:50%;" /></p>
<h2 id="绘制矩形">3. 绘制矩形</h2>
<p>画面坐标系都是左上坐标系（左上角为顶点），所以对于坐标<code>(x,y)</code>我们只需要通过<code>0xa0000 + x + y * 320</code>定为该坐标的对应地址，这么一来绘制矩形就简单多了</p>
<p>绘制矩形代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vram: 对应显存地址 0xa0000</span></span><br><span class="line"><span class="comment">xsize: 对应宽</span></span><br><span class="line"><span class="comment">c: 颜色编号</span></span><br><span class="line"><span class="comment">左上-右下坐标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boxfill8</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *vram, <span class="keyword">int</span> xsize, <span class="keyword">unsigned</span> <span class="keyword">char</span> c, <span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">for</span> (y = y0; y &lt;= y1; y++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (x = x0; x &lt;= x1; x++)</span><br><span class="line">			vram[y * xsize + x] = c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/assets/Note/30DaysOs/04_2.png" style="zoom:50%;" /></p>
<p>作者最后还绘制了一个简陋的界面都是通过绘制矩形实现这里就不多说了</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>30天自制操作系统</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1003 Emergency（最短路）</title>
    <url>/2020/02/24/2020-02-24-PAT-Advanced-1003/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MjM4MzUxMDkzNzY=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>
<p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each test case, the first line contains 4 positive integers: <em>N</em> (≤500) - the number of cities (and the cities are numbered from 0 to <em>N</em>−1), <em>M</em> - the number of roads, <em>C</em>1 and <em>C</em>2 - the cities that you are currently in and that you must save, respectively. The next line contains <em>N</em> integers, where the <em>i</em>-th integer is the number of rescue teams in the <em>i</em>-th city. Then <em>M</em> lines follow, each describes a road with three integers <em>c</em>1, <em>c</em>2 and <em>L</em>, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from <em>C</em>1 to <em>C</em>2.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line two numbers: the number of different shortest paths between <em>C</em>1 and <em>C</em>2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6 0 2</span><br><span class="line">1 2 1 5 3</span><br><span class="line">0 1 1</span><br><span class="line">0 2 2</span><br><span class="line">0 3 1</span><br><span class="line">1 2 1</span><br><span class="line">2 4 1</span><br><span class="line">3 4 1 </span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h2 id="基本思路">基本思路</h2>
<p>开始以为是简单的最短路模板题，结果发现还是有点意思的，在简单的最短路的基础上更进一步，基础图论起手就是 Dijkstra。<a href="/dsaa/2018/12/07/ShortestPath/">最短路基础算法 原地TP</a></p>
<p>和基础最短路不同的是，这里我们需要计算的是 <strong>最短路的条数</strong>，以及这些最短路中 <strong>节点权重和最大的值</strong>。可以作为其他类似题目的解题思路。</p>
<p>在基础的 Dijkstra 算法中我们每次更新对应点最短路当 <strong>到此点距离</strong> 小于 <strong>到其相邻点距离</strong> 与 <strong>对应边权和</strong>，这样就保证每次都是“最短”了，显然最短路不只一条，那么何时可以判断有重复最短路。</p>
<p><img src="/assets/ArticleImg/2020/pat1003_01.jpg" style="zoom:50%;" /></p>
<p>简单来说 <span class="math inline">\(d[i]\)</span> 表示起始点到 i 点的最短路大小，到 C 点的最短路更新在 <span class="math inline">\(d[C] &lt; d[B] + cost\)</span> 的时候。我们使用 <span class="math inline">\(num[i]\)</span> 表示到 i 点最短路条数，此时到 C 的最短路只能是从点 B 过来，所以此时 C 的最短路数量就是 B 的最短路数量。 点 C 最短路条数增长仅当 <span class="math inline">\(d[B] + cost == d[C]\)</span> 时，这时候说明从 B 到 C 和 C 原来的最短路是一样的，所以我们需要把到 B 的最短路数量加给我们的 C，得到新的最短路条数</p>
<p>代码表示如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新 C 点的最短路</span></span><br><span class="line"><span class="comment">// C 为 B 的所有邻点</span></span><br><span class="line"><span class="keyword">for</span>(C in B_Neighbors) &#123;</span><br><span class="line">    <span class="keyword">if</span>(d[B] + cost &lt; d[C]) &#123;</span><br><span class="line">        <span class="comment">// 此时更新最短路 通过 B 到 C 所以 C 的最短路数量等于到 B 的最短路数量</span></span><br><span class="line">        d[C] = d[B] + cost;</span><br><span class="line">        num[C] = num[B];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d[B] + cost == d[C]) &#123;</span><br><span class="line">        <span class="comment">// 从B方向来的路也是最短路 所以加上</span></span><br><span class="line">        num[C] += num[B];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于最短路中的最大节点权值和则比较简单，当存在更短的路径时，更新对应点的权值和，当存在相同长度最短路时，比较两条路的节点权值和，取较大的，最后的逻辑代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新 C 点的最短路</span></span><br><span class="line"><span class="comment">// C 为 B 的所有邻点</span></span><br><span class="line"><span class="comment">// sum[i] 表示i点的最短路径节点权值和最大值</span></span><br><span class="line"><span class="keyword">for</span>(C in B_Neighbors) &#123;</span><br><span class="line">    <span class="keyword">if</span>(d[B] + cost &lt; d[C]) &#123;</span><br><span class="line">        <span class="comment">// 此时更新最短路 通过B到C 所以C的最短路数量等于到B的最短路数量</span></span><br><span class="line">        d[C] = d[B] + cost;</span><br><span class="line">        num[C] = num[B];</span><br><span class="line">        sum[C] = sum[B] + weight[C]; <span class="comment">// weight[C] C节点的权值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d[B]+cost == d[C]) &#123;</span><br><span class="line">        <span class="comment">// 从B方向来的路也是最短路 所以加上</span></span><br><span class="line">        num[C] += num[B];</span><br><span class="line">        <span class="keyword">if</span>(sum[C] &lt; sum[B] + weight[C]) &#123;</span><br><span class="line">            sum[C] = sum[B] + weight[C];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>
<h2 id="ac-代码">AC 代码</h2>
<p>注意其中对应数组 <strong>变量的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">501</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;    <span class="comment">// P.first 为 起始点到 P.second 的最短路</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, cost;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[maxn];   <span class="comment">// 存储图的邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> d[maxn];    <span class="comment">// 对应点的最短路</span></span><br><span class="line"><span class="keyword">int</span> team_num[maxn]; <span class="comment">// 每个城市对应点的救援队数量</span></span><br><span class="line"><span class="keyword">int</span> road_sum[maxn]; <span class="comment">// 最短路数量</span></span><br><span class="line"><span class="keyword">int</span> team_sum[maxn]; <span class="comment">// 节点最大权值和</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n, m, s, t; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    fill(d, d+maxn, INF); d[s] = <span class="number">0</span>;</span><br><span class="line">    fill(road_sum, road_sum+maxn, <span class="number">0</span>);   <span class="comment">// 开始全部为 0</span></span><br><span class="line">    road_sum[s] = <span class="number">1</span>;    <span class="comment">// 起点到自己有1条路</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, team_num+i);</span><br><span class="line">        team_sum[i] = team_num[i];  <span class="comment">// 都可以自己到自己，所以和team_num一样</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读入图数据</span></span><br><span class="line">    <span class="keyword">int</span> t_s, <span class="keyword">t_t</span>, t_cost;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;t_s, &amp;<span class="keyword">t_t</span>, &amp;t_cost);</span><br><span class="line">        G[t_s].push_back(edge&#123;<span class="keyword">t_t</span>, t_cost&#125;);</span><br><span class="line">        G[<span class="keyword">t_t</span>].push_back(edge&#123;t_s, t_cost&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que;</span><br><span class="line">    que.push(<span class="built_in">make_pair</span>(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        P t = que.top(); que.pop();</span><br><span class="line">        <span class="keyword">if</span>(d[t.second] &lt; t.first) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[t.second].size();i++) &#123;</span><br><span class="line">            edge e = G[t.second][i];</span><br><span class="line">            <span class="keyword">if</span>(d[e.to] &gt; d[t.second] + e.cost) &#123;</span><br><span class="line">                team_sum[e.to] = team_sum[t.second] + team_num[e.to];</span><br><span class="line">                road_sum[e.to] = road_sum[t.second];</span><br><span class="line">                d[e.to] = d[t.second] + e.cost;</span><br><span class="line">                que.push(<span class="built_in">make_pair</span>(d[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d[e.to] == d[t.second] + e.cost) &#123;</span><br><span class="line">                road_sum[e.to] += road_sum[t.second];</span><br><span class="line">                <span class="keyword">if</span>(team_sum[e.to] &lt; team_sum[t.second] + team_num[e.to]) &#123;</span><br><span class="line">                    team_sum[e.to] = team_sum[t.second] + team_num[e.to];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, road_sum[t], team_sum[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode84 柱状图中最大的矩形</title>
    <url>/2020/03/01/2020-02-29-Leetcode84/</url>
    <content><![CDATA[<h2 id="题目描述"><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGFyZ2VzdC1yZWN0YW5nbGUtaW4taGlzdG9ncmFtLw==">题目描述<i class="fa fa-external-link-alt"></i></span></h2>
<blockquote>
<p>题目图片会403。。</p>
</blockquote>
<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解决方案">解决方案</h2>
<p>官方已经给出很多中方法了：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGFyZ2VzdC1yZWN0YW5nbGUtaW4taGlzdG9ncmFtL3NvbHV0aW9uL3podS16aHVhbmctdHUtemhvbmctenVpLWRhLWRlLWp1LXhpbmctYnktbGVldGNvZGUv">leetcode官方解答<i class="fa fa-external-link-alt"></i></span></p>
<p>但是有些感觉没说清楚的地方，主要是两种思路，<strong>分治法</strong>和<strong>栈</strong></p>
<h3 id="分治法">分治法</h3>
<p>对一个区间我们可以认为最大矩形只有三种情况，假设最短下标为<em>i</em></p>
<ul>
<li>下标<em>i</em>为最大矩形的高，此时宽就是整个区间</li>
<li>最大矩形出现在下标<em>i</em>的左边</li>
<li>最大矩形出现在下标<em>i</em>的右边</li>
</ul>
<p>这样子就可以将大问题分而治之，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> divide(heights, <span class="number">0</span>, heights.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_index = l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(heights[i] &lt; heights[min_index]) &#123;</span><br><span class="line">                min_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> area = heights[min_index]*(r-l+<span class="number">1</span>);</span><br><span class="line">        area = max(area, divide(heights, l, min_index<span class="number">-1</span>));</span><br><span class="line">        area = max(area, divide(heights, min_index+<span class="number">1</span>, r));</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的复杂度是<span class="math inline">\(n\log n\)</span>，但是在有序数列的情况下，会达到 <span class="math inline">\(n^2\)</span>，有时候leetcode会超时（多提交几次没准就过哈哈）</p>
<h3 id="栈">栈</h3>
<p>这个方法就十分巧妙了，看了好久的官方代码才明白</p>
<p>其中的主要思想是：<strong>如何求一根高为<em>h</em>的柱子的最大矩形</strong>。这个思路就很清楚了，分别从此柱子下标开始向两边寻找第一个高度小于它的（在往两边拓展则会高度变小），就可以了</p>
<p>这个栈的思路也是如此：<strong>维护一个非递减栈</strong>，通过一遍遍历，即可完成所有以此柱子为高的最大矩形面积的确定</p>
<p>当我们从左往右将柱子<strong>下标</strong>加入栈，直到遇到一个<strong>破坏非递减关系</strong>的柱子（即<span class="math inline">\(heights[i]&lt;heights[i-1]\)</span>），记此时的下标为<em>i</em>。我们假设此时栈中满足高度<strong>小于</strong><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> <em>i</em>柱子的最大下标为<em>j</em>，那么在区间 <span class="math inline">\((i,j)\)</span>之间的柱子的最大面积都可以确定</p>
<p>令<span class="math inline">\(z \in (i,j)\)</span>，下标为<em>z</em>的柱子它们的右边界就是<em>i</em>，它们的左边界就是在栈中位于它们之下的那个下标，假设为<em>k</em>，有了这些<em>z</em>的最大面积也可以得出来了</p>
<p>利用栈的后进先出特性，此时我们可以一个个的从栈中弹出下标，直到遇到上面的“<em>j</em>”，可以得出计算面积的表达式： <span class="math display">\[
(i-stack[top-1]\times heights[stack[top]])
\]</span> 在多次入栈出栈后，栈内的坐标会变得的不再连续，而且上面的规则隐藏了一些深的特性</p>
<p>假设 <em>stack[top-1]</em> 的值为 <em>k</em>，每个区间的特别意义如下：</p>
<ul>
<li>从左到右排列：<span class="math inline">\(j,k,z,i\)</span> 注意此时<em>i</em>并未入栈</li>
<li><span class="math inline">\((j,k)\)</span>：此区间的高度均大于或等于<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a><span class="math inline">\(heights[i]\)</span></li>
<li><span class="math inline">\((k,z)\)</span>：此区间高度均大于或等于 <span class="math inline">\(heights[z]\)</span>（当<em>k,z</em>不连续时，此时比<em>z</em>小的都在之前被弹出了栈）</li>
<li><span class="math inline">\((z,i)\)</span>：此区间最大矩形均已确定，按以上表达式</li>
</ul>
<p>在最后如果栈不为空，则说明栈内的下标对应高度<strong>呈非递减趋势</strong>。此时依次出栈计算面积，计算表达式为： <span class="math display">\[
heights[stack[top]]*(heights.size - stack[top-1] - 1) \\
因为stack[top-1]之后高度均大于等于stack[top]
\]</span></p>
<h3 id="代码如下">代码如下</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st; st.push(<span class="number">-1</span>); <span class="comment">// 方便处理栈底的处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; heights.size();i++) &#123;</span><br><span class="line">            <span class="comment">// 此时找到了一个非递增的</span></span><br><span class="line">            <span class="comment">// 注意大于等于都可以</span></span><br><span class="line">            <span class="keyword">while</span>(st.top() != <span class="number">-1</span> &amp;&amp; heights[st.top()] &gt;= heights[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> height_index = st.top(); st.pop();</span><br><span class="line">                res = max(res, heights[height_index]*(i - <span class="number">1</span> - st.top()));</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(st.top() != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> height_index = st.top(); st.pop();</span><br><span class="line">            res = max(res, (<span class="keyword">int</span>)(heights[height_index]*(heights.size() - st.top() - <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGFyZ2VzdC1yZWN0YW5nbGUtaW4taGlzdG9ncmFtL3NvbHV0aW9uL3poYW8tbGlhbmctYmlhbi1kaS15aS1nZS14aWFvLXl1LXRhLWRlLXpoaS1ieS1wb3djLw==">社区题解<i class="fa fa-external-link-alt"></i></span>有个更巧妙的，在heights数组前和后加入高度0，可以避免最后以此的清空栈操作和对栈底弹出时的特别处理（此处使用加入-1作为特别处理）</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            left_i = i</span><br><span class="line">            right_i = i</span><br><span class="line">            <span class="keyword">while</span> left_i &gt;= <span class="number">0</span> <span class="keyword">and</span> heights[left_i] &gt;= heights[i]:</span><br><span class="line">                left_i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right_i &lt; n <span class="keyword">and</span> heights[right_i] &gt;= heights[i]:</span><br><span class="line">                right_i += <span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, (right_i - left_i - <span class="number">1</span>) * heights[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr />
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>其实在此处小于等于也是可以的<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>根据注解1处的不同而不同（1处若为小于等于，此处则仅大于）<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1010 Radix（二分法）</title>
    <url>/2020/03/19/2020-03-19-PAT-Advanced-1010/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MDcyMjU2NjU1MzY=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>
<p>Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is <code>yes</code>, if 6 is a decimal number and 110 is a binary number.</p>
<p>Now for any pair of positive integers <em>N</em>1 and <em>N</em>2, your task is to find the radix of one number while that of the other is given.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case occupies a line which contains 4 positive integers:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N1 N2 tag radix</span><br></pre></td></tr></table></figure>
<p>Here <code>N1</code> and <code>N2</code> each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, <code>a</code>-<code>z</code> } where 0-9 represent the decimal numbers 0-9, and <code>a</code>-<code>z</code> represent the decimal numbers 10-35. The last number <code>radix</code> is the radix of <code>N1</code> if <code>tag</code> is 1, or of <code>N2</code> if <code>tag</code> is 2.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the radix of the other number so that the equation <code>N1</code> = <code>N2</code> is true. If the equation is impossible, print <code>Impossible</code>. If the solution is not unique, output the smallest possible radix.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 110 1 10</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-1">Sample Output 1:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="sample-input-2">Sample Input 2:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 ab 1 2</span><br></pre></td></tr></table></figure>
<h3 id="sample-output-2">Sample Output 2:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure>
<h2 id="基本思路">基本思路</h2>
<p>PAT题目都很迷，很多地方都不说清楚输入范围。。。</p>
<p>这道题输入数据不会超过<code>long long</code>，所以可以放心的使用基本思路计算不同进制下的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">getRes</span><span class="params">(<span class="built_in">string</span> &amp;tar, <span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = tar.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        res = res*radix + getNum(tar[i]);</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果每次都从进制2开始递增进制，直到一种不可能的情况出现，但这种方法对大小差距极大的两个数特别耗时，对于这种<strong>在一个序列中寻找一个正确解</strong>的过程，显然是用二分法解决。</p>
<p>但是二分法需要一个范围，那么这道题的进制范围是在哪一个范围。首先对于R进制的串，对于数串内的数必须小于R，所以获取此串的最小进制（下界）就显而易见了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">char</span> tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tar &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; tar &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinRadix</span><span class="params">(<span class="built_in">string</span> &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 也可以使用C++的max_element函数</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tar[i] &gt; c) &#123;</span><br><span class="line">            c = tar[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  max(getNum(c) + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上界即为<code>max(minRadix,  num)</code> num为已知进制的数的值，因为题目中只涉及到0-35的值，所以num作为上届已经足够，因为个位是不可能达到num值的最高就是35，那么在2位数字的情况下最小也是10，此时10在num进制下就是num，所以num进制的最小值就是num，在往上就会大于num就没有必要了</p>
<p>所有在上下界进行二分法查找即可</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">char</span> tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tar &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; tar &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tar - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinRadix</span><span class="params">(<span class="built_in">string</span> &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tar[i] &gt; c) &#123;</span><br><span class="line">            c = tar[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  max(getNum(c) + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getRes</span><span class="params">(<span class="built_in">string</span> &amp;tar, <span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = tar.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tar.length();i++) &#123;</span><br><span class="line">        res = res*radix + getNum(tar[i]);</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">string</span> A, B;</span><br><span class="line">    <span class="keyword">int</span> tag, radix;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; tag &gt;&gt; radix;</span><br><span class="line">    <span class="keyword">if</span>(tag == <span class="number">2</span>) &#123;</span><br><span class="line">        swap(A, B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// B 是 要计算的</span></span><br><span class="line">    ll tar = getRes(A, radix);</span><br><span class="line">    <span class="comment">//  二分</span></span><br><span class="line">    ll left = getMinRadix(B);</span><br><span class="line">    ll right = max(left, tar);</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        ll mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ll temp = getRes(B, mid);</span><br><span class="line">        <span class="keyword">if</span>(temp == tar) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, mid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp &lt; <span class="number">0</span> || temp &gt; tar) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Matplotlib 图像直接导出为 ndarray</title>
    <url>/2020/03/12/2020-03-12-Matplotlib-DirectlyOutput-Img/</url>
    <content><![CDATA[<h2 id="导出为ndarray格式图片">导出为ndarray格式图片</h2>
<p><em>matplotlib</em> 绘制的图线有自己的显示窗口，有时候希望在其他的<em>UI</em>设计中使用其绘制的图，比如<em>PyQt</em>，官方有一个支持QT的显示窗口类，但配置很麻烦，在这里记录一种简便的导出方式</p>
<p>主要思路为使用<em>matplotlib</em>的<code>print_png</code>函数将其图片数据导出到二进制流中，然后<em>numpy</em>从此二进制流中取出数据即可</p>
<a id="more"></a>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># matplotlib 绘制区</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">y = [<span class="number">1.2</span>, <span class="number">2.5</span>, <span class="number">4.5</span>, <span class="number">7.3</span>]</span><br><span class="line"></span><br><span class="line">fig = plt.figure(<span class="string">&quot;Image&quot;</span>, frameon=<span class="literal">False</span>)</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">canvas = fig.canvas</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取二进制流</span></span><br><span class="line">buffer = io.BytesIO()</span><br><span class="line">canvas.print_png(buffer)</span><br><span class="line">data = buffer.getvalue()</span><br><span class="line">buffer.write(data)</span><br><span class="line">buffer.seek(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy 获取数据</span></span><br><span class="line">file_bytes = np.asarray(<span class="built_in">bytearray</span>(buffer.read()), dtype=np.uint8)</span><br><span class="line"><span class="comment"># opencv 读取</span></span><br><span class="line">img = cv2.imdecode(file_bytes, cv2.IMREAD_COLOR)</span><br><span class="line"></span><br><span class="line">buffer.close()</span><br></pre></td></tr></table></figure>
<h2 id="设置matplotlib-borders便于鼠标信息处理坐标">设置matplotlib borders便于鼠标信息处理（坐标）</h2>
<p>有时候仅导出为图片还不够，还需要实现用户的交互操作，在原生<em>matplotlib</em>中可以绑定事件以实现用户交互，但导出为图片时，就不得行了，但只需要获取坐标和图片宽高之间的关系，就可以简单的坐标转换一下就可以实现了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置显示的图像（不包括坐标轴，仅绘图区）显示在figure的位置</span></span><br><span class="line">left, bottom, right, top = <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.9</span>, <span class="number">0</span>,<span class="number">9</span></span><br><span class="line">plt.subplots_adjust(left=left, bottom=bottom, right=right, top=top)</span><br></pre></td></tr></table></figure>
<h3 id="坐标转换">坐标转换</h3>
<p>因为知道绘图区在整个图的相对位置，所以可以很好的处理</p>
<p>下面例子为<em>PyQt5</em>使用<em>widget</em>显示图片，<em>widget</em>到曲线坐标系的转换（曲线坐标系x,y均在[0,1]之间）</p>
<p><strong>即左上角为原点的屏幕坐标系到[0,1]坐标范围的图表坐标系的转换</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w, h = width(), height() <span class="comment"># 即为显示图片的容器大小</span></span><br><span class="line">plot_w, plot_h = (right - left)*w, (top - bottom)*h <span class="comment"># 绘图区大小</span></span><br><span class="line"><span class="comment"># 图标坐标到全图的像素坐标转换</span></span><br><span class="line">coord2bk = <span class="keyword">lambda</span> coord: [coord[<span class="number">0</span>]*plot_w + w*left, h*(<span class="number">1</span>-bottom) - coord[<span class="number">1</span>]*plot_h]</span><br><span class="line"><span class="comment"># 全图坐标到像素坐标的转换</span></span><br><span class="line">bk2coord = <span class="keyword">lambda</span> coord: [(coord[<span class="number">0</span>] - w*left) / plot_w ,<span class="number">1</span> - (coord[<span class="number">1</span>] - h*(<span class="number">1</span>-top)) / plot_h]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Matplotlib</tag>
        <tag>PyQT</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1012 The Best Rank（排序）</title>
    <url>/2020/03/21/2020-03-21-PAT-Advanced-1012/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MDI2NTgwNjg0ODA=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>
<p>To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: <code>C</code> - C Programming Language, <code>M</code> - Mathematics (Calculus or Linear Algrbra), and <code>E</code> - English. At the mean time, we encourage students by emphasizing on their best ranks -- that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.</p>
<p>For example, The grades of <code>C</code>, <code>M</code>, <code>E</code> and <code>A</code> - Average of 4 students are given as the following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StudentID  C  M  E  A</span><br><span class="line">310101     98 85 88 90</span><br><span class="line">310102     70 95 88 84</span><br><span class="line">310103     82 87 94 88</span><br><span class="line">310104     91 91 91 91</span><br></pre></td></tr></table></figure>
<p>Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case starts with a line containing 2 numbers <em>N</em> and <em>M</em> (≤2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then <em>N</em> lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of <code>C</code>, <code>M</code> and <code>E</code>. Then there are <em>M</em> lines, each containing a student ID.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each of the <em>M</em> students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.</p>
<p>The priorities of the ranking methods are ordered as <code>A</code> &gt; <code>C</code> &gt; <code>M</code> &gt; <code>E</code>. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.</p>
<p>If a student is not on the grading list, simply output <code>N/A</code>.</p>
<h3 id="sample-input">Sample Input:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">310101 98 85 88</span><br><span class="line">310102 70 95 88</span><br><span class="line">310103 82 87 94</span><br><span class="line">310104 91 91 91</span><br><span class="line">310105 85 90 90</span><br><span class="line">310101</span><br><span class="line">310102</span><br><span class="line">310103</span><br><span class="line">310104</span><br><span class="line">310105</span><br><span class="line">999999</span><br></pre></td></tr></table></figure>
<h3 id="sample-output">Sample Output:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 C</span><br><span class="line">1 M</span><br><span class="line">1 E</span><br><span class="line">1 A</span><br><span class="line">3 A</span><br><span class="line">N&#x2F;A </span><br></pre></td></tr></table></figure>
<h2 id="基本思路">基本思路</h2>
<p>题目本身没什么，就是PAT题目条件给的<strong>太隐晦</strong>了。。。很多条件都不明说</p>
<p>对于平均分是否四舍五入，并列的处理都不明说，全部藏在例子里面</p>
<p>是需要<strong>四舍五入</strong>的对于<strong>并列是 1 1 3 4 5</strong>这种（没有第二名了就）</p>
<p>所以只要把握这两点，这题目就很水了</p>
<p>首先按<em>ACME</em>的顺序对学生成绩排序，然后更新每个学生最好成绩就可以了，按<em>ACME</em>的顺序也是根据优先级安排的，在相同名次下，后排序更新的不做处理</p>
<p>这题目还可以使用<strong>空间换时间的思路</strong>，稍微加快一点处理，比如判断是否存在学生，因为学生的学号是个整数，所以直接开辟那么大的数组记录即可，对每个学生的分数排名都可以这么处理</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2001</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> score[<span class="number">4</span>]; <span class="comment">// A C M E 对应的分数</span></span><br><span class="line">&#125;stu[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn_ = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> is_exist[maxn_];   <span class="comment">// 判断是否存在</span></span><br><span class="line"><span class="keyword">int</span> best_rank[maxn_];   <span class="comment">// 记录对应的最好成绩</span></span><br><span class="line"><span class="keyword">int</span> best_rank_type[maxn_];  <span class="comment">// 记录最好成绩对应的学科</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(is_exist, <span class="number">0</span>, <span class="keyword">sizeof</span>(is_exist));</span><br><span class="line">    <span class="built_in">memset</span>(best_rank, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(best_rank));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;stu[i].id, &amp;stu[i].score[<span class="number">1</span>], &amp;stu[i].score[<span class="number">2</span>], &amp;stu[i].score[<span class="number">3</span>]);</span><br><span class="line">        stu[i].score[<span class="number">0</span>] = (stu[i].score[<span class="number">1</span>]+stu[i].score[<span class="number">2</span>]+stu[i].score[<span class="number">3</span>])/<span class="number">3</span> + <span class="number">0.5</span>; <span class="comment">// 四舍五入</span></span><br><span class="line">        is_exist[stu[i].id] = <span class="literal">true</span>; <span class="comment">// 标记为存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 四个分数排序 按 A C M E 的顺序</span></span><br><span class="line">    <span class="comment">// 相同的情况后不能覆盖前（优先级）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">        sort(stu, stu+n, [i](Stu &amp;a, Stu &amp;b)&#123; <span class="keyword">return</span> a.score[i] &gt; b.score[i]; &#125;);</span><br><span class="line">        <span class="keyword">if</span>(best_rank[stu[<span class="number">0</span>].id] != <span class="number">0</span>) &#123;</span><br><span class="line">            best_rank[stu[<span class="number">0</span>].id] = <span class="number">0</span>;</span><br><span class="line">            best_rank_type[stu[<span class="number">0</span>].id] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last_rank = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意处理并列。。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(stu[j<span class="number">-1</span>].score[i] != stu[j].score[i]) &#123;</span><br><span class="line">                last_rank = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(best_rank[stu[j].id] &gt; last_rank) &#123;</span><br><span class="line">                best_rank[stu[j].id] = last_rank;</span><br><span class="line">                best_rank_type[stu[j].id] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> type[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> id; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;id);</span><br><span class="line">        <span class="keyword">if</span>(is_exist[id]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %c\n&quot;</span>, best_rank[id] + <span class="number">1</span>, type[best_rank_type[id]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;N/A\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1014 Waiting in Line（优先队列）</title>
    <url>/2020/03/21/2020-03-24-PAT-Advanced-1014/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0OTgyMDc5MTE5MzY=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>之前一直错还是题目看错，英文题目还是要注意啊。</p>
<p>17：00后的不予服务，只要在17：00之前接受服务的都可以，不用管截止时间。</p>
<a id="more"></a>
<h2 id="基本思路">基本思路</h2>
<p>题目本身不难，理清楚过程即可。（他题目有些也迷）</p>
<p>给出了N个窗口以及最大等待区M，K个顾客。相当于本来就有K个人在排队，然后每个人依次选窗口当等待区有空位的适合。等待区总共可以容纳NM个人，所以最前面的NM个人依次排满等待区即可（按照题目定的规则），当等待区满的时候，只要有一个人结束服务，那在等待区外排队的人就马上可以塞进去一个。</p>
<p>所以我们需要知道的就是最早结束服务的人，这就可以用到优先队列了，维护结束服务的时间。时间越早优先级越高。每当他进入等待区，就push到优先队列中。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> win_index;</span><br><span class="line">    <span class="keyword">int</span> end_time;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Customer&amp; other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// 同时离开 选择编号小的</span></span><br><span class="line">        <span class="keyword">return</span> end_time != other.end_time ? end_time &gt; other.end_time : win_index &gt; other.win_index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;customers[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cost_time[maxn];    <span class="comment">// 用户的花费时间</span></span><br><span class="line"><span class="keyword">int</span> end_time[maxn];     <span class="comment">// 每个用户的结束时间</span></span><br><span class="line"><span class="keyword">int</span> win_cur_time[<span class="number">21</span>];   <span class="comment">// 当前窗口等待区清空的最晚时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(win_cur_time, <span class="number">0</span>, <span class="keyword">sizeof</span>(win_cur_time));</span><br><span class="line">    <span class="built_in">memset</span>(end_time, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(end_time));</span><br><span class="line">    <span class="keyword">int</span> n, m, k, q; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, cost_time+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Customer&gt; que;</span><br><span class="line">    <span class="comment">// 前NM个直接加入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k &amp;&amp; i &lt; n*m;i++) &#123;</span><br><span class="line">        win_cur_time[i%n] += cost_time[i];</span><br><span class="line">        end_time[i] = win_cur_time[i%n];</span><br><span class="line">        que.push(&#123;i%n, end_time[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n*m;i &lt; k;i++) &#123;</span><br><span class="line">        Customer temp = que.top(); que.pop();   <span class="comment">// 获取最早离开的</span></span><br><span class="line">        win_cur_time[temp.win_index] += cost_time[i];</span><br><span class="line">        end_time[i] = win_cur_time[temp.win_index];</span><br><span class="line">        temp.end_time = end_time[i];</span><br><span class="line">        que.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tar;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tar);</span><br><span class="line">        <span class="keyword">int</span> mins = end_time[tar<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">// 开始服务的时间不能晚于17:00</span></span><br><span class="line">        <span class="keyword">if</span>(mins - cost_time[tar<span class="number">-1</span>] &gt;= <span class="number">540</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Sorry\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d\n&quot;</span>, <span class="number">8</span>+mins/<span class="number">60</span>, mins%<span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>埃氏筛 &amp; 欧拉筛</title>
    <url>/2020/03/24/2020-03-24-prime-sieve/</url>
    <content><![CDATA[<blockquote>
<p>素数的定义：指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数。大于1的自然数若不是素数，则称之为合数。</p>
</blockquote>
<a id="more"></a>
<h2 id="试除法">试除法</h2>
<p>直接使用定义解决的方案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="built_in">sqrt</span>(n);i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里从2遍历到<span class="math inline">\(\sqrt n\)</span> 因为之后的就没有必要了，一个和数拆分成两个因子必定是在<span class="math inline">\(\sqrt n\)</span>的两侧，是对称的，所以只需要遍历一边就可以了。</p>
<h2 id="埃氏筛">埃氏筛</h2>
<p>上面的算法是判断一个数是否是素数，但是对获取某个范围的素数开销非常大。埃氏筛（素数筛）就是求某个范围素数的算法。</p>
<p>原理很简单，合数必定可以拆分为一系列素数的积，即<strong>某个素数的任意倍数都是合数</strong>。</p>
<p>代码也很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// maxn 为范围的上届</span></span><br><span class="line"><span class="keyword">bool</span> is_prime[maxn] = &#123;<span class="literal">true</span>&#125;; <span class="comment">// 初始化为全部 true</span></span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> prime_numbers[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">        prime_numbers[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i*i;j &lt; maxn;j += i) &#123;</span><br><span class="line">            is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度为：<span class="math inline">\(n\log \log n\)</span></p>
<h2 id="欧拉筛">欧拉筛</h2>
<p>埃氏筛很明显的一个缺点就是一个合数会被重复筛掉（被每一个素数因子筛一次），增加复杂度。欧拉筛就是在其上的改进，使每一个合数只被它的最小因子筛掉。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> is_prime[maxn] = &#123;<span class="literal">true</span>&#125;; <span class="comment">// 初始化为全部 true</span></span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> prime_numbers[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">        prime_numbers[cnt++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环中&lt;maxn没有也没关系</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;i*prime_numbers[j] &lt; maxn;j++) &#123;</span><br><span class="line">        is_prime[i*prime_numbers[j]] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(i % prime_numbers[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欧拉筛复杂度为n（将空循环不视作开销），每个合数仅被筛一次。</p>
<p>核心就在于<code>i % prime_numbers[j] == 0</code>，当这个条件成立的时候跳出循环，不继续往下筛，下面的都是已经或者未来要被筛掉的。</p>
<p>条件成立时意味着 <span class="math inline">\(i = prime\_numbers[j] \times K\)</span>，而继续循环下去可以得到<span class="math inline">\(i*prime\_numbers[j+1]\)</span>也就是,<span class="math inline">\(prime\_numbers[j]\times prime\_numbers[j+1] \times K = prime\_numbers[j] \times Q\)</span>，也就是说它会被<span class="math inline">\(prime\_numbers[j]\)</span>乘以另外一个数给筛掉，之后的循环也就没必要进行了。也保证了，每个合数都只被它的最小因子筛掉。</p>
<p>令<span class="math inline">\(N = K \times Q \times ...\)</span> K Q为两个素数且<span class="math inline">\(Q \gt K\)</span>，假设N可以被Q筛掉，也就是$N = Q M， M= K... $这里的M就是上面循环中的i，它是不可能使用QM筛掉的，因为<code>M%K == 0</code>，就跳出循环之外了。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1016 Phone Bills（排序）</title>
    <url>/2020/03/27/2020-03-27-PAT-Advanced-1016/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0OTM2NDg3MDM0ODg=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>提交了整整一个下午。。。</p>
<p>再次吐槽PAT的题目描述，很多时候都是迷迷糊糊的，很多地方没有说清楚。</p>
<p>这道题一个巨大的坑：<strong>没有符合条件的时间对时，不输出该用户信息</strong></p>
<p>太坑了。。</p>
<a id="more"></a>
<h2 id="题目思路">题目思路</h2>
<p>题目还是比较简单的，简单的排序即可，可以全部存为一个数组，然后先按名字排序，在名字相同时按时间排序即可。此处采用 C++ Map 分类。对每一个顾客的时间进行排序。然后仅当 当前时间为 <code>on-line</code>紧跟着的下一个时间为<code>off-line</code> 为有效时间对。</p>
<p>仅当存在有效时间对时才有对应的输出。</p>
<p>对于一段时间的计费，可以分别计算单独时间到<code>00:00:00</code>的费用，然后相减即可，一个很好的思路。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, mon, day, hour, mins;</span><br><span class="line">    <span class="keyword">bool</span> type;  <span class="comment">// 1: on-line 0: off-line</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Record&amp; another) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t &lt; another.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;Record&gt;&gt; calls;</span><br><span class="line"><span class="keyword">int</span> price_table[<span class="number">24</span>], price_day = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getCost</span><span class="params">(Record &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = tar.day, h = tar.hour, m = tar.mins;</span><br><span class="line">    ll cost = d * price_day;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; h;i++) &#123;</span><br><span class="line">        cost += price_table[i]*<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cost += price_table[h]*m;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTime</span><span class="params">(Record &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d&quot;</span>, tar.day, tar.hour, tar.mins);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">24</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, price_table+i);</span><br><span class="line">        price_day += price_table[i]*<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> customer, t, line;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; customer;</span><br><span class="line">        Record temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d:%d&quot;</span>, &amp;temp.mon, &amp;temp.day, &amp;temp.hour, &amp;temp.mins);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; line;</span><br><span class="line">        temp.type = line == <span class="string">&quot;on-line&quot;</span>;</span><br><span class="line">        temp.t = <span class="number">24</span>*<span class="number">60</span>*temp.day + <span class="number">60</span>*temp.hour + temp.mins; <span class="comment">// 获取从00:00:00到此的分钟数</span></span><br><span class="line">        calls[customer].push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : calls) &#123;</span><br><span class="line">        sort(i.second.begin(), i.second.end());</span><br><span class="line">        <span class="keyword">int</span> size = i.second.size();</span><br><span class="line">        <span class="keyword">float</span> cost_all = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// 判断是否存在有效时间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; size - <span class="number">1</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second[j].type == <span class="literal">true</span> &amp;&amp; i.second[j+<span class="number">1</span>].type == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; i.first &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="built_in">printf</span>(<span class="string">&quot;%02d\n&quot;</span>, i.second[<span class="number">0</span>].mon);</span><br><span class="line">                &#125;</span><br><span class="line">                printTime(i.second[j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                printTime(i.second[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">float</span> temp_cost = (getCost(i.second[j+<span class="number">1</span>]) - getCost(i.second[j]))/<span class="number">100.0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d $%.2f\n&quot;</span>, i.second[j+<span class="number">1</span>].t - i.second[j].t, temp_cost);</span><br><span class="line">                cost_all += temp_cost;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Total amount: $%.2f\n&quot;</span>, cost_all);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1017 Queueing at Bank（优先队列）</title>
    <url>/2020/03/29/2020-03-29-PAT-Advanced-1017/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0OTE1MzA1Nzk5Njg=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>和 1014 很相似的题目，同样使用优先队列解决，容易的一道题。</p>
<p>题目的意思是真的难懂，17：00之后不能被服务，17：00 是到达时间。。不是服务时间，服务时间不能超过1小时是指大于1小时的按一小时处理，而不是不处理</p>
<a id="more"></a>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arrive;</span><br><span class="line">    <span class="keyword">int</span> leave;</span><br><span class="line">    <span class="keyword">int</span> serve_secs;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Customer &amp; another) &#123;</span><br><span class="line">        <span class="keyword">return</span> arrive &lt; another.arrive;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;customers[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> clock_8 = <span class="number">8</span>*<span class="number">3600</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> clock_17 = <span class="number">17</span>*<span class="number">3600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> whole_wait_sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> legal_nums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> h, m, s, t; <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d %d&quot;</span>, &amp;h, &amp;m, &amp;s, &amp;t);</span><br><span class="line">        <span class="keyword">int</span> arrive = h*<span class="number">60</span>*<span class="number">60</span> + m*<span class="number">60</span> + s;</span><br><span class="line">        <span class="keyword">if</span>(arrive &gt; clock_17) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        customers[legal_nums].arrive = arrive;</span><br><span class="line">        customers[legal_nums++].serve_secs = t &gt; <span class="number">60</span> ? <span class="number">3600</span> : t*<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(customers, customers + legal_nums);</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; leave_que;</span><br><span class="line">    <span class="comment">// 先push M 个 8：00 全在8点离开</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        leave_que.push(clock_8);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; legal_nums;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> serve_time = max(leave_que.top(), customers[i].arrive); leave_que.pop();</span><br><span class="line">        leave_que.push(serve_time + customers[i].serve_secs);</span><br><span class="line">        whole_wait_sec += serve_time - customers[i].arrive;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>, legal_nums == <span class="number">0</span> ? <span class="number">0.0</span> : whole_wait_sec/<span class="number">60.0</span>/legal_nums);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>画个简陋樱花树（简单递归）</title>
    <url>/2020/03/31/2020-03-31-Draw-CherryTree/</url>
    <content><![CDATA[<blockquote>
<p>看到网上很多代码绘制的樱花树，参见<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0Mzk3Ny9hcnRpY2xlL2RldGFpbHMvMTAyNjkxMzky">CSDN<i class="fa fa-external-link-alt"></i></span>，便想自己试试，但是画的有点丑</p>
</blockquote>
<a id="more"></a>
<h2 id="基本思路">基本思路</h2>
<p>其实就是一个“二叉树的遍历”的思路，使用递归不断的二叉，就可以了，这也算是分形图案了。但是简单的递归二叉，不掌握好长度、角度、粗细以及主干和枝干的变化就会很规整。所以慢慢调参吧。</p>
<p>这里采用的是给出每个参数的最大取值范围，然后设置一个缩小的函数，随着递归层数的提高，对应的参数越来越小，这个小的程度和范围就要自己把握了。</p>
<p>缩小函数可以参考：<span class="math inline">\(\frac{1}{n},\frac{1}{\sqrt{n}}\)</span></p>
<h2 id="依赖">依赖</h2>
<p>这里的樱花树使用的是一个简单的<span class="exturl" data-url="aHR0cHM6Ly9lYXN5eC5jbi8=">C++图形库 easyx<i class="fa fa-external-link-alt"></i></span>，简单容易上手。</p>
<h2 id="演示">演示</h2>
<video src="/assets/ArticleVideo/2020/draw-cherrytree.mp4" preload="metadata" controlslist="nodownload" controls playsinline poster=""></video>
<h2 id="基础代码">基础代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;easyx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED (RGB(240, 128, 128))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE (RGB(255, 255, 255))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BROWN (RGB(160, 82, 45))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与主干角度的偏移角度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> angle_min = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> angle_max = <span class="number">28</span>;</span><br><span class="line"><span class="comment">// 长度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> length_min = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> length_max = <span class="number">90</span>;</span><br><span class="line"><span class="comment">// 宽度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> thick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制区大小</span></span><br><span class="line"><span class="keyword">int</span> width = <span class="number">800</span>, height = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制一条线</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawline</span><span class="params">(Point st, Point ed)</span> </span>&#123;</span><br><span class="line">    line(st.first, st.second, ed.first, ed.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生范围内的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_range</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> st + rand() % (ed - st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给点原点 相对于水平的角度 长度 返回处理后的节点</span></span><br><span class="line"><span class="function">Point <span class="title">getPointFromAngle</span><span class="params">(Point src, <span class="keyword">float</span> angle, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    angle = <span class="number">3.14</span>/<span class="number">180.0</span> * angle;</span><br><span class="line">    <span class="keyword">return</span> &#123; src.first+length*<span class="built_in">cos</span>(angle), src.second-length*<span class="built_in">sin</span>(angle) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归画叉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_bifurcation</span><span class="params">(Point p, <span class="keyword">float</span> angle, <span class="keyword">int</span> layer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结束层</span></span><br><span class="line">    <span class="keyword">if</span> (layer == <span class="number">13</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 偏移角</span></span><br><span class="line">    <span class="keyword">float</span> delta = rand_range(angle_min, angle_max);</span><br><span class="line">    <span class="comment">// 收缩 使用根号</span></span><br><span class="line">    <span class="keyword">float</span> shrink = <span class="built_in">pow</span>(layer, <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 便宜的角度越来越小</span></span><br><span class="line">    <span class="keyword">float</span> left_angle = angle + delta/shrink;</span><br><span class="line">    <span class="comment">// 右分支的角度确定</span></span><br><span class="line">    <span class="keyword">float</span> right_angle = left_angle - <span class="number">2.4</span>*delta/shrink;</span><br><span class="line">    <span class="comment">// 随机长度</span></span><br><span class="line">    <span class="keyword">int</span> length_left = rand_range(length_min / shrink, length_max / shrink);</span><br><span class="line">    <span class="keyword">int</span> length_right = rand_range(length_min / shrink, length_max / shrink);</span><br><span class="line">    <span class="comment">// 获取下一个分支点</span></span><br><span class="line">    Point left = getPointFromAngle(p, left_angle, length_left);</span><br><span class="line">    Point right = getPointFromAngle(p, right_angle, length_right);</span><br><span class="line">    <span class="comment">// 末端绘制红白相间的花瓣</span></span><br><span class="line">    <span class="keyword">int</span> type = rand() % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (layer &gt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">            setlinecolor(RED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            setlinecolor(WHITE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        setlinecolor(BROWN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置厚度</span></span><br><span class="line">    setlinestyle(PS_SOLID , thick/layer);</span><br><span class="line">    drawline(p, left);</span><br><span class="line">    <span class="comment">// 递归左分支</span></span><br><span class="line">    draw_bifurcation(left, left_angle, layer + <span class="number">1</span>);</span><br><span class="line">    setlinestyle(PS_SOLID, thick / layer);</span><br><span class="line">    <span class="keyword">if</span> (layer &gt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">            setlinecolor(WHITE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            setlinecolor(RED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        setlinecolor(BROWN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态效果</span></span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">    drawline(p, right);</span><br><span class="line">    <span class="comment">// 递归右分支</span></span><br><span class="line">    draw_bifurcation(right, right_angle, layer + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机绘制地面的花瓣</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_ground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = width * <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = width * <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> up = height - <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> down = height;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">4</span>;</span><br><span class="line">    setlinecolor(RED);</span><br><span class="line">    setlinestyle(PS_SOLID, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> x, y, angle;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        x = rand_range(left, right);</span><br><span class="line">        y = rand_range(up, down);</span><br><span class="line">        angle = rand_range(<span class="number">0</span>, <span class="number">360</span>);</span><br><span class="line">        Point ed = getPointFromAngle(&#123; x, y &#125;, angle, length);</span><br><span class="line">        Sleep(<span class="number">5</span>);</span><br><span class="line">        drawline(&#123; x, y &#125;, ed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initgraph(width, height);</span><br><span class="line">    <span class="comment">// 设置背景色</span></span><br><span class="line">    setbkcolor(RGB(<span class="number">241</span>, <span class="number">215</span>, <span class="number">118</span>));</span><br><span class="line">    cleardevice();</span><br><span class="line">    <span class="comment">// 绘制主干</span></span><br><span class="line">    setlinecolor(BROWN);</span><br><span class="line">    setlinestyle(PS_SOLID | PS_ENDCAP_SQUARE, <span class="number">10</span>);</span><br><span class="line">    line(width/<span class="number">2</span>, height<span class="number">-110</span>, width/<span class="number">2</span>, height<span class="number">-20</span>);</span><br><span class="line">    <span class="comment">// 递归绘制</span></span><br><span class="line">    draw_bifurcation(&#123; width/<span class="number">2</span>, height<span class="number">-110</span> &#125;, <span class="number">90.0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 绘制掉落花瓣的地面</span></span><br><span class="line">    draw_ground();</span><br><span class="line">    _getch();</span><br><span class="line">    closegraph();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1018 Public Bike Management（Dijkstra + DFS）</title>
    <url>/2020/03/31/2020-03-31-PAT-Advanced-1018/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0ODkyODI0MzMwMjQ=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>一眼看去便是最短路问题，和<span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MjM4MzUxMDkzNzY=">1003<i class="fa fa-external-link-alt"></i></span>，有点类似，但又不同。</p>
<p>题目就是求最短路，多条最短路取从基地携带数量最少了，如果有一样的携带数量，就取带回数量最少的，确保这样的路径唯一。</p>
<a id="more"></a>
<h2 id="解决思路">解决思路</h2>
<p>开始以为与<span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU1MjM4MzUxMDkzNzY=">1003<i class="fa fa-external-link-alt"></i></span>一样，但是还是不一样的，因为最短路的子路并不是最优子结构，也就是满足当前的最优条件不一定会满足整体的。这里就必须先将所有的最短路找出，然后计算每一条路的携带数量和带回数量，来选取最优的路径。</p>
<p>有一个一不注意就中招的坑：在计算携带数量和带回数量的时候需要考虑先后关系，即后面多余的车不能补充前面的。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">502</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;    <span class="comment">// P.first 为 起始点到 P.second 的最短路</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, cost;&#125;;<span class="comment">// 边</span></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[maxn];       <span class="comment">// 存储图的邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> weight[maxn];           <span class="comment">// 每个站点的权值</span></span><br><span class="line"><span class="keyword">int</span> d[maxn];                <span class="comment">// 对应点的最短路</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev_node[maxn];        <span class="comment">// 最短路的树结构</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; shortest_paths; <span class="comment">// 起始点到问题点的所有最短路</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 获取路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = &#123;&#125;)</span> </span>&#123;</span><br><span class="line">    temp.push_back(root);</span><br><span class="line">    <span class="keyword">if</span>(prev_node[root].size() == <span class="number">0</span>) &#123;</span><br><span class="line">        shortest_paths.push_back(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; prev_node[root].size();i++) &#123;</span><br><span class="line">        dfs(prev_node[root][i], temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">int</span> c_max, n, problem, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;c_max, &amp;n, &amp;problem, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    weight[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp);</span><br><span class="line">        weight[i] = c_max/<span class="number">2</span> - temp; <span class="comment">// 正 表示carry 负 表示 back</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> st, ed, cost;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;st, &amp;ed, &amp;cost);</span><br><span class="line">        G[st].push_back(&#123;ed, cost&#125;);</span><br><span class="line">        G[ed].push_back(&#123;st, cost&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt;&gt; que;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    que.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        P t = que.top(); que.pop();</span><br><span class="line">        <span class="keyword">if</span>(d[t.second] &lt; t.first) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[t.second].size();i++) &#123;</span><br><span class="line">            edge e = G[t.second][i];</span><br><span class="line">            <span class="keyword">if</span>(d[e.to] &gt; d[t.second] + e.cost) &#123;</span><br><span class="line">                prev_node[e.to] = &#123;t.second&#125;;</span><br><span class="line">                d[e.to] = d[t.second] + e.cost;</span><br><span class="line">                que.push(<span class="built_in">make_pair</span>(d[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d[e.to] == d[t.second] + e.cost) &#123;</span><br><span class="line">                prev_node[e.to].push_back(t.second);    <span class="comment">// 添加前置节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(problem);</span><br><span class="line">    <span class="keyword">int</span> min_carry = INF, min_back = INF, min_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; shortest_paths.size();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, back = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = shortest_paths[i].size() - <span class="number">2</span>;j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="comment">// 坑点 必须按照路径的前进 方向改变对于数值，即后面节点的多余不能给前面节点使用</span></span><br><span class="line">            <span class="keyword">int</span> need = weight[shortest_paths[i][j]];</span><br><span class="line">            <span class="keyword">if</span>(need &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                carry += back - need &gt; <span class="number">0</span> ? <span class="number">0</span> : need - back;</span><br><span class="line">                back = back - need &gt; <span class="number">0</span> ? back - need : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                back += -need;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &lt; min_carry) &#123;</span><br><span class="line">            min_carry = carry;</span><br><span class="line">            min_back = back;</span><br><span class="line">            min_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(carry == min_carry &amp;&amp; back &lt; min_back) &#123;</span><br><span class="line">            min_back = back;</span><br><span class="line">            min_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, min_carry);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = shortest_paths[min_index].size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, shortest_paths[min_index][i]);</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, min_back);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1020 Tree Traversals （二叉树）</title>
    <url>/2020/04/01/2020-04-01-PAT-Advanced-1020/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0ODUwMzM2MDMwNzI=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>给定一个二叉树的后序遍历以及中序遍历的结果，求层序遍历的结果，也就是构造二叉树了</p>
<a id="more"></a>
<h2 id="解决思路">解决思路</h2>
<p>这是一个很经典的重构二叉树的问题了，只要清楚每种遍历的规则和规律即可。</p>
<p>后序遍历：左子树，右子树，根节点</p>
<p>中序遍历：左子树，根节点，右子树</p>
<p>所以对后序遍历而言，后面的节点是前面节点构成的树的根节点，前面节点构成左子树和右子树，所以我们可以采取以下方案获取整棵树的结构。</p>
<p>从后序遍历数组<code>postorder</code>的末尾开始，从<code>inorder</code>数组中寻找和<code>postorder</code>相同值的，<strong>这样就可以分为两边，分别是左子树和右子树</strong>。然后将<code>postorder</code>末尾向前移动一步，对应的就是右子树的根节点。然后在<code>inorder</code>刚刚分开的右半边继续寻找即可。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> postorder[maxn];</span><br><span class="line"><span class="keyword">int</span> inorder[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *left = <span class="literal">NULL</span>, *right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一棵树 根据根节点的值（这里提供postorder的下标），以及inorder的左右边界</span></span><br><span class="line"><span class="function">Node* <span class="title">getTree</span><span class="params">(<span class="keyword">int</span> post_i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *t_root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 分开左右子树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i] == postorder[post_i]) &#123;</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t_root-&gt;val = inorder[mid];</span><br><span class="line">    <span class="comment">// 递归左右子数</span></span><br><span class="line">    t_root-&gt;right = getTree(post_i<span class="number">-1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    t_root-&gt;left = getTree(post_i - (r - mid) - <span class="number">1</span>, l, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> t_root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, postorder + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, inorder + i);</span><br><span class="line">    &#125;</span><br><span class="line">    Node *root = getTree(n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, root-&gt;val);</span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; que;</span><br><span class="line">    que.push(root-&gt;left);</span><br><span class="line">    que.push(root-&gt;right);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        Node *t = que.front(); que.pop();</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,t-&gt;val);</span><br><span class="line">        que.push(t-&gt;left);</span><br><span class="line">        que.push(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>树的直径</title>
    <url>/2020/04/02/2020-04-02-tree-diameter/</url>
    <content><![CDATA[<p>树的直径，即<strong>树中距离最远的两个节点的距离</strong>。</p>
<h2 id="求解方法">求解方法</h2>
<p>选取树中的任意一个节点，计算距离它最远的节点（使用DFS或者BFS），然后以这个最远的节点为根计算距离它最远的节点。这段距离即为树的直径，根和此最远的点便是两个端点。</p>
<a id="more"></a>
<h2 id="简单证明">简单证明</h2>
<p>其实只要证明：<strong>以任意点为根节点，距离此根节点最远的节点必定是树的直径中的一个端点。</strong></p>
<p>证明了这个，那么上面提到的算法就很容易证明了，获取第一个端点，然后以此端点为根的最远端点就是另外一个端点。</p>
<p>首先规定从<em>r</em>开始的最远距离节点为<em>u</em>，证明<em>u</em>为树的直径的一个端点，可以使用反证法证明，假设存在另外两个节点<em>s,t</em>，构成了树的直径。</p>
<ol type="1">
<li><p><strong><em>st</em>的路径和<em>ru</em>不相交</strong>：</p>
<p>在这种情况下，存在<span class="math inline">\(dis(u,s)+dis(s,t) &gt; dis(s,t)\)</span>，所以<em>st</em>并不是最长的，和假设相矛盾，<em>st</em>这种情况下不存在</p></li>
<li><p><strong><em>st</em>的路径和<em>ru</em>相交于点<em>v</em>：</strong></p>
<p>此时<em>s,u</em>都是以<em>a</em>为根的子树上的节点，因为u为距离a最远的结点所以可得： <span class="math display">\[
 dis(a,y)+dis(y,u) &gt; dis(a,y)+dis(y,s) \\
 即：dis(u,y) &lt; dis(s,y)
 \]</span> 同样表示<em>s,t</em>并不是最长的，而是<em>u,t</em></p></li>
</ol>
<p>综上，<em>u</em>必定为树的直径的一个端点。</p>
<p>关于树的直径的更多性质可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vS2hhZGEtSmhpbi9wLzEwMTk1Mjg3Lmh0bWw=">博客园 树的直径及其性质与证明<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1021 Deepest Root （连通分量+树的直径）</title>
    <url>/2020/04/03/2020-04-03-PAT-Advanced-1021/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0ODI5MTk2NzM4NTY=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>一个图如果是树，给出树的直径的大小（最深），否则给出连通分量个数。</p>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>掌握了基础的<a href="/2020/04/06/2020-04-06-connected-components/">连通分量的求法</a>以及<a href="/2020/04/02/2020-04-02-tree-diameter/">树的直径的算法</a>便很简单了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];    <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> visited[maxn];     <span class="comment">// 检查是否遍历完</span></span><br><span class="line"><span class="keyword">int</span> max_height = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历连接图 获得连通分量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            dfs(G[root][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDeepest</span><span class="params">(<span class="keyword">int</span> root, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;height_set, <span class="keyword">int</span> heights = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            getDeepest(G[root][i], height_set, heights+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 叶节点</span></span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        <span class="keyword">if</span>(max_height == heights) &#123;</span><br><span class="line">            height_set.insert(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(max_height &lt; heights) &#123;</span><br><span class="line">            height_set.clear();</span><br><span class="line">            height_set.insert(root);</span><br><span class="line">            max_height = heights;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">    <span class="keyword">int</span> components = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">            components++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(components &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: %d components&quot;</span>, components);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st_points, ed_points;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        getDeepest(<span class="number">1</span>, st_points);</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        getDeepest(*st_points.begin(), ed_points);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : ed_points) &#123;</span><br><span class="line">            st_points.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : st_points) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>求解图的连通分量</title>
    <url>/2020/04/06/2020-04-06-connected-components/</url>
    <content><![CDATA[<h2 id="简单定义">简单定义</h2>
<p>有向图中称为，强连通分量。连通图和连通分量都是针对无向图。</p>
<p>在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为<strong>强连通分量</strong>(strongly connected components)。</p>
<a id="more"></a>
<h2 id="无向图">无向图</h2>
<p>对于无向图而言，只要从一个点开始使用DFS或者BFS遍历所有可以遍历的边，这些遍历到的点集就构成了一个连通分量。然后寻找下一个之前没有遍历的点作为下一个连通分量的根结点，继续进行遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];    <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> visited[maxn];     <span class="comment">// 检查是否遍历完</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历连接图 获得连通分量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[root].size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            dfs(G[root][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;	<span class="comment">// 连通分量的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= num_nodes;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">        dfs(i);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有向图">有向图</h2>
<p>下面两个算法都是<span class="math inline">\(O(N+E)\)</span>的复杂度</p>
<h3 id="tarjan算法">Tarjan算法</h3>
<p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnl2b2lkLmNvbS96aHMvYmxvZy9zY2MtdGFyamFu">有向图强连通分量的Tarjan算法<i class="fa fa-external-link-alt"></i></span></p>
<p>算法的基本思想如下：任选一节点开始进行深度优先搜索（<strong>若深度优先搜索结束后仍有未访问的节点，则再从中任选一点再次进行</strong>）。搜索过程中已访问的节点不再访问。搜索树的若干子树构成了图的强连通分量。</p>
<p>节点按照被访问的顺序存入堆栈中。从搜索树的子树返回至一个节点时，检查该节点是否是某一强连通分量的根节点（见下）并将其从堆栈中删除。如果某节点是强连通分量的根，则在它之前出堆栈且还不属于其他强连通分量的节点构成了该节点所在的强连通分量。</p>
<p>算法代码为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tarjan(u)</span><br><span class="line">&#123;</span><br><span class="line">    DFN[u]=Low[u]=++Index                      <span class="comment">// 为节点u设定次序编号和Low初值</span></span><br><span class="line">    Stack.push(u)                              <span class="comment">// 将节点u压入栈中 其实就是保存拓扑序</span></span><br><span class="line">    <span class="keyword">for</span> each (u, v) in E                       <span class="comment">// 枚举每一条边</span></span><br><span class="line">        <span class="keyword">if</span> (v is <span class="keyword">not</span> visted)                   <span class="comment">// 如果节点v未被访问过</span></span><br><span class="line">            tarjan(v)                          <span class="comment">// 继续向下找</span></span><br><span class="line">            Low[u] = min(Low[u], Low[v])</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v in S)                       <span class="comment">// 如果节点v还在栈内</span></span><br><span class="line">            Low[u] = min(Low[u], DFN[v])</span><br><span class="line">    <span class="keyword">if</span> (DFN[u] == Low[u])                      <span class="comment">// 如果节点u是强连通分量的根</span></span><br><span class="line">        repeat</span><br><span class="line">            v = S.pop                          <span class="comment">// 将v退栈，为该强连通分量中一个顶点</span></span><br><span class="line">            print v</span><br><span class="line">        until (u== v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>DFN[u]：为结点u的搜索编号（时间次序）</li>
<li>Low[u]：为结点u和与结点u相连的子树的最小搜索序（最早出现时间）</li>
</ul>
<p>此算法其中判断强连通分量的思路就是，在以u为根节点进行DFS的过程中如果出现一个结点v指向了之前遍历过的点t，即<span class="math inline">\(u \rightarrow t \rightarrow v \rightarrow t\)</span>也就表明出现了一个环，其中<span class="math inline">\(t,v,t\)</span>就构成了环，即连通分量。</p>
<p>其中的DFN就保存每个结点的访问顺序，Low保存相关子树的最早访问时间，在算法回溯的时候更新，可保证一个强连通分量的Low都是一致的，栈保存的是拓扑序，即遍历的次序，不断出栈获取连通分量。</p>
<h3 id="kosaraju算法">Kosaraju算法</h3>
<p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnVsbHp4L3AvNjQzNzkyNi5odG1s">Kosaraju算法解析: 求解图的强连通分量<i class="fa fa-external-link-alt"></i></span></p>
<p>Kosaraju算法比Tarjan算法看似要简单一些，但效率没有Tarjan算法高，Kosaraju算法依靠DFS遍历获取极大连通子图。但存在一点问题。</p>
<p><img src="\assets\ArticleImg\2020\connected-components-1.png" /></p>
<p>对于上图，从A0开始遍历和B4开始遍历是不一样的结果。如果从B开始遍历，需要2次DFS便可以遍历完整个图，而A0只需要一次。<strong>所以Kosaraju算法的第一个DFS需要获取正确的遍历顺序，</strong>然后第二次DFS的次数便是连通分量的个数了。</p>
<p>上图的反图为：</p>
<p><img src="\assets\ArticleImg\2020\connected-components-2.jpg" /></p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// g 是原图，g2 是反图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u])</span><br><span class="line">    <span class="keyword">if</span> (!vis[v]) dfs1(v);</span><br><span class="line">  s.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  color[u] = sccCnt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : g2[u])</span><br><span class="line">    <span class="keyword">if</span> (!color[v]) dfs2(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sccCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) dfs1(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (!color[s[i]]) &#123;</span><br><span class="line">      ++sccCnt;</span><br><span class="line">      dfs2(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是两点：</p>
<ol type="1">
<li>后序遍历获取拓扑序，保证BA的相对顺序不会改变</li>
<li>反向原图根据上面获取的遍历顺序，重新DFS</li>
</ol>
<h4 id="反图的作用">反图的作用</h4>
<p>其中的反图很有意思，对于强连通子图，反图和原图并无区别。但对于非强连通的则会有很大的影响。例如<span class="math inline">\(A \rightarrow B \rightarrow C\)</span>反图为<span class="math inline">\(A \leftarrow B \leftarrow C\)</span> 从A开始遍历一次便遍历完，但反图后从A开始便需要3次，也就是强连通分量的个数（单个结点也是强连通）。而且反图保证了图的收缩，可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI2NTI2NjkyMy9hbnN3ZXIvOTEyMjM5MTky">Kosaraju算法为什么是用图G的反向图的逆后序，而不能是图G的后序？<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>所以通过后续遍历获取遍历结点的顺序，然后通过反图获取强连通分量的个数。</strong></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1026 Table Tennis （模拟）</title>
    <url>/2020/04/09/2020-04-09-PAT-Advanced-1026/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NzIzMzMyNTA1NjA=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>给定数量的乒乓球台（8：00~21：00开放）以及顾客访问时间表，确定每个顾客的服务时间（不超过2小时）以及每个球台接待的顾客数量。其中增加了VIP机制，有以下三条规则：</p>
<ul>
<li>当一个VIP球台空的时候，排队中的第一个VIP可以优先使用</li>
<li>如果当前没有VIP用户等待，普通用户也可以使用VIP球台</li>
<li>如果VIP用户没有VIP球台可以使用，就使用普通球台</li>
</ul>
<p>存在多个球台可以选择时，选择可选择的编号最小的。如果被服务的时间超过（包含）21：00则不予服务，不打印。注意等待时间的四舍五入。 题目并没有涉及到很难的算法，只是一个挺复杂的模拟问题。</p>
<a id="more"></a>
<h2 id="基础思路">基础思路</h2>
<p>其实有很多种处理的方式，我采取的策略为：</p>
<ol type="1">
<li>用户按时间排序，将每个球台开放时间保存为数组</li>
<li>分别获取球台的最早的普通球台和VIP球台开放时间</li>
<li>如果是普通先开放，意味着没有VIP球台多余，直接给下一个等待用户即可，另外处理没有任何等待用户的情况</li>
<li>如果是VIP球台先开放（包含和普通同时开放的情况），查找顾客数组是否有VIP在等待，有的话给此VIP用户，否则给等待的第一个普通用户，如果没有人等待，进入处理无人等待的情况</li>
<li>无人等待的情况处理：没人等意味着下一个来的可以马上处理，如果来的是VIP查看是否有VIP球台，有给他，没有则给普通，普通用户则直接给空闲的编号最小的球台（此时没VIP等待）</li>
</ol>
<p>可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2FpeWlzaHVhaS9wLzExMzcyMTUzLmh0bWw=">PAT 甲级 1026 Table Tennis (30 分)（坑点很多，逻辑较复杂，做了1天）<i class="fa fa-external-link-alt"></i></span>其中的测试样例</p>
<p><strong>在<code>测试点8</code>错误了，原因为：在检查是否有VIP在排队的时候，忽略了此VIP用户可能在之前以及被处理（VIP有时候可以优先）</strong></p>
<p>代码实现还是有些细节的，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Player</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arrival;</span><br><span class="line">    <span class="keyword">int</span> served;</span><br><span class="line">    <span class="keyword">int</span> isvip;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Player&amp; another) &#123;</span><br><span class="line">        <span class="keyword">return</span> arrival &lt; another.arrival;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Player&gt; players; <span class="comment">// 存储玩家</span></span><br><span class="line">P tables[maxn]; <span class="comment">// 桌子 first：释放时间 second：是否VIP</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> clock_8 = <span class="number">8</span>*<span class="number">3600</span>, clock_21 = <span class="number">21</span>*<span class="number">3600</span>;</span><br><span class="line"><span class="keyword">int</span> table_count[maxn];  <span class="comment">// 计数</span></span><br><span class="line"><span class="keyword">bool</span> is_served[<span class="number">10001</span>];  <span class="comment">// 玩家是否被服务 针对VIP优先处理</span></span><br><span class="line"><span class="keyword">int</span> k, m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_time</span><span class="params">(<span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = sec/<span class="number">3600</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (sec%<span class="number">3600</span>)/<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> s = sec%<span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d&quot;</span>, h, m, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 以及更新对应的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_serverd_player</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> table_pos, <span class="keyword">int</span> served_time)</span> </span>&#123;</span><br><span class="line">    print_time(players[index].arrival); <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>; print_time(served_time); <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> wait = (served_time - players[index].arrival + <span class="number">30</span>)/<span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, wait);</span><br><span class="line">    is_served[index] = <span class="literal">true</span>;</span><br><span class="line">    table_count[table_pos]++;</span><br><span class="line">    tables[table_pos].first = served_time + players[index].served;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回VIP和非VIP的最小下标</span></span><br><span class="line"><span class="function">P <span class="title">getMinTableIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">-1</span>, index2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tables[i].second) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index2 == <span class="number">-1</span> || tables[i].first &lt; tables[index2].first) &#123;</span><br><span class="line">                index2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(index1 == <span class="number">-1</span> || tables[i].first &lt; tables[index1].first) &#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;index1, index2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理没有人等待的情况 VIP的话要先看是否有空闲的VIP</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">no_wait</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取空闲VIP和普通的最小下标</span></span><br><span class="line">    <span class="keyword">int</span> index1 = INF, index2 = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tables[i].second) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index2 == INF &amp;&amp; tables[i].first &lt; players[index].arrival) &#123;</span><br><span class="line">                index2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(index1 == INF &amp;&amp; tables[i].first &lt; players[index].arrival) &#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tar;</span><br><span class="line">    <span class="keyword">if</span>(players[index].isvip) &#123;</span><br><span class="line">        tar = index2 == INF ? index1 : index2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tar = min(index1, index2);</span><br><span class="line">    &#125;</span><br><span class="line">    push_serverd_player(index, tar, players[index].arrival);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(table_count, <span class="number">0</span>, <span class="keyword">sizeof</span>(table_count));</span><br><span class="line">    <span class="built_in">memset</span>(is_served, <span class="number">0</span>, <span class="keyword">sizeof</span>(is_served));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> hh, mm, ss, p, tag;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d %d %d&quot;</span>, &amp;hh, &amp;mm, &amp;ss, &amp;p, &amp;tag);</span><br><span class="line">        <span class="keyword">int</span> sec = hh*<span class="number">3600</span> + mm*<span class="number">60</span> + ss;</span><br><span class="line">        p = p &gt; <span class="number">120</span> ? <span class="number">120</span>*<span class="number">60</span> : p*<span class="number">60</span>;</span><br><span class="line">        <span class="keyword">if</span>(sec &gt;= clock_21) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        players.push_back(&#123;sec, p, tag&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(players.begin(), players.end());</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;k, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        tables[i] = &#123;clock_8, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止全部都是普通或者VIP 导致获取下标函数返回没有意义的值</span></span><br><span class="line">    tables[k++] = &#123;clock_21, <span class="number">0</span>&#125;;</span><br><span class="line">    tables[k++] = &#123;clock_21, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> vip_pos; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;vip_pos);</span><br><span class="line">        tables[vip_pos<span class="number">-1</span>].second = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, len = players.size();</span><br><span class="line">    <span class="keyword">while</span>(index &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_served[index]) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Player p = players[index];</span><br><span class="line">        P min_index = getMinTableIndex();</span><br><span class="line">        <span class="comment">// 后面的都不用处理了</span></span><br><span class="line">        <span class="keyword">if</span>(tables[min_index.first].first &gt;= clock_21 &amp;&amp; tables[min_index.second].first &gt;= clock_21) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> table_empty_time;</span><br><span class="line">        <span class="comment">// 普通的先空 意味着没有VIP位置 那么直接给等待的下一个</span></span><br><span class="line">        <span class="keyword">if</span>(tables[min_index.first].first &lt; tables[min_index.second].first) &#123;</span><br><span class="line">            table_empty_time = tables[min_index.first].first;</span><br><span class="line">            <span class="comment">// 有人在等待</span></span><br><span class="line">            <span class="keyword">if</span>(p.arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                push_serverd_player(index, min_index.first, table_empty_time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没人等</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                no_wait(index);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在空的VIP 位置 注意VIP普通同时为空</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            table_empty_time = tables[min_index.second].first;</span><br><span class="line">            <span class="comment">// 寻找是否有等待的VIP 有则先给他位置 否则给下一个人</span></span><br><span class="line">            <span class="keyword">int</span> vip_pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = index;i &lt; len;i++) &#123;</span><br><span class="line">                <span class="comment">// Error 8:最后一个测试点卡。。已经处理的VIP 跳过</span></span><br><span class="line">                <span class="keyword">if</span>(is_served[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(players[i].arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(players[i].isvip) &#123;</span><br><span class="line">                        vip_pos = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有VIP在等</span></span><br><span class="line">            <span class="keyword">if</span>(vip_pos != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">// printf(&quot;index:%d vip:%d\n&quot;, index, vip_pos);</span></span><br><span class="line">                push_serverd_player(vip_pos, min_index.second, table_empty_time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有VIP在等</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 但有普通人等</span></span><br><span class="line">                <span class="keyword">if</span>(p.arrival &lt;= table_empty_time) &#123;</span><br><span class="line">                    <span class="comment">// 普通人也可以选择VIP的位置 看哪个小选哪个</span></span><br><span class="line">                    <span class="keyword">int</span> tar_pos = tables[min_index.first].first == tables[min_index.second].first ? min(min_index.second, min_index.first) : min_index.second;</span><br><span class="line">                    push_serverd_player(index, tar_pos, table_empty_time);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 没人等</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    no_wait(index);</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k<span class="number">-2</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,table_count[i]);</span><br><span class="line">        <span class="keyword">if</span>(i != k<span class="number">-3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1032 Sharing（链表）</title>
    <url>/2020/04/11/2020-04-11-PAT-Advanced-1032/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NjA2NTIxMTM5MjA=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>简单来说就是求用链表表示的两个字符串的公共后缀的开始位置。</p>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>200ms的限制时间暴力是不可能暴力的，必须是线性时间的算法。</p>
<p>我的思路比较繁琐，首先获取两个字符串的完整路径，并分别记录他们的前置结点，和结尾结点位置。如果两个结尾不一样则输出-1，否则从末尾开始向前寻找第一个分支即可（两个字符串第一个路径前驱不同的位置）。</p>
<p>在生成路径的时候注意<strong>不要以是否为-1作为结束判断</strong>，有些字符串可能他只给出一部分，并没有-1结束标志。其次，采取这种思路在寻找前驱分支的时候，注意当两个字符串为同一个的情况（可能会出现）。可以实现将起始点的前驱结点赋值为不同的值，如-1，-2即可。</p>
<p>网上一种很简便的方法就是遍历字符串1，将遍历到的点记录，然后遍历字符串2，遇到的第一个字符串1中遍历过的，就是公共后缀的开始位置了。</p>
<p>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; link;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> st_1, st_2, ed_1, ed_2, n;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; prev_1, prev_2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;st_1, &amp;st_2, &amp;n);</span><br><span class="line">    <span class="comment">// 防止有两个字符串完全一样的情况。。</span></span><br><span class="line">    prev_1[st_1] = <span class="number">-1</span>;</span><br><span class="line">    prev_2[st_2] = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur, next;</span><br><span class="line">        <span class="keyword">char</span> v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %c %d&quot;</span>, &amp;cur, &amp;v, &amp;next);</span><br><span class="line">        link[cur] = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = st_1;</span><br><span class="line">    <span class="comment">// 条件为link[cur].next != -1会TE 可能不会有-1结尾</span></span><br><span class="line">    <span class="keyword">while</span>(link.count(link[cur])) &#123;</span><br><span class="line">        prev_1[link[cur]] = cur;</span><br><span class="line">        cur = link[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    ed_1 = cur;</span><br><span class="line">    cur = st_2;</span><br><span class="line">    <span class="keyword">while</span>(link.count(link[cur])) &#123;</span><br><span class="line">        prev_2[link[cur]] = cur;</span><br><span class="line">        cur = link[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    ed_2 = cur;</span><br><span class="line">    <span class="keyword">if</span>(ed_1 != ed_2) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prev_1[cur] != prev_2[cur]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = prev_1[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%05d&quot;</span>, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1033 To Fill or Not to Fill （贪心）</title>
    <url>/2020/04/11/2020-04-11-PAT-Advanced-1033/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NTg3MjI3MzQwODA=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>给定出发点到目的地的距离，车油箱容量，平均一单位油的行驶距离和一系列加油站到出发点的距离以及油价。求到达目的地的最低油价，不能到达的话，给出最大可到达距离，假定开始油箱是空的。</p>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>思路清楚的话便十分简单了，大体思想就是贪心。贪心策略如下：</p>
<p>当到达一个加油站的时候，获取其满油状态下可以到达的最远距离，然后<strong>在当前和最远距离之间</strong>选取一个合适的加油站，作为下一次加油的站点。通过下面的方式获取合适站点：</p>
<ol type="1">
<li>如果存在<strong>油价比当前所在加油站价格低</strong>的，则在当前加油站加油到恰好可以到达第一个油价低于它的</li>
<li>否则直接在当前加油站加满油，然后下一个加油站为满油状态下可到达的最远加油站</li>
</ol>
<p>如果到不了下一个油站则直接输出最大可到达距离即可。</p>
<p>需要特判一下开始位置没有加油站的情况，直接输出最大距离0.00。</p>
<p>此贪心策略画个图便很容易想到并证明了。如果在当前加油站可开到一个比他油价低的加油站则在低油价站点补充油一定比直接开要开销小。相反如果不能开到油价低的，则说明途径的油站价格都比原油站价格高，则在途中补充不如直接开到最后一个在补充。<strong>此正确性来自，每个加油站最多且保证可加到满油状态。</strong></p>
<p>注意在考虑的时候，要注意到此油站可能还剩余一些油。</p>
<p>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">float</span> tank, dis, avg, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f %f %f %f&quot;</span>, &amp;tank, &amp;dis, &amp;avg, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt; &gt; gas_stations;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">float</span> v, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f %f&quot;</span>, &amp;v, &amp;d);</span><br><span class="line">        gas_stations.push_back(&#123;d, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    gas_stations.push_back(&#123;dis, <span class="number">0</span>&#125;);   <span class="comment">// 将最后一个站设为免费加油站 便于后面处理</span></span><br><span class="line">    sort(gas_stations.begin(), gas_stations.end()); <span class="comment">// 按距离排序</span></span><br><span class="line">    <span class="comment">// 起始位置没有加油站</span></span><br><span class="line">    <span class="keyword">if</span>(gas_stations[<span class="number">0</span>].first != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The maximum travel distance = %.2f&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> cost = <span class="number">0</span>, last_gas = <span class="number">0</span>;  <span class="comment">// 开销 &amp; 到此加油站剩余油</span></span><br><span class="line">    <span class="keyword">int</span> cur_pos = <span class="number">0</span>, stations_size = gas_stations.size();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> next_dis = gas_stations[cur_pos].first + tank*avg;  <span class="comment">// 在这个站满油情况下的可以开到的最远位置</span></span><br><span class="line">        <span class="keyword">int</span> tar_pos = <span class="number">-1</span>;   <span class="comment">// 获取开销最小的下一个加油站</span></span><br><span class="line">        <span class="comment">// 从这段距离中获取合适的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur_pos+<span class="number">1</span>;i &lt; stations_size;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(gas_stations[i].first &gt; next_dis) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tar_pos = i;</span><br><span class="line">            <span class="keyword">if</span>(gas_stations[i].second &lt;= gas_stations[cur_pos].second) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不能到达到下一个站</span></span><br><span class="line">        <span class="keyword">if</span>(tar_pos == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The maximum travel distance = %.2f&quot;</span>, next_dis);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">float</span> gas_need; <span class="comment">// 需要购买的油</span></span><br><span class="line">        <span class="comment">// 有价格更小的站</span></span><br><span class="line">        <span class="keyword">if</span>(gas_stations[tar_pos].second &lt;= gas_stations[cur_pos].second) &#123;</span><br><span class="line">            gas_need = (gas_stations[tar_pos].first-gas_stations[cur_pos].first)/avg - last_gas;</span><br><span class="line">            last_gas = <span class="number">0</span>;   <span class="comment">// 直接买足够到下一个站的油即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 价格都比它大</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            gas_need = tank - last_gas;   <span class="comment">// 直接加满</span></span><br><span class="line">            last_gas = (next_dis - gas_stations[tar_pos].first)/avg; <span class="comment">// 更新到下一个站的油量</span></span><br><span class="line">        &#125;</span><br><span class="line">        cost += gas_need*gas_stations[cur_pos].second;</span><br><span class="line">        <span class="comment">// 到达目标地</span></span><br><span class="line">        <span class="keyword">if</span>(tar_pos == stations_size<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_pos = tar_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>, cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1040 Longest Symmetric String（动态规划）</title>
    <url>/2020/04/16/2020-04-16-PAT-Advanced-1040/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NDYxMDIwNzMzNDQ=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>求最长回文子串的长度</p>
<a id="more"></a>
<h2 id="基本思路">基本思路</h2>
<p>这里使用动态规划求解 <span class="math display">\[
dp[i][j]=
\begin{cases}
true &amp; &amp; dp[i-1][j+1] == true \&amp;\&amp; str[i]==str[j] \\
false &amp; &amp;\text{else}
\end{cases}
\]</span> dp[i][j] 表示substr(j, i) 是否是回文串</p>
<p>这里动态规划遍历的顺序可以有多种，我是以下标为遍历顺序，也可以以回文串长度作为遍历顺序。</p>
<p>还有一种算法为马拉车算法，实现了复杂度<span class="math inline">\(O(n)\)</span>。可参考<a href="/2018/10/01/2018-10-01-manacher/">最长回文子串算法</a></p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">char</span> s[maxn];</span><br><span class="line">    fgets(s, maxn, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            dp[i][i<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            res = max(res, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-2</span>;j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j+<span class="number">1</span>] &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1038 Recover the Smallest Number （贪心）</title>
    <url>/2020/04/16/2020-04-16-PAT-Advanced-1038/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NDk2MjUyODg3MDQ=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>给定一系列数字串，使用他们组成一个最小的数字</p>
<a id="more"></a>
<h2 id="基础思路">基础思路</h2>
<p>似乎或者应该有那么点贪心的思路，重载一个排序函数，每次选取保证可以最小整个数字串的值。</p>
<p>重载<code>string</code>比较函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != a.size() &amp;&amp; i != b.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> c = a+b, d = b+a;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != c.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i] &lt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[i] &gt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较的思路大概就是对于两个串，从开始遍历，优先选择数字小的，如果两个串前缀完全相同比如A：321，B：32，那么就比较，AB和BA的数字大小情况。</p>
<p>因为无论什么样的顺序，最终的数字位数是确定的，所以确定取那个串作为下一部分，只要选取前缀最小的就可以了。</p>
<p>注意00000的情况，需要打印一个0</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != a.size() &amp;&amp; i != b.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> c = a+b, d = b+a;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != c.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i] &lt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[i] &gt; d[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">string</span> num_str;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; seq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num_str;</span><br><span class="line">        seq.push_back(num_str);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(seq.begin(), seq.end(), cmp);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : seq) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i.length();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i[j] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; i[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; i[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1043 Is It a Binary Search Tree（树）</title>
    <url>/2020/04/21/2020-04-21-PAT-Advanced-1043/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0NDA5NzY2MzM4NTY=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>给定一个二叉树的前序遍历结果，判断是否是搜索二叉树或者搜索二叉树的镜像，是的话打印树的后续遍历结果</p>
<a id="more"></a>
<h2 id="基本思路">基本思路</h2>
<p>前序遍历：<span class="math inline">\(根节点 \rightarrow 左子树 \rightarrow 右子树\)</span>，对于根结点root，只需要将其之后的结点分为两部分（左小于，右大于等于），分别为左子树和右子树，然后对两部分继续递归分解。递归的结构恰好实现了后序遍历<span class="math inline">\(左子树 \rightarrow 右子树 \rightarrow 根节点\)</span>，只要在递归返回的时候记录当前节点值，就可以了。</p>
<p>对于非法搜索树的判断，即在切分子树的阶段，从序列的首尾向中心查找，如果存在没有被归入左子树或者右子树的，则为非法搜索树。</p>
<p>代码如下（参考了<span class="exturl" data-url="aHR0cHM6Ly93d3cubGl1Y2h1by5uZXQvYXJjaGl2ZXMvMjE1Mw==">刘婼<i class="fa fa-external-link-alt"></i></span>的代码）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> pre_order[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">bool</span> is_mirror = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; post_order;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getTree</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 避免只有一半的树 比如5 4 3，此时的ed是大于st的</span></span><br><span class="line">    <span class="keyword">if</span>(st &gt; ed) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = st+<span class="number">1</span>, l = ed;</span><br><span class="line">    <span class="keyword">if</span>(!is_mirror) &#123;</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= ed &amp;&amp; pre_order[r] &lt; pre_order[st]) r++; <span class="comment">// 最后的r是大于l的 因为++，真正的位置是循环结束的r-1</span></span><br><span class="line">        <span class="keyword">while</span>(l &gt; st &amp;&amp; pre_order[l] &gt;= pre_order[st]) l--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= ed &amp;&amp; pre_order[r] &gt;= pre_order[st]) r++;</span><br><span class="line">        <span class="keyword">while</span>(l &gt; st &amp;&amp; pre_order[l] &lt; pre_order[st]) l--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r - l != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刚刚好为后续遍历</span></span><br><span class="line">    getTree(st+<span class="number">1</span>, l);   <span class="comment">//  左边</span></span><br><span class="line">    getTree(r, ed);     <span class="comment">// 右边</span></span><br><span class="line">    post_order.push_back(pre_order[st]);    <span class="comment">// 根结点 此处即为后序遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, pre_order+i);</span><br><span class="line">    &#125;</span><br><span class="line">    getTree(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(post_order.size() == n) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        post_order.clear();</span><br><span class="line">        is_mirror = <span class="literal">true</span>;</span><br><span class="line">        getTree(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(post_order.size() == n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; post_order.size();i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, post_order[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != post_order.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1045 Favorite Color Stripe（动态规划）</title>
    <url>/2020/04/21/2020-04-27-PAT-Advanced-1045/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0Mzc0MTE0NzU0NTY=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>和最长公共子序列很相似，不同的是这里是求串B中符合串A的数字顺序的最长串的大小（即可重复）。比如：</p>
<p>给定顺序A为：1、2、3，待匹配串B为：1、1、2、4、3、2</p>
<p>其中符合条件的串有：</p>
<ol type="1">
<li>1、1、2、2</li>
<li>1、2、2</li>
<li>2、3</li>
<li>...</li>
</ol>
<a id="more"></a>
<h2 id="基本思路">基本思路</h2>
<p>题目和最长公共子序列几乎是一样的，都是动态规划的思路。既然是动态规划那么就涉及到状态转移方程了。类比最长公共子序列，这里使用<code>dp[i][j]</code>表示A串第i位和B串第j位可以构成满足条件的最长串大小。</p>
<p>构成的状态转移方程为： <span class="math display">\[
dp[i][j] = 
\begin{cases}
dp[i][j-1]&amp; \text{A[i-1]==B[j-1]} \\
max(dp[i][j-1], dp[j-1][i]&amp; \text{else}
\end{cases}
\]</span> 可以看出和最长公共子序列仅仅在A[i-1] == B[j-1]（注意dp是从1开始的，表示第i位）时不一样，由<span class="math inline">\(dp[i-1][j-1] + 1\)</span>变成了<span class="math inline">\(dp[i][j-1]+1\)</span>，就是<strong>因为此题目允许相对顺序的重复</strong>。</p>
<p>这里还可以进行状态压缩，注意到此时位二维DP数组，观察其状态转移方程，可以将其压缩为一维数组（也叫做滚动数组）</p>
<p>参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">int</span> nums[maxn];</span><br><span class="line"><span class="keyword">int</span> order[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, order+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, nums+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j<span class="number">-1</span>] == order[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[j] = dp[j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = max(dp[j<span class="number">-1</span>], dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1044 Shopping in Mars（二分）</title>
    <url>/2020/04/21/2020-04-25-PAT-Advanced-1044/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MzkyMDI0NDMyNjQ=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>简单来说，即给定一串数字序列，以及目标值M，找出一段和为M的子串，若不存在找出大于M的最小子串</p>
<a id="more"></a>
<h2 id="简单思路">简单思路</h2>
<p>这是一道二分法的题目，开始很难看出来，因为二分意味着有序，这里并没有什么有序。唯一可能有序的就是和了，如果让一个数组sums保存从开始到此位置的和，那这个数组就是递增的了，也就可以使用二分法了。</p>
<p>从位置i开始（左界）寻找符合条件的右界，也就是找前缀和为sums[i-1]+M的下标，这就可以使用二分查找了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> sums[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ed = n, mid, tar = m+sums[st<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(st &lt; ed) &#123;</span><br><span class="line">        mid = (st + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sums[mid] &gt;= tar) &#123;</span><br><span class="line">            ed = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            st = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    sums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;mid);</span><br><span class="line">        sums[i] = sums[i<span class="number">-1</span>] + mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min_m = sums[n];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tar_pos = divide(i);</span><br><span class="line">        <span class="keyword">int</span> temp = sums[tar_pos]-sums[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(temp &gt; min_m) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp &lt; min_m) &#123;</span><br><span class="line">                res.clear();</span><br><span class="line">                min_m = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(&#123;i, tar_pos&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : res) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-%d\n&quot;</span>, v.first, v.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1051 Pop Sequence（栈）</title>
    <url>/2020/05/06/2020-05-06-PAT-Advanced-1051/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MjczMzI1NjI5NDQ=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>给定栈的最大容量，按照1~N的顺序入栈，但可以随时出栈，判断给出的pop序列是否是可能的情况</p>
<a id="more"></a>
<h2 id="基本思路">基本思路</h2>
<p>这里主要是运用栈这种数据结构先进后出的特点，假如当前pop出来的值为a，那么1~a之间的值，必定是被push过了，所以我们从左到右遍历pop序列并且维护一个栈，而且记录当前已pop的最大值maxn，如果当前pop值t大于他，说明有新的值push到栈中，这些值即为a+1~t，如果小于maxn，说明现在的值是已经被push到栈中了的，所以直接查看它与当前栈顶的值是否一致，是的话则将栈pop，否则说明非法序列，在push到栈的过程中要检查栈大小，不能超过限定值</p>
<p>参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> m, n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;m, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v &gt; maxn) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = maxn+<span class="number">1</span>;j &lt;= v;j++) &#123;</span><br><span class="line">                    s.push(j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s.size() &gt; m) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxn = v;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(v != s.top()) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1049 Counting Ones（动态规划？数学问题）</title>
    <url>/2020/05/02/2020-05-02-PAT-Advanced-1049/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MzA1OTU3MzE0NTY=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>给定n，给出[1,n]范围内所有数字含有的1的个数</p>
<a id="more"></a>
<h2 id="简单思路">简单思路</h2>
<h3 id="规律">规律</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGl1Y2h1by5uZXQvYXJjaGl2ZXMvMjMwNQ==">刘婼巨佬的方法<i class="fa fa-external-link-alt"></i></span>，网上很多都是如此的算法，这道题是《编程之美》中的一道例题，简单来说只需要按以下规律计算即可：</p>
<p><img src="/assets/ArticleImg/2020/pat1049.png" /></p>
<h3 id="动态规划有点那么意思">动态规划（有点那么意思）</h3>
<p>这道题还是想了好久，用了种类似动态规划的方法（或者说动归的思想）。题目求的是1的数目，那么就简单的想就需要知道包含1个1的数字有多少，包含2个1的数字有多少……</p>
<p>所以有什么非暴力的方法获取这些数据，是否可以根据带判断数字的前N位，推出N+1位的数据。比如求123以内的1的个数，如果知道12的相关数据，是否可以推导出123的。</p>
<p>例如，12有下表，纵为1的个数：（包含0）</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>12</td>
<td>9</td>
<td>3（1，10，12）</td>
<td>1（11）</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>根据上表便可以推导出123的相关数据：</p>
<p>比如，求123中只含有1个1的数字的数量。<strong>含有1个1可以从12中的（0，1）两列数据导出，因为含有1个1，可以是不包含1的情况后面添加一个1，如XX1的形式，或者是12中含有1个1的情况添加非1的数如1X[~1]</strong>，还需要注意的一点，<strong>在12中，12这个数是在1列中（表示含有1个1），所以给他添加第三个数的时候需要分类讨论了</strong>，比如10，它的第三位就有9种可能，0，2，3...9，但对于12就只有3种可能，0，2，3（因为目标是123，第三位是3）。还需要注意N+1位为0的情况。</p>
<p>所以获得123的数据表如下：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>12</td>
<td>9</td>
<td>3（1，10，12）</td>
<td>1（11）</td>
<td>0</td>
</tr>
<tr class="even">
<td>123</td>
<td>81</td>
<td>9+2*9+1*3</td>
<td>3+1*9</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>大致思路如上，总结来说，求N+1为的j个数1的数量需要N位j-1，j两列的数据，需要对N位数做单独讨论，因为对XXY，如果前两位是XX那么N+1位就只有Y+1中可能的选择，否则有10种。其次还需要注意对0的讨论。</p>
<p>参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个数1个个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calOnes</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num % <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        num = num/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getOnes</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> num_str[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(num_str, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">    ll table[<span class="number">30</span>]; <span class="comment">// 存储信息表 位数-数量表</span></span><br><span class="line">    <span class="built_in">memset</span>(table, <span class="number">0</span>, <span class="keyword">sizeof</span>(table));</span><br><span class="line">    <span class="comment">// 初始化1位的情况</span></span><br><span class="line">    table[<span class="number">0</span>] = num_str[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>, table[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lens = <span class="built_in">strlen</span>(num_str);</span><br><span class="line">    <span class="keyword">int</span> up_pos = calOnes(table[<span class="number">0</span>]); <span class="comment">// 记录N位的1的个数，以获取其在哪一列</span></span><br><span class="line">    <span class="keyword">int</span> temp_sum = table[<span class="number">0</span>];    <span class="comment">// N位对应的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= lens;i++) &#123;  <span class="comment">// 位数遍历</span></span><br><span class="line">        <span class="keyword">int</span> cur_num = num_str[i<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>;   <span class="comment">// 当前的对应位的值</span></span><br><span class="line">        temp_sum = temp_sum*<span class="number">10</span> + cur_num;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;   <span class="comment">// 保存含有1的数字总和</span></span><br><span class="line">        <span class="comment">// 从后往前压缩数组（滚动数组）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cur = i;cur &gt;= <span class="number">1</span>;cur--) &#123;   <span class="comment">// 获取对应1的个数的数量</span></span><br><span class="line">            <span class="keyword">int</span> prev = cur<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 对应prev，cur两列的数值</span></span><br><span class="line">            <span class="keyword">int</span> a = up_pos == prev ? table[prev] - (cur_num == <span class="number">0</span>) : table[prev];</span><br><span class="line">            <span class="keyword">int</span> b = up_pos == cur ? (table[cur] - <span class="number">1</span>)*<span class="number">9</span> + (cur_num == <span class="number">0</span> ? <span class="number">1</span> : cur_num) : table[cur]*<span class="number">9</span>;</span><br><span class="line">            table[cur] = a+b;</span><br><span class="line">            temp += table[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        table[<span class="number">0</span>] = temp_sum - temp + <span class="number">1</span>; <span class="comment">// 不包含1 的数量</span></span><br><span class="line">        up_pos = calOnes(temp_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= lens;i++) &#123;</span><br><span class="line">        res += i*table[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, getOnes(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1057 Stack （树状数组）</title>
    <url>/2020/05/14/2020-05-14-PAT-Advanced-1057/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MTc5NDU3MTA1OTI=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>给定栈的一系列 POP，PUSH 操作，求执行这些操作后的栈中从小到大排序的中位数（询问中位数的操作是多次的）</p>
<a id="more"></a>
<h2 id="基本思路">基本思路</h2>
<p>栈的模拟并不难处理，主要是对中位数的判断。在不断的更改之中还需要寻找一组数的中位数（范围特征），并且修改每次修改一个具体的数（单点修改），这两个特征符合<a href="/2020/05/13/2020-05-13-Binary-Index-Tree/">树状数组</a>的特征。但还是很难将题目与树状数组联系起来（是真的想不到）。</p>
<p>数组数组的最大特征就是<strong>区间和的计算（前缀和）和高效率的单点修改</strong>，这如何与题目的中位数联系起来，中位数即中间位置的数，也就说明从开始到该数的个数为总数的一半。所以我们使用树状数组维护X这个数的个数，求中位数也就是求目标X，满足1-X范围内的前缀和为总数的一半。这就与树状数组相联系了。</p>
<p>题目给定的条件N为正数，并且小于 <span class="math inline">\(10^5\)</span> 满足使用树状数组的条件。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOWBIT(x) ((x)&amp;(-(x)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nums[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示值x的数量加1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt; maxn) &#123;</span><br><span class="line">        nums[x] += v;   </span><br><span class="line">        x += LOWBIT(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取&lt;x的所有个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        res += nums[x];</span><br><span class="line">        x -= LOWBIT(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(nums, <span class="number">0</span>, <span class="keyword">sizeof</span>(nums));</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, cmd);</span><br><span class="line">        <span class="keyword">if</span>(cmd[<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Invalid\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> x = s.top(); s.pop();</span><br><span class="line">                add(x, <span class="number">-1</span>); <span class="comment">// 减少一个了</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Invalid\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tar = (s.size() + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">1</span>, right = maxn<span class="number">-1</span>, mid;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                    mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(getsum(mid) &lt; tar) &#123;</span><br><span class="line">                        left = mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        right = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            s.push(x);</span><br><span class="line">            add(x, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1052 Linked List Sorting（排序）</title>
    <url>/2020/05/11/2020-05-11-PAT-Advanced-1052/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MjU3ODA2NzA0NjQ=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>给定内存中的链表，节点格式为（地址，值，指向下一个节点的地址），并给出开始地址，给出此链表从小到大排序后的链表。</p>
<a id="more"></a>
<h2 id="基础思路">基础思路</h2>
<p>这道题只需要排序即可，比较基础，但有几个坑，首先这类题一定要考虑不存在的情况（即给出的开始地址是无效的），再者不要使用stl，map会超时……能够使用数组哈希表代替map就不要使用map，开销大很多。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Node;</span><br><span class="line">Node G[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n, v, addr, next, st;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;st);</span><br><span class="line">    <span class="keyword">bool</span> is_empty = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;addr, &amp;v, &amp;next);</span><br><span class="line">        <span class="keyword">if</span>(addr == st) &#123;</span><br><span class="line">            is_empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        G[addr] = &#123;v, next&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is_empty) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0 -1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>.push_back(st);</span><br><span class="line">        <span class="keyword">if</span>(G[st].second == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st = G[st].second;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(<span class="built_in">list</span>.begin(), <span class="built_in">list</span>.end(), [](<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)-&gt;<span class="keyword">bool</span>&#123;<span class="keyword">return</span> G[a].first &lt; G[b].first;&#125;);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">list</span>.size();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %05d\n&quot;</span>, len, <span class="built_in">list</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>, <span class="built_in">list</span>[i], G[<span class="built_in">list</span>[i]].first, <span class="built_in">list</span>[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1\n&quot;</span>, <span class="built_in">list</span>[i], G[<span class="built_in">list</span>[i]].first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary Index Tree 树状数组</title>
    <url>/2020/05/13/2020-05-13-Binary-Index-Tree/</url>
    <content><![CDATA[<h2 id="树状数组">树状数组</h2>
<p>树状数组是能够完成下述操作的数据结构：</p>
<p>给定一个初始值全为0的数列，<span class="math inline">\(a_1,a_2,\dots,a_n\)</span></p>
<ul>
<li>给定i，计算<span class="math inline">\(a_1+a_2+\dots+a_n\)</span></li>
<li>给定i和x，执行<span class="math inline">\(a_i+=x\)</span></li>
</ul>
<p>即单点修改和区间和计算</p>
<a id="more"></a>
<h2 id="原理介绍">原理介绍</h2>
<h3 id="树状数组结构">树状数组结构</h3>
<p><img src="\assets\ArticleImg\2020\bit.png" /></p>
<p>使用大节点保存了多个子节点的信息（区间和信息），如图，<span class="math inline">\(a_8\)</span>为<span class="math inline">\(a_1 \sim a8\)</span>的和，<span class="math inline">\(a_6\)</span>则为<span class="math inline">\(a_5,a_6\)</span>，十分巧妙</p>
<p>其中每个节点的相关节点和其下标对应的二进制有关，与其二进制末尾0的个数有关。其中求<span class="math inline">\(a_1+a_2+\dots+a_n\)</span>，有以下规律：</p>
<ol type="1">
<li><span class="math inline">\(SUM(2) = a[1]+a[2]\)</span></li>
<li><span class="math inline">\(SUM(3) = a[2] + a[3]\)</span></li>
<li><span class="math inline">\(SUM(4) = a[4]\)</span></li>
<li><span class="math inline">\(SUM(5) = a[4]+a[5]\)</span></li>
<li><span class="math inline">\(SUM(6) = a[4]+a[6]\)</span></li>
</ol>
<p>要获取<span class="math inline">\(SUM[n]\)</span>则必须知道<span class="math inline">\(SUM(n-(2^{0的个数}))\)</span>，这个 <span class="math inline">\(2^{0的个数}\)</span> 的个数通过以下函数获取:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用宏实现，x和-x按位相与便可以获得<span class="math inline">\(2^{num(0)}\)</span></p>
<p>所以获取<span class="math inline">\(SUM(n)\)</span>，可以由以下代码获取：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        res += nums[n];</span><br><span class="line">        n -= lowbit(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于单点更新，从以下结论可以得出方法：</p>
<p>更新点x，则所有包含点x结果的点均要更新，而包含点x的点即为x+lowbit(x)，所以代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v当然可以是负数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt; maxn) &#123;</span><br><span class="line">        nums[x] += v;   </span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1059 Prime Factors（素数）</title>
    <url>/2020/05/16/2020-05-16-PAT-Advanced-1059/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MTUwMDU1MDM0ODg=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>将一个数分解为一系列素数相乘的结果，如<code>97532468=2^2*11*17*101*1291</code></p>
<a id="more"></a>
<h2 id="简单思路">简单思路</h2>
<p>网上很多建立素数表的（使用<a href="https://Weijun-Lin.top/2020/03/24/2020-03-24-prime-sieve/">素数筛</a>)，但这道题应该是没有必要的。</p>
<p>从最简单的<a href="https://Weijun-Lin.top/2020/03/24/2020-03-24-prime-sieve/#试除法">一个个除的方法求素数</a>可以解决这道题目。从2开始除，除到2不能除的时候用3除，之后用4，用5……，当然这里4是不能除的，即4不做如何处理跳转到用5除，因为前面2已经将2的倍数全部给除掉了，也就不可能被4除了，这里面也就隐含了<a href="https://Weijun-Lin.top/2020/03/24/2020-03-24-prime-sieve/#埃氏筛">埃氏筛</a>的特点。</p>
<p>参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld=&quot;</span>, n);</span><br><span class="line">    <span class="keyword">int</span> sqr = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        m[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= sqr;) &#123;</span><br><span class="line">        <span class="comment">// 一个因子</span></span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">            n = n/i;</span><br><span class="line">            sqr = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n != <span class="number">1</span>) &#123;</span><br><span class="line">        m[n]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = m.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v.second != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d^%d&quot;</span>, v.first, v.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>VERCEL（原名为ZEIT）DNS 记录的修改</title>
    <url>/2020/05/17/2020-05-17-VERCEL-DNS-EDIT/</url>
    <content><![CDATA[<blockquote>
<p>VERCEL提供静态网站的部署和CDN的加速，十分优秀的工具（适合白嫖）</p>
</blockquote>
<h2 id="问题简述">问题简述</h2>
<p>在部署自己的静态网站后（从GITHUB），VERCEL提供了他们的子域名，当然可以使用自己的域名。可以用CNAME将域名导向VERCEL的子域名，也可以直接使用我们自己的域名（不通过CNAME）。具体配置参考：<span class="exturl" data-url="aHR0cHM6Ly92ZXJjZWwuY29tL2RvY3MvdjIvY3VzdG9tLWRvbWFpbnM=">Custom Domain<i class="fa fa-external-link-alt"></i></span></p>
<p>但直接使用自己的域名会出现一个问题，使用VERCEL提供的DNS服务器后，原来配置的DNS解析失效了。原来我使用的是阿里云的云解析，在更改为VERCEL的DNS服务后，子域名的A记录失效。</p>
<a id="more"></a>
<h2 id="解决方案">解决方案</h2>
<p>既然域名解析失效，因为DNS服务器改成了VERCEL的，所以我们想要改回来需要通过VERCEL修改DNS记录。这需要通过VERCEL的CLI工具实现。下载地址为：https://vercel.com/download</p>
<p>需要先登录，执行：<code>vercel login</code>，登录好之后，就可以修改DNS解析了。（这里我登录验证了好久……）</p>
<p>跟着vercel的官方教程即可：https://vercel.com/docs/cli#commands/domains</p>
<p><code>vercel dns add [domain] [subdomain] [A || AAAA || ALIAS || CNAME || TXT] [value]</code></p>
<p>便可以修改记录</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
  </entry>
  <entry>
    <title>Python 正则替换 Markdown 图像路径前缀</title>
    <url>/2020/05/22/2020-05-22-blog-image-replace/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>在博客网站下直接写文章时，会涉及到图像的路径，一般采用的相对路径。但是这样子在最后部署的时候的路径一般都会出现问题（或者自己另外写好的文章放到网站上就不可避免的重新编辑图像地址）。</p>
<p>一种解决方法是把所有图片放在图床上，就不存在上面的问题了。但本人一般喜欢本地写，图片资源直接放在GitHub上，或者博客网站的相应位置，所以将本地路径转换为 GitHub /网站 路径就显的很重要。</p>
<p>这里采用的是 Python 正则替换实现此功能</p>
<a id="more"></a>
<h2 id="解决方案">解决方案</h2>
<p>这里采用的是Python的正则匹配方案。</p>
<p>Markdown 中的图像都是以 <code>![text](./img_directory/sub_path)</code> 或者 <code>![text](img_directory/sub_path)</code> 这样的形式，而目标则色把他们的公共前缀路径替换为超链接前缀，如 <code>![text](https://site/sub_path)</code>，所以简单的思路就是把图像中的路径 <code>****prefix/img.jpg</code> 替换为 <code>site_path/img.jpg</code> 即把 prefix 及其前面的部分替换为网址前缀，防止图像路径有的使用 <code>./</code> 有的不适用的格式。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author : Weijun Lin</span></span><br><span class="line"><span class="comment"># @File : change-img-path.py</span></span><br><span class="line"><span class="comment"># @Software: VS Code</span></span><br><span class="line"><span class="comment"># @Version: python 3.7.3</span></span><br><span class="line"><span class="comment"># @Desc: 使用方式 python change-img-path.py tar-markdown-file prefix newprefix</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">4</span>:</span><br><span class="line">    print(<span class="string">&quot;amount of parameters must be 4&quot;</span>)</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line">all_prefix = sys.argv[<span class="number">2</span>]</span><br><span class="line">patter1 = <span class="string">&#x27;\!\[.*?\]\((?P&lt;tar&gt;.*&#123;&#125;).*?.*?\)&#x27;</span>.<span class="built_in">format</span>(all_prefix)</span><br><span class="line">patter1 = re.<span class="built_in">compile</span>(patter1)</span><br><span class="line">patter2 = <span class="string">&#x27;\&lt;img src=&quot;(?P&lt;tar&gt;.*&#123;&#125;).*?\..*?\&gt;&#x27;</span>.<span class="built_in">format</span>(all_prefix)</span><br><span class="line">patter2 = re.<span class="built_in">compile</span>(patter2)</span><br><span class="line">file_path, prefix =sys.argv[<span class="number">1</span>], sys.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> file_in, <span class="built_in">open</span>(<span class="string">&quot;out-&quot;</span>+file_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> file_out:</span><br><span class="line">    line = file_in.readline()</span><br><span class="line">    <span class="keyword">while</span> line:</span><br><span class="line">        <span class="comment"># 获取所有匹配的Match对象</span></span><br><span class="line">        matched1 = patter1.finditer(line)</span><br><span class="line">        matched2 = patter2.finditer(line)</span><br><span class="line">        pos_list = []</span><br><span class="line">        <span class="keyword">if</span> matched1 != <span class="literal">None</span>:</span><br><span class="line">            pos_list += [(x.start(<span class="string">&quot;tar&quot;</span>), x.end(<span class="string">&quot;tar&quot;</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(matched1)]</span><br><span class="line">        <span class="keyword">if</span> matched2 != <span class="literal">None</span>:</span><br><span class="line">            pos_list += [(x.start(<span class="string">&quot;tar&quot;</span>), x.end(<span class="string">&quot;tar&quot;</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(matched2)]</span><br><span class="line">        pos_list.sort() <span class="comment"># 按开始位置从小到大排序</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> pos_list[::<span class="number">-1</span>]: <span class="comment"># 逆序遍历</span></span><br><span class="line">            st, ed = v</span><br><span class="line">            <span class="comment"># 替换掉原来的</span></span><br><span class="line">            <span class="keyword">if</span> st == ed:</span><br><span class="line">                line = line[:st] + prefix + line[st:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                line = line[:st] + prefix + line[ed:]</span><br><span class="line">        file_out.write(line);</span><br><span class="line">        line = file_in.readline()</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>使用方式为 <code>python change-img-path.py tar-markdown-file prefix newprefix</code></p>
<p>使用 <code>newprefix</code> 替换图像路径中的 <code>prefix</code></p>
<p>其中一些函数的解释可以参考：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy9saWJyYXJ5L3JlLmh0bWw=">正则表达式操作<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1060 Are They Equal （模拟）</title>
    <url>/2020/05/23/2020-05-23-PAT-Advanced-1060/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9waW50aWEuY24vcHJvYmxlbS1zZXRzLzk5NDgwNTM0MjcyMDg2ODM1Mi9wcm9ibGVtcy85OTQ4MDU0MTM1MjA3MTk4NzI=">题目地址<i class="fa fa-external-link-alt"></i></span></p>
<p>给定有效数字位数，以及两个浮点数，判断浮点数转换为科学计数法后判断是否相同</p>
<a id="more"></a>
<h2 id="简单思路">简单思路</h2>
<p>思路其实挺清楚的，有效数字就是从第一个非零数开始算，不足设定有效位数的需要在后面补零，然后根据小数点的位置和第一个非零值的位置，判断是几次方。</p>
<p>但是坑是真的狠，注意前导0的情况以及输入0的情况。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">format</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">string</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = a.find(<span class="string">&#x27;.&#x27;</span>);  <span class="comment">// pos为点的位置</span></span><br><span class="line">    <span class="comment">// 保证字符串有小数部分</span></span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        a += <span class="string">&quot;.0&quot;</span>;</span><br><span class="line">        pos = a.length() - <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = a.length();</span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">int</span> temp_pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp_pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temp_pos 记录前导0的位置 注意对00.1这样的判断</span></span><br><span class="line">    <span class="keyword">if</span>(temp_pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[temp_pos+<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            temp_pos--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除前导0 并更新长度和点的位置</span></span><br><span class="line">        a.erase(<span class="number">0</span>, temp_pos+<span class="number">1</span>);</span><br><span class="line">        pos -= temp_pos+<span class="number">1</span>;</span><br><span class="line">        length -= temp_pos+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, non_zero = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 取n个有效数字 并且记录第一个非0值的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == n) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(non_zero &lt; <span class="number">0</span> &amp;&amp; a[i] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; a[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            non_zero = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; non_zero != <span class="number">-1</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            res.push_back(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">0</span>;    <span class="comment">// if non_zero = 0说明是000.000这样的 那么exp = 0</span></span><br><span class="line">    <span class="keyword">if</span>(non_zero != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 指数的判断 需要分大于小于1</span></span><br><span class="line">        <span class="keyword">if</span>(non_zero &gt; pos) &#123;</span><br><span class="line">            <span class="built_in">exp</span> = pos - non_zero + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">exp</span> = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有效数不足的要补零</span></span><br><span class="line">    res.insert(res.end(), n-cnt, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    res = <span class="string">&quot;0.&quot;</span> + res + <span class="string">&quot;*10^&quot;</span> + <span class="built_in">std</span>::to_string(<span class="built_in">exp</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> A, B;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    A = format(n, A);</span><br><span class="line">    B = format(n, B);</span><br><span class="line">    <span class="keyword">if</span>(A == B) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES &quot;</span> &lt;&lt; A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO &quot;</span> &lt;&lt; A &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; B;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1064 Complete Binary Search Tree （二叉树）</title>
    <url>/2020/05/27/2020-05-27-PAT-Advanced-1064/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给定一个各个数不同的序列，给出满足完全二叉树定义的二叉搜索树的层序遍历结果</p>
<p>Sample Input:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 0</span><br></pre></td></tr></table></figure>
<p>Sample Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 3 8 1 5 7 9 0 2 4</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="基本思路">基本思路</h2>
<p>主要需要知道完全二叉树的定义以及一些性质，完全二叉树即除底层之外，为满二叉树，且底层为从左到右排列。所以对于给定数量的节点，它的完全二叉树结构是确定的，此时只需要用中序遍历，将给定的序列排序后依次放入就可以了，因为它也是一个搜索树。最后在层序遍历输出结果即可。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Tree[<span class="number">1010</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> vals[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> nodes[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> layers;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">midorder</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历左边</span></span><br><span class="line">    <span class="keyword">if</span>(Tree[root][<span class="number">0</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">        midorder(Tree[root][<span class="number">0</span>], tar);</span><br><span class="line">    &#125;</span><br><span class="line">    nodes[root] = vals[tar++];</span><br><span class="line">    <span class="comment">// 遍历右边</span></span><br><span class="line">    <span class="keyword">if</span>(Tree[root][<span class="number">1</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">        midorder(Tree[root][<span class="number">1</span>], tar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">memset</span>(Tree, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, vals + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="comment">// 构建树结构</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        l = <span class="number">2</span>*i+<span class="number">1</span>, r = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; n) &#123;</span><br><span class="line">            Tree[i][<span class="number">0</span>] = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; n) &#123;</span><br><span class="line">            Tree[i][<span class="number">1</span>] = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vals, vals+n);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过中序遍历</span></span><br><span class="line">    midorder(<span class="number">0</span>, cnt);</span><br><span class="line">    <span class="comment">//层序遍历</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = q.front(); q.pop();</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%s&quot;</span>, nodes[r], cnt == n ? <span class="string">&quot;&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(Tree[r][<span class="number">0</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">            q.push(Tree[r][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Tree[r][<span class="number">1</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">            q.push(Tree[r][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1065 A+B and C (64bit)</title>
    <url>/2020/05/28/2020-05-28-PAT-Advanced-1065/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给定三个数A，B，C，范围在<span class="math inline">\([-2^{63},2^{63}]\)</span>，判断<code>A+B&gt;C</code></p>
<a id="more"></a>
<h2 id="简单思路">简单思路</h2>
<p>网上很多都是将范围看作<span class="math inline">\([-2^{63},2^{63}-1]\)</span>的范围（因为测试点没有<span class="math inline">\(2^{63}\)</span>这个数据……），这样就可以直接使用<code>long long</code>类型存数据然后判断是否溢出即可。但终究不符合题意，如果真有<span class="math inline">\(2^{63}\)</span>便不行了。</p>
<p>既然<code>long long</code>存不下，就可以改用<code>unsigned long long</code>，符号位另外单独保存，所以只需要根据符号位计算对应的和就可以了，但是相加之后还是会出现溢出的情况，所以单独判断溢出即可。</p>
<p>出现溢出的情况只有在正+正，负+负的情况，并且假设<code>A+B = S</code>，那么有<code>S &lt; A and S &lt; B</code>，根据这个结论便可以判断是否溢出。</p>
<p>对于符号位的存储，需要首先将数存为字符串类型，然后通过<code>sscanf</code>读入，对于负号要先去掉。</p>
<p>当然你也可以直接使用字符串模拟加法操作也是可以的。</p>
<p>参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> llu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isGreater</span><span class="params">(<span class="keyword">bool</span> s_a, llu a, <span class="keyword">bool</span> s_b, llu b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正 负</span></span><br><span class="line">    <span class="keyword">if</span>(s_a &amp;&amp; !s_b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负 正</span></span><br><span class="line">    <span class="keyword">if</span>(!s_a &amp;&amp; s_b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负 负</span></span><br><span class="line">    <span class="keyword">if</span>(!s_a &amp;&amp; !s_b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">3</span>][<span class="number">50</span>];    <span class="comment">// 保存为字符串 区别正负数</span></span><br><span class="line">    <span class="keyword">bool</span> s[<span class="number">3</span>];          <span class="comment">// 0 非负数 1 负数 符号位保存</span></span><br><span class="line">    llu nums[<span class="number">3</span>];        <span class="comment">// 保存数值</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %s %s&quot;</span>, str[<span class="number">0</span>], str[<span class="number">1</span>], str[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">3</span>;k++) &#123;</span><br><span class="line">            s[k] = str[k][<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">char</span> *buffer = str[k][<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> ? str[k]+<span class="number">1</span> : str[k];</span><br><span class="line">            <span class="built_in">sscanf</span>(buffer, <span class="string">&quot;%llu&quot;</span>, &amp;nums[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag;  <span class="comment">// 结果的符号</span></span><br><span class="line">        llu res;    <span class="comment">// 存放结果</span></span><br><span class="line">        <span class="comment">// 正 负</span></span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] &amp;&amp; !s[<span class="number">1</span>]) &#123;</span><br><span class="line">            flag = nums[<span class="number">0</span>] &gt;= nums[<span class="number">1</span>];  <span class="comment">// a &gt;= b true</span></span><br><span class="line">            res = flag ? nums[<span class="number">0</span>] - nums[<span class="number">1</span>] : nums[<span class="number">1</span>] - nums[<span class="number">0</span>];</span><br><span class="line">            flag = isGreater(flag, res, s[<span class="number">2</span>], nums[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 负 正</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!s[<span class="number">0</span>] &amp;&amp; s[<span class="number">1</span>]) &#123;</span><br><span class="line">            flag = nums[<span class="number">1</span>] &gt;= nums[<span class="number">0</span>];  <span class="comment">// a &gt;= b true</span></span><br><span class="line">            res = flag ? nums[<span class="number">1</span>] - nums[<span class="number">0</span>] : nums[<span class="number">0</span>] - nums[<span class="number">1</span>];</span><br><span class="line">            flag = isGreater(flag, res, s[<span class="number">2</span>], nums[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 负 负</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!s[<span class="number">0</span>] &amp;&amp; !s[<span class="number">1</span>]) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>];</span><br><span class="line">            flag = isGreater(flag, res, s[<span class="number">2</span>], nums[<span class="number">2</span>]);</span><br><span class="line">            <span class="comment">// 必然是小于溢出，溢出则必定是小于</span></span><br><span class="line">            <span class="keyword">if</span>(res &lt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>];</span><br><span class="line">            flag = isGreater(flag, res, s[<span class="number">2</span>], nums[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span>(res &lt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %s\n&quot;</span>, i, flag ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT Advanced 1066 Root of AVL Tree (AVL树)</title>
    <url>/2020/06/01/2020-06-01-PAT-Advanced-1066/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给定整数序列，按顺序添加到AVL树中，给出最后AVL树的根节点的值（没想到甲级居然还要考AVL）</p>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>只要会AVL平衡操作的旋转就可以了</p>
<p>参考：</p>
<ol type="1">
<li>https://zhuanlan.zhihu.com/p/34899732</li>
<li>https://www.cnblogs.com/vamei/archive/2013/03/21/2964092.html</li>
</ol>
<p>知乎那篇文章也有点问题。。。</p>
<p>参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    node *left;</span><br><span class="line">    node *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treeHeight</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max(treeHeight(root-&gt;left),treeHeight(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回高度差</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treeGetBalanceFactor</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> treeHeight(root-&gt;left) - treeHeight(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单右旋 返回新的ROOT节点</span></span><br><span class="line"><span class="function">node* <span class="title">treeRotateRight</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    node* left = root-&gt;left;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = left-&gt;right; <span class="comment">// 将将要被抛弃的节点连接为旋转后的 root 的左孩子</span></span><br><span class="line">    left-&gt;right = root; <span class="comment">// 调换父子关系</span></span><br><span class="line">    <span class="comment">// 这里高度就不更新了，用到的时候直接递归获取</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单左旋 返回新的ROOT节点</span></span><br><span class="line"><span class="function">node* <span class="title">treeRotateLeft</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    node* right = root-&gt;right;</span><br><span class="line"></span><br><span class="line">    root-&gt;right = right-&gt;left;</span><br><span class="line">    right-&gt;left = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">treeRebalance</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> factor = treeGetBalanceFactor(root);</span><br><span class="line">    <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; treeGetBalanceFactor(root-&gt;left) &gt; <span class="number">0</span>) <span class="comment">// LL</span></span><br><span class="line">        <span class="keyword">return</span> treeRotateRight(root);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; treeGetBalanceFactor(root-&gt;left) &lt;= <span class="number">0</span>) &#123; <span class="comment">//LR</span></span><br><span class="line">        root-&gt;left = treeRotateLeft(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> treeRotateRight(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(factor &lt; <span class="number">-1</span> &amp;&amp; treeGetBalanceFactor(root-&gt;right) &lt;= <span class="number">0</span>) <span class="comment">// RR</span></span><br><span class="line">        <span class="keyword">return</span> treeRotateLeft(root);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((factor &lt; <span class="number">-1</span> &amp;&amp; treeGetBalanceFactor(root-&gt;right) &gt; <span class="number">0</span>)) &#123; <span class="comment">// RL</span></span><br><span class="line">        root-&gt;right = treeRotateRight(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> treeRotateLeft(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Nothing happened.</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node **root_ptr, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    node *root = *root_ptr;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node *new_node = <span class="keyword">new</span> node&#123;val,<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">        *root_ptr = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; val) &#123;</span><br><span class="line">            insert(&amp;(root-&gt;right), val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            insert(&amp;(root-&gt;left), val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *root_ptr = treeRebalance(*root_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;./in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    node* root = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br><span class="line">        insert(&amp;root, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>【STL】next_permutation 算法原理</title>
    <url>/2020/09/24/2020-09-24-next-permutation/</url>
    <content><![CDATA[<blockquote>
<p>参考：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbHVydWl5dWFuL3AvNTkxNDkwOS5odG1s">【博客园】 STL next_permutation 算法原理和自行实现<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0N6eWF1bi9hcnRpY2xlL2RldGFpbHMvMTA0NDIwMzI5">【CSDN】next_permutation和pre_permutation源码解析<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<h2 id="基本思路">基本思路</h2>
<p>【STL】 <code>next_permutation</code> 函数就是返回当前序列的下一个字典序，已经为最大字典序则返回 False，否则为返回 True</p>
<p>基本思想如下：</p>
<ol type="1">
<li>从尾端开始依次比较两个相邻元素直到存在 <span class="math inline">\(a_i,a_{i+1}\)</span> 满足 <span class="math inline">\(a_i &lt; a_{i+1}\)</span>，如果未找到返回 False</li>
<li>从尾端开始向前检验，找出第一个大于 <span class="math inline">\(a_i\)</span> 的元素 <span class="math inline">\(a_j\)</span>，交换 <span class="math inline">\(a_i,a_j\)</span></li>
<li>将 <span class="math inline">\(a_i\)</span> 之后（不包括 <span class="math inline">\(a_i\)</span>）的序列做反序处理</li>
</ol>
<a id="more"></a>
<p>可能的代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirIt</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">next_permutation</span><span class="params">(BidirIt first, BidirIt last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    BidirIt i = last;</span><br><span class="line">    <span class="keyword">if</span> (first == --i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        BidirIt i1, i2;</span><br><span class="line"> </span><br><span class="line">        i1 = i;</span><br><span class="line">        <span class="keyword">if</span> (*--i &lt; *i1) &#123;</span><br><span class="line">            i2 = last;</span><br><span class="line">            <span class="keyword">while</span> (!(*i &lt; *--i2))</span><br><span class="line">                ;</span><br><span class="line">            <span class="built_in">std</span>::iter_swap(i, i2);</span><br><span class="line">            <span class="built_in">std</span>::reverse(i1, last);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == first) &#123;</span><br><span class="line">            <span class="built_in">std</span>::reverse(first, last);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单证明">简单证明</h2>
<p>上面给出了思路，这里做一个简单证明</p>
<p>对一个序列 <span class="math inline">\(a_0,a_1,\cdots,a_i,a_{i+1},\cdots,a_{n-1}\)</span>，必定存在 <span class="math inline">\(i\)</span>，使得 <span class="math inline">\(a_0 \sim a_i\)</span>，为正序，<span class="math inline">\(a_{i+1}\sim a_{n-1}\)</span> 为逆序（这里正序指的是从小到大的顺序，逆序为从大到小），这里对应了上面的步骤 1</p>
<p>现在需要求此序列的下一个字典序，容易得到，<span class="math inline">\(a_{i+1}\sim a_{n-1}\)</span> 已经为逆序（也为递减数列），不存在更大的字典序，但 <span class="math inline">\(a_{i}\sim a_{n-1}\)</span>，并不是逆序，即存在更大的字典序</p>
<p>显然以 <span class="math inline">\(a_i\)</span> 作为 <span class="math inline">\(a_{i}\sim a_{n-1}\)</span> 的首元素已经达到最大，所以需要在 <span class="math inline">\(a_{i+1}\sim a_{n-1}\)</span> 中找到一个元素替换 <span class="math inline">\(a_i\)</span>，显然此元素为大于 <span class="math inline">\(a_i\)</span> 的最小元素，因为数列 <span class="math inline">\(a_{i+1}\sim a_{n-1}\)</span> 为递减数列，所以只需要从末端开始向前寻找第一个大于 <span class="math inline">\(a_i\)</span> 的元素即可，记此元素为 <span class="math inline">\(a_j\)</span>，即步骤 2</p>
<p>因为 <span class="math inline">\(a_j &gt; a_i\)</span>，所以 <span class="math inline">\(a_j\)</span> 作为首元素的最小排列为 <span class="math inline">\(a_{i+1} \sim a_{n-1}\)</span> 的顺序表示即可。交换后的序列仍然为逆序的，所以只需要反序处理即可，对应步骤 3</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积的简单概况</title>
    <url>/2020/11/01/2020-11-01-ConvolutionAndCorrelation/</url>
    <content><![CDATA[<p>计算机视觉与图形图像处理等方面傅里叶变换都是一个十分重要的工具，与傅里叶变换紧密结合起来的便是<strong>卷积和相关</strong>，尤其是卷积（Convolution）在《数字图像处理-冈萨雷斯》中对卷积的的介绍比较笼统。</p>
<a id="more"></a>
<p>以下内容参考自《傅里叶变换-冷建华》以及《DIP》</p>
<p>卷积和相关有连续时间和离散时间两种形式，称之为时间是因为傅里叶是和信号紧密相关的，信号简单来说就是有意义的改变量，一般是随时间改变。</p>
<h2 id="冲激信号">冲激信号</h2>
<p>类似的冲激信号也有连续和离散两种形式，冲激信号是十分重要的基本信号，在傅里叶变换和取样有重要作用。</p>
<h3 id="连续时间的冲激信号">连续时间的冲激信号</h3>
<p>基本形式如下： <span class="math display">\[
\delta_a(t) = 
\left\{
\begin{aligned}
+\infty&amp;, &amp;t = 0 \\
0&amp;, &amp;t\neq 0
\end{aligned}
\right.
\]</span> 且满足： <span class="math display">\[
\int_{-\infty}^{+\infty} \delta_a(t) dt = 1
\]</span> 下标 a 表示模拟信号（analog），有以下的积分形式的取样特性（sift）： <span class="math display">\[
\int_{-\infty}^{+\infty} f(t) \delta_a(t) dt = f(0) \\
\int_{-\infty}^{+\infty} f(t) \delta_a(t-t_0) dt = f(t_0)
\]</span></p>
<h3 id="离散时间的冲激信号">离散时间的冲激信号</h3>
<p>和连续形式的冲激类似，其形式如下： <span class="math display">\[
\delta(n) = 
\left\{
\begin{aligned}
1&amp;, &amp;n = 0 \\
0&amp;, &amp;n\neq 0
\end{aligned}
\right.
\]</span> 其中 n 为整数，满足： <span class="math display">\[
\sum_{n = -\infty}^{+\infty}\delta(n) = 1
\]</span> 类似的取样特性如下： <span class="math display">\[
\sum_{n = -\infty}^{+\infty} f(n)\delta(n) = f(0) \\
\sum_{n = -\infty}^{+\infty} f(n)\delta(n - x_0) = f(x_0)
\]</span></p>
<h2 id="连续时间信号的卷积">连续时间信号的卷积</h2>
<h3 id="线性卷积">线性卷积</h3>
<p>定义如下： <span class="math display">\[
x_a(t) * y_a(t) = \int_{-\infty}^{+\infty} x_a(\tau) y_a(t-\tau) d\tau
\]</span> 也就是将 <span class="math inline">\(y_a\)</span> 翻转（卷）之后对应相乘（积）然后平移计算出所有的值。</p>
<p>具有<strong>冲激不变性</strong>： <span class="math display">\[
x_a(t) * \delta_a(t) = \int_{-\infty}^{+\infty} x_a(\tau) \delta_a(t-\tau) d\tau = x_a(t)
\]</span> 线性卷积一般针对一般信号，需要在整个定义域内进行计算</p>
<h3 id="周期卷积">周期卷积</h3>
<p>周期卷积也就是针对的是周期信号的卷积，因为是周期信号所以只需要关注一个周期就可以了</p>
<p>定义如下： <span class="math display">\[
x_a(t) * y_a(t) = \int_{0}^{T} x_a(\tau) y_a(t-\tau) d\tau
\]</span> 其中 <span class="math inline">\(x_a\)</span> 和 <span class="math inline">\(y_a\)</span> 都是周期为 T 的信号，和线性卷积唯一不同的就是积分区域，这里采用的是 <span class="math inline">\([0 \sim T]\)</span>，其实只要满足一个周期就可以了</p>
<h3 id="循环卷积">循环卷积</h3>
<p>循环卷积是针对有限信号，即在某一段区域内有定义的信号（定义域外为 0）假设信号 <span class="math inline">\(x_a,y_a\)</span> 定义在 <span class="math inline">\([0 \sim T]\)</span> 上，循环卷积定义如下： <span class="math display">\[
x_a(t) * y_a(t) = \int_{0}^{T} x_a(\tau) y_a(&lt;t-\tau&gt;_T) d\tau
\]</span> 其中 <span class="math inline">\(&lt;t-\tau&gt;_T\)</span> 表示对 <span class="math inline">\(t-\tau\)</span> 取模 T 运算，即余数。</p>
<p>卷积后的信号仅在 <span class="math inline">\([0\sim T]\)</span> 有定义，其它均为 0。</p>
<p><strong>周期卷积和循环卷积同样满足冲击不变性</strong>。</p>
<h2 id="离散时间信号的卷积">离散时间信号的卷积</h2>
<p>类似于连续信号，离散信号（序列）仅仅是将积分改为求和，离散卷积同样具有冲击不变性</p>
<h3 id="线性卷积-1">线性卷积</h3>
<p>定义如下： <span class="math display">\[
x(n) * y(n) = \sum_{i=-\infty}^{+\infty} x(i) y(n-i)
\]</span> n 为整数，代表离散</p>
<h3 id="周期卷积-1">周期卷积</h3>
<p>周期卷积对应的就是周期序列，两个周期为 N 的信号的卷积如下： <span class="math display">\[
x(n) * y(n) = \sum_{i=0}^{N-1} x(i) y(n-i)
\]</span></p>
<h3 id="循环卷积-1">循环卷积</h3>
<p>循环卷积定义的是一般有限序列，定义如下： <span class="math display">\[
x(n) * y(n) = \sum_{i=0}^{N-1} x(i) y(&lt;n-i&gt;_N)
\]</span></p>
<h2 id="简单补充">简单补充</h2>
<p>循环卷积和周期卷积本质上并无区别，循环卷积就是对有限序列直接进行<strong>周期拓展</strong>后的周期卷积</p>
<p>循环卷积也叫做圆周卷积</p>
<p>对于长度不同的序列做循环卷积一般会进行拓展，即在末尾补0，假设两个信号长度分别为 M，N，则补充 0 后的长度应该至少为 M+N，这样的循环卷积才会和直接线性卷积相同。即两个信号的高低频不会混淆。</p>
<h2 id="拓充参考">拓充参考</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2Vuc3Bvcmdlci9wLzEyOTAzMTUyLmh0bWw=">序列卷积：线性、周期和圆周<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDAyODkzMzc=">别怕，&quot;卷积&quot;其实很简单<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
      </categories>
      <tags>
        <tag>傅里叶变换</tag>
        <tag>信号处理</tag>
        <tag>卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>傅里叶变换推导</title>
    <url>/2020/12/04/2020-12-04-FourierTransformation/</url>
    <content><![CDATA[<p>主要介绍从傅里叶级数出发推导傅里叶变换，知乎有很多优秀的傅里叶变换的推导，这里给出一个从傅里叶级数出发，化离散为连续推导出傅里叶变换（也参考了网上的一些思路）</p>
<p>本文的傅里叶形式主要为冈萨雷斯中文版《数字图形处理 第三版》第四章给出的形式，下文用《DIP》替代。</p>
<a id="more"></a>
<h2 id="傅里叶级数">傅里叶级数</h2>
<p>复数形式的傅里叶级数： <span class="math display">\[
\begin{align}
f(t) &amp;= \sum_{n=-\infty}^{\infty} C_n e^{j\frac{2\pi n}{T}t} \\
C_n &amp;= \frac{1}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} f(t) e^{-j\frac{2\pi n}{T}t} \text{d}t \\
n &amp;= 0,\pm 1,\pm 2,\dots
\end{align}
\]</span> 等式摘自《DIP》 4.2.2 傅里叶级数。</p>
<p>傅里叶级数的复数形式可参考网上，注意指数表达有角频率和频率两种，这里为角频率。傅里叶变换推导中将指出。</p>
<h2 id="傅里叶变换">傅里叶变换</h2>
<p>《DIP》4.2.4 给出了傅里叶变换对 <span class="math display">\[
\begin{align}
F(\mu) &amp;= \int_{-\infty}^{\infty} f(t) e^{-j2\pi \mu t} \text{d}t \\
f(t) &amp;= \int_{-\infty}^{\infty} F(\mu) e^{-j2\pi \mu t} \text{d}\mu
\end{align}
\]</span> 其实我们发现傅里叶变换和傅里叶级数的形式是十分相似的，且<strong>级数与积分之间的关系可以用离散和连续来表示</strong>，那么可以试试将傅里叶级数连续化，看看是否可以得出傅里叶变换。傅里叶级数是适用于周期函数的，对于一般函数可认为 <span class="math inline">\(T\rightarrow \infty\)</span></p>
<p>重写一般函数的傅里叶级数如下： <span class="math display">\[
\begin{align}
f(t) &amp;= \lim_{T\rightarrow \infty} \sum_{n = -\infty}^{\infty} C_n e^{j\frac{2\pi n}{T}t} \\
&amp;=\lim_{T\rightarrow \infty} \sum_{n = -\infty}^{\infty} 
\{\frac{1}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} f(t) e^{-j\frac{2\pi n}{T}t} \text{d}t\}
e^{j\frac{2\pi n}{T}t} \\
\end{align}
\]</span> 令 <span class="math inline">\(\Delta w = \frac{2\pi}{T}\)</span>（角频率）， <span class="math inline">\(T\rightarrow \infty\)</span> 所以 <span class="math inline">\(\Delta w \rightarrow 0\)</span>，将 <span class="math inline">\(\Delta w\)</span> 带入上式可得 <span class="math display">\[
f(t) = \lim_{\Delta w\rightarrow 0} \sum_{n = -\infty}^{\infty} 
\{\frac{\Delta w}{2\pi} \int_{-\infty}^{\infty} f(t) e^{-j\Delta w\cdot nt} \text{d}t\}
e^{j\Delta w\cdot nt}
\]</span> 令 <span class="math inline">\(w = \Delta w\cdot n\)</span>，带入可得 <span class="math display">\[
f(t) = \lim_{\Delta w\rightarrow 0} \sum_{n = -\infty}^{\infty} 
\{\frac{\Delta w}{2\pi} \int_{-\infty}^{\infty} f(t) e^{-jwt} \text{d}t\}
e^{jwt}
\]</span> 这里可以发现大括号内的就是傅里叶变换的形式。所以将其单独提取出来即： <span class="math display">\[
F(w) = \int_{-\infty}^{\infty} f(t) e^{-jwt} \text{d}t
\]</span> 所以函数又可化为： <span class="math display">\[
\begin{align}
f(t) &amp;= \lim_{\Delta w\rightarrow 0} \sum_{n = -\infty}^{\infty} 
\frac{\Delta w}{2\pi} F(w)
e^{jwt} \\
&amp;= \frac{1}{2\pi} \lim_{\Delta w\rightarrow 0} \sum_{n = -\infty}^{\infty} 
\Delta w F(w)
e^{jwt}
\end{align}
\]</span> 注意到 <span class="math inline">\(w = \Delta w\cdot n\)</span> ，因为 <span class="math inline">\(n \in (-\infty,\infty)\)</span>，所以 w 为<span class="math inline">\((-\infty,\infty)\)</span> 上以 <span class="math inline">\(\Delta w\)</span> 为间隔的点集。且有定义可知 w 是 n 的函数，对于确定的 <span class="math inline">\(\Delta w\)</span> ，有 <span class="math inline">\(\text{d}w = \Delta w\)</span>，现在，令 <span class="math inline">\(\Delta w\rightarrow 0\)</span> ，即将 w 连续化，所以上式的<strong>本质为函数 <span class="math inline">\(F(w)e^{jwt}\)</span> 自变量 w 在 <span class="math inline">\((-\infty,\infty)\)</span> 上的积分</strong>。最终可得： <span class="math display">\[
\begin{align}
f(t) &amp;= \frac{1}{2\pi} \int_{-\infty}^{\infty} 
F(w) e^{jwt} \text{d} w \tag{1}\\
F(w)&amp; = \int_{-\infty}^{\infty} f(t) e^{-jwt} \text{d}t \tag{2} \\
w &amp;= \Delta w \cdot n \\
\Delta w &amp;= \frac{2\pi}{T}
\end{align}
\]</span> 式子 <span class="math inline">\((1),(2)\)</span> 构成了傅里叶变换对，<span class="math inline">\((1)\)</span> 为傅里叶逆变换，<span class="math inline">\((2)\)</span> 为傅里叶变换</p>
<p>其中并没有涉及到 <span class="math inline">\(\Delta w\)</span> ，只涉及到自变量 <span class="math inline">\(t,w\)</span>。但傅里叶变换对是时域到频率域的转换。现在也很好理解为什么连接了频率域，<strong>因为推导过程涉及到了 <span class="math inline">\(\Delta w\)</span>，它的物理意义为角频率，而 w 是数轴上以 <span class="math inline">\(\Delta w\)</span> 分割的点集，也就覆盖了全部的频率，换句话说，w 是在频率域中的变量</strong>。</p>
<p>这个变换对定义式和《DIP》以及网上一些不同，主要在于系数 <span class="math inline">\(\frac{1}{2\pi}\)</span> 以及指数部分，本质上都是相同的，不过是<strong>自变量取角频率还是频率的区别</strong>。</p>
<p>频率和角频率的关系为：<span class="math inline">\(w = 2 \pi \mu\)</span>，带入角频率傅里叶变换对可得：</p>
<ol type="1">
<li><p>傅里叶变换 <span class="math display">\[
 F(w) = F(2\pi \mu) = \int_{-\infty}^{\infty} f(t) e^{-j2\pi \mu t} \text{d}t = F&#39;(\mu)
 \]</span></p></li>
<li><p>傅里叶逆变换 <span class="math display">\[
 \begin{align}
 f(t) &amp;= \frac{1}{2\pi} \int_{-\infty}^{\infty} 
 F(w) e^{jwt} \text{d} w \\
 &amp;= \frac{1}{2\pi} \int_{-\infty}^{\infty} 
 F(2\pi \mu) e^{j2\pi \mu t} \text{d} (2\pi \mu) \\
 &amp;= \int_{-\infty}^{\infty} 
 F&#39;(\mu) e^{j2\pi \mu t} \text{d} \mu
 \end{align}
 \]</span></p></li>
</ol>
<p>即： $$ <span class="math display">\[\begin{align}
F(\mu) &amp;= \int_{-\infty}^{\infty} f(t) e^{-j2\pi \mu t} \text{d}t \\
f(t) &amp;= \int_{-\infty}^{\infty} 
F(\mu) e^{j2\pi \mu t} \text{d} \mu

\end{align}\]</span> $$</p>
<h2 id="总结">总结</h2>
<p>本文给出了傅里叶变换对的频率与角频率形式，以及从傅里叶级数出发推导傅里叶变换的方法，但不是很严谨，只能是说给出了一个思路，傅里叶变换其实为傅里叶级数拓展到无穷周期的表示。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
      </categories>
      <tags>
        <tag>傅里叶变换</tag>
        <tag>信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>《30天自制操作系统》 05-08部分 从字符显示到中断处理</title>
    <url>/2020/02/09/2020-02-09-30OSMakeNote05-08/</url>
    <content><![CDATA[<h2 id="文字鼠标显示">1. 文字鼠标显示</h2>
<h3 id="a.-定义bootinfo结构体">a. 定义BOOTINFO结构体</h3>
<blockquote>
<p>这个结构体包含操作系统的基础信息</p>
</blockquote>
<a id="more"></a>
<p>结构体声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BOOTINFO</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> cyls, leds, vmode, reserve;</span><br><span class="line">	<span class="keyword">short</span> scrnx, scrny;</span><br><span class="line">	<span class="keyword">char</span> *vram;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应的信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; asmhead.nas</span><br><span class="line">; BOOT_INFO相关</span><br><span class="line">CYLS	EQU		0x0ff0			; 引导扇区设置</span><br><span class="line">LEDS	EQU		0x0ff1</span><br><span class="line">VMODE	EQU		0x0ff2			; 关于颜色的信息</span><br><span class="line">SCRNX	EQU		0x0ff4			; 分辨率X</span><br><span class="line">SCRNY	EQU		0x0ff6			; 分辨率Y</span><br><span class="line">VRAM	EQU		0x0ff8			; 图像缓冲区的起始地址</span><br><span class="line">		ORG		0xc200			;  这个的程序要被装载的内存地址</span><br><span class="line"></span><br><span class="line">; 画面设定</span><br><span class="line"></span><br><span class="line">		MOV		AL,0x13			; VGA显卡，320x200x8bit</span><br><span class="line">		MOV		AH,0x00</span><br><span class="line">		INT		0x10</span><br><span class="line">		MOV		BYTE [VMODE],8	; 屏幕的模式（参考C语言的引用）</span><br><span class="line">		MOV		WORD [SCRNX],320</span><br><span class="line">		MOV		WORD [SCRNY],200</span><br><span class="line">		MOV		DWORD [VRAM],0x000a0000		</span><br></pre></td></tr></table></figure>
<p>作者没有对<code>BOOTINFO.reserve</code>说明，仔细看<code>asmhead.nas</code>可以发现VMODE只有一个字节的内容，但是<code>SCRNX</code>是从<code>0xff4</code>开始，中间有一个字节是没有做任何设定的，由此可以看出这一个字节的内容是暂时保留的。</p>
<p>启动信息的开始地址是0xff0，所以我们通过<code>struct BOOTINFO *binfo = (struct BOOTINFO *) 0x0ff0;</code>设置好我们的结构体。</p>
<h3 id="b.-字符和鼠标指针显示">b. 字符和鼠标指针显示</h3>
<p>简单来说，和之前我们绘制矩形一样的思路，整个屏幕都是就是一个<code>320*200</code>大小的一个画布，需要显示字符只要将对应位置置为一个颜色就可以了，如下</p>
<p><img src="/assets/Note/30DaysOs/05_1.png" style="zoom:50%;" /></p>
<p>其中每一个1代表此处应该置为一个对应颜色，此时的字体大小为16*8</p>
<p>作者给出的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只是将位为1的位置置为对应的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putfont8</span><span class="params">(<span class="keyword">char</span> *vram, <span class="keyword">int</span> xsize, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span> c, <span class="keyword">char</span> *font)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> *p, d <span class="comment">/* data */</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">		p = vram + (y + i) * xsize + x;</span><br><span class="line">		d = font[i];</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x80</span>) != <span class="number">0</span>) &#123; p[<span class="number">0</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x40</span>) != <span class="number">0</span>) &#123; p[<span class="number">1</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x20</span>) != <span class="number">0</span>) &#123; p[<span class="number">2</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x10</span>) != <span class="number">0</span>) &#123; p[<span class="number">3</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x08</span>) != <span class="number">0</span>) &#123; p[<span class="number">4</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x04</span>) != <span class="number">0</span>) &#123; p[<span class="number">5</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x02</span>) != <span class="number">0</span>) &#123; p[<span class="number">6</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x01</span>) != <span class="number">0</span>) &#123; p[<span class="number">7</span>] = c; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作者给出了他为每一个字符定义的字体，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hankaku.txt</span></span><br><span class="line"><span class="comment">// 此文件通过作者的 makefont.exe编译为目标文件</span></span><br><span class="line"><span class="comment">// 只是将其中的字体文件解析相应的字节数据</span></span><br><span class="line"><span class="keyword">char</span> <span class="number">0x41</span></span><br><span class="line">........</span><br><span class="line">...**...</span><br><span class="line">...**...</span><br><span class="line">...**...</span><br><span class="line">...**...</span><br><span class="line">..*..*..</span><br><span class="line">..*..*..</span><br><span class="line">..*..*..</span><br><span class="line">..*..*..</span><br><span class="line">.******.</span><br><span class="line">.*....*.</span><br><span class="line">.*....*.</span><br><span class="line">.*....*.</span><br><span class="line">***..***</span><br><span class="line">........</span><br><span class="line">........</span><br></pre></td></tr></table></figure>
<p>因为这是外部定义的数据，所以在我们的C语言源文件中，需要使用的话需要增加 <strong><em>extern char hankaku[4096];</em></strong></p>
<p>字符串的显示也类似处理即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putfonts8_asc</span><span class="params">(<span class="keyword">char</span> *vram, <span class="keyword">int</span> xsize, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span> c, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">char</span> hankaku[<span class="number">4096</span>];</span><br><span class="line">	<span class="keyword">for</span> (; *s != <span class="number">0x00</span>; s++) &#123;</span><br><span class="line">		putfont8(vram, xsize, x, y, c, hankaku + *s * <span class="number">16</span>);</span><br><span class="line">		x += <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鼠标的显示也是类似的，不过作者定义了一个16*16大小的指针，作者这个鼠标太没有美感了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_mouse_cursor8</span><span class="params">(<span class="keyword">char</span> *mouse, <span class="keyword">char</span> bc)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* マウスカーソルを準備（16x16） */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> cursor[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">		<span class="string">&quot;**************..&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOOOOOOOOO*...&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOOOOOOOO*....&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOOOOOOO*.....&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOOOOOO*......&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOOOOO*.......&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOOOOO*.......&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOOOOOO*......&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOO**OOO*.....&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOO*..*OOO*....&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OO*....*OOO*...&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*O*......*OOO*..&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**........*OOO*.&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*..........*OOO*&quot;</span>,</span><br><span class="line">		<span class="string">&quot;............*OO*&quot;</span>,</span><br><span class="line">		<span class="string">&quot;.............***&quot;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">16</span>; y++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">16</span>; x++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cursor[y][x] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">				mouse[y * <span class="number">16</span> + x] = COL8_000000;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (cursor[y][x] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">				mouse[y * <span class="number">16</span> + x] = COL8_FFFFFF;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (cursor[y][x] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">				mouse[y * <span class="number">16</span> + x] = bc;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在https://www.cnblogs.com/bitzhuwei/p/OS-in-30-days-05-initialize-keyboard-and-mouse.html有人给出了一个更好看的鼠标，更加符合Windows风格的鼠标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> cursor[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	<span class="string">&quot;*...............&quot;</span>,</span><br><span class="line">	<span class="string">&quot;**..............&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*O*.............&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OO*............&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OOO*...........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OOOO*..........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OOOOO*.........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OOOOOO*........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OOOOOOO*.......&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OOOO*****......&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OO*O*..........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*O*.*O*.........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;**..*O*.........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*....*O*........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;.....*O*........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;......*.........&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后的效果图如下：</p>
<p><img src="/assets/Note/30DaysOs/05_2.png" style="zoom:50%;" /></p>
<h2 id="gdtidt初始化">2. GDT/IDT初始化</h2>
<h3 id="a.-gdtidt基础">a. GDT/IDT基础</h3>
<p>所谓分段，简单来说就是把4GB的内存切分为很多的块，每一块的起始地址都可以看作0来处理，这样子对我们写程序就十分的方便，通过<code>DS:EBX</code>获取对应的地址，在32位模式（保护模式）下，需要对GDT（global（segment） descriptor table 全局段号记录表）进行相应的配置。（这里DS：EBX是作者给出的32位寻址方式，但是有32位的EDS也可以作为寄存器，我怀疑是否是进行了DS和GDT之间的一个映射）</p>
<p>表示一个段需要有以下几个信息:</p>
<ul>
<li>段的大小是多少</li>
<li>段的起始地址在哪里</li>
<li>段的管理属性（禁止写入， 禁止执行， 系统专用等）</li>
</ul>
<p>CPU使用8个字节的数据来表示这些信息，用于指定段的寄存器只有16位。 或许有人会猜想在32位模式下， 段寄存器会扩展到64位， 但事实上段寄存器仍然是16位。那该怎么办才好呢？ 可以模仿图像调色板的做法。 也就是说， 先有一个段号4， 存放在段寄存器里。 然后预先设定好段号与段的对应关系。</p>
<p>段寄存器是16位，但由于CPU设计上的原因，段寄存器的低三位不能够使用（作者也没有表明是用作什么用），所以我们只有13位的段号，范围是0~8191，所以我们需要把8192*8 = 64KB的数据写到内存的对应位置，这一部分的数据就是GDT了。</p>
<p>相应的IDT（interrupt descriptor table 中断记录表）是实现操作系统中断功能必需的。IDT记录了0~255的中断号码与调用函数之间的对应关系，设定方法和GDT十分类似，在对IDT设置之前必须进行GDT的设定。</p>
<h3 id="b.-gdtidt设置">b. GDT/IDT设置</h3>
<p>部分摘自：</p>
<p>https://blog.csdn.net/misskissC/article/details/100593986 (haribote dsctbl.c 设置GDT和IDT程序阅读注释)</p>
<p>IDT 描述符可参考：https://blog.csdn.net/fwqcuc/article/details/5855460</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">base指的是32位的基地址，在这里分为了low,mid,high三个部分，这里分为3段主要是和80286时代的程序相兼容</span></span><br><span class="line"><span class="comment">limit是指段上限，表示这个段有多少字节</span></span><br><span class="line"><span class="comment">段上限分为高低，但是只有20位，这里看上去有3个字节但是limit_high的高四位用于保存段属性</span></span><br><span class="line"><span class="comment">limit_high的高四位和access_right这12位是段属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEGMENT_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">short</span> limit_low, base_low;</span><br><span class="line">    <span class="keyword">char</span> base_mid, access_right;</span><br><span class="line">    <span class="keyword">char</span> limit_high, base_high;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">offset_high&amp;&amp;offset_low,</span></span><br><span class="line"><span class="comment">中断或异常处理程序在其所在内存段中的偏移;</span></span><br><span class="line"><span class="comment">selector,处理程序所在内存段的段选择符;</span></span><br><span class="line"><span class="comment">dw_count,保留未用;</span></span><br><span class="line"><span class="comment">access_right,IDT描述符有效位,特权级(DPL),类型(TYPE)等属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GATE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">short</span> offset_low, selector;</span><br><span class="line">    <span class="keyword">char</span> dw_count, access_right;</span><br><span class="line">    <span class="keyword">short</span> offset_high;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_gdtidt</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0x270000~0x27ffff设为GDT，将此处设置为地址并没有特别的意义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SEGMENT_DESCRIPTOR</span> *<span class="title">gdt</span> =</span> (struct SEGMENT_DESCRIPTOR *)<span class="number">0x00270000</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GATE_DESCRIPTOR</span> *<span class="title">idt</span> =</span> (struct GATE_DESCRIPTOR *)<span class="number">0x0026f800</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/* GDT的初始化 这里只是简单的全部初始化为1*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8192</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set_segmdesc(gdt + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置1，2两个段1代表的是整个内存，2保留的是我们的bootpack.hrb</span></span><br><span class="line">    set_segmdesc(gdt + <span class="number">1</span>, <span class="number">0xffffffff</span>, <span class="number">0x00000000</span>, <span class="number">0x4092</span>);</span><br><span class="line">    set_segmdesc(gdt + <span class="number">2</span>, <span class="number">0x0007ffff</span>, <span class="number">0x00280000</span>, <span class="number">0x409a</span>);</span><br><span class="line">    <span class="comment">// gdtr保存的是GDT的首地址，修改寄存器需要使用汇编，所以定义在naskfunc.nas</span></span><br><span class="line">    <span class="comment">// 下面这个函数就是设置段上限和起始地址</span></span><br><span class="line">    <span class="comment">// _load_gdtr: ; void load_gdtr(int limit, int addr);</span></span><br><span class="line">    <span class="comment">//     MOV AX,[ESP+4] ; limit</span></span><br><span class="line">    <span class="comment">//     MOV [ESP+6],AX</span></span><br><span class="line">    <span class="comment">//     LGDT [ESP+6]    ; 从ESP+6处读取6个字节内容</span></span><br><span class="line">    <span class="comment">//     RET</span></span><br><span class="line">    load_gdtr(<span class="number">0xffff</span>, <span class="number">0x00270000</span>);</span><br><span class="line">    <span class="comment">/* IDT的初始化 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set_gatedesc(idt + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    load_idtr(<span class="number">0x7ff</span>, <span class="number">0x0026f800</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_segmdesc,</span></span><br><span class="line"><span class="comment">设置sd指向的GDT段描述符,</span></span><br><span class="line"><span class="comment">sd,GDT段描述符内存首地址;limit,段描述符所描述内存段基于段基址最大偏移;</span></span><br><span class="line"><span class="comment">base,段描述符所描述内存段基址;ar,段描述符特权级,类型等属性。</span></span><br><span class="line"><span class="comment">ar格式为：xxxx0000xxxxxxxx 高四位存入limit_high的高四位低8位保存到access_right</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_segmdesc</span><span class="params">(struct SEGMENT_DESCRIPTOR *sd, <span class="keyword">unsigned</span> <span class="keyword">int</span> limit, <span class="keyword">int</span> base, <span class="keyword">int</span> ar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    高四位格式为GD00,G代表是否*4KB计算，D代表段的模式1为32位模式，0为16位</span></span><br><span class="line"><span class="comment">    如果超过1M大小则将G_bit置为1，此时CPU会将limit*4KB计算段上限</span></span><br><span class="line"><span class="comment">    ar的低8位有以下：</span></span><br><span class="line"><span class="comment">    00000000（0x00） ： 未使用的记录表（descriptor table） 。</span></span><br><span class="line"><span class="comment">    10010010（0x92） ： 系统专用， 可读写的段。 不可执行。</span></span><br><span class="line"><span class="comment">    10011010（0x9a） ： 系统专用， 可执行的段。 可读不可写。</span></span><br><span class="line"><span class="comment">    11110010（0xf2） ： 应用程序用， 可读写的段。 不可执行。</span></span><br><span class="line"><span class="comment">    11111010（0xfa） ： 应用程序用， 可执行的段。 可读不可写</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (limit &gt; <span class="number">0xfffff</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ar |= <span class="number">0x8000</span>; <span class="comment">/* G_bit = 1 */</span></span><br><span class="line">        limit /= <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据GDT段描述符位格式,通过GDT段描述符结构体设置GDT描述符。</span></span><br><span class="line"><span class="comment">    bit[15..0],内存段长度低16位;</span></span><br><span class="line"><span class="comment">    bit[31..16],内存段基址低16位;</span></span><br><span class="line"><span class="comment">    bit[39..32],内存段基址23..16位;</span></span><br><span class="line"><span class="comment">    bit[47..40],有效位P,特权级DPL,类型TYPE等;</span></span><br><span class="line"><span class="comment">    bit[55..48],内存颗粒度,内存段长度19..16位;</span></span><br><span class="line"><span class="comment">    bit[63..56],内存段基址高8位。    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sd-&gt;limit_low = limit &amp; <span class="number">0xffff</span>;</span><br><span class="line">    sd-&gt;base_low = base &amp; <span class="number">0xffff</span>;</span><br><span class="line">    sd-&gt;base_mid = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    sd-&gt;access_right = ar &amp; <span class="number">0xff</span>;</span><br><span class="line">    sd-&gt;limit_high = ((limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0f</span>) | ((ar &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xf0</span>);</span><br><span class="line">    sd-&gt;base_high = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_gatedesc,</span></span><br><span class="line"><span class="comment">设置gd指向的IDT描述符,</span></span><br><span class="line"><span class="comment">gd,IDT描述符内存首地址;offset,处理程序在其所在段的偏移地址;</span></span><br><span class="line"><span class="comment">selector,处理程序所在内存段的段选择符;ar,IDT描述符有效位,特权级,类型等属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_gatedesc</span><span class="params">(struct GATE_DESCRIPTOR *gd, <span class="keyword">int</span> offset, <span class="keyword">int</span> selector, <span class="keyword">int</span> ar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据IDT段描述符位格式,通过IDT描述符结构体设置IDT描述符。</span></span><br><span class="line"><span class="comment">    bit[15..0],处理程序偏移地址低16位;</span></span><br><span class="line"><span class="comment">    bit[31..16],处理程序所在内存段的段选择符;</span></span><br><span class="line"><span class="comment">    bit[39..32],保留未用;</span></span><br><span class="line"><span class="comment">    bit[47..40],有效位P,特权级DPL,类型TYPE等;</span></span><br><span class="line"><span class="comment">    bit[63..48],处理程序偏移地址高16位。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    gd-&gt;offset_low = offset &amp; <span class="number">0xffff</span>;</span><br><span class="line">    gd-&gt;selector = selector;</span><br><span class="line">    gd-&gt;dw_count = (ar &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    gd-&gt;access_right = ar &amp; <span class="number">0xff</span>;</span><br><span class="line">    gd-&gt;offset_high = (offset &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中断处理">3. 中断处理</h2>
<p>前面已经正确的将GDT以及IDT初始化完成了，要使用中断还需要初始化<strong><em>PIC（programmable interrupt controller 可编程中断控制器）</em></strong>，前面提到中断向量表IDT可以配置256个中断向量号，但是x86系列机提供15个可编程中断，其他中断大多是系统中断。</p>
<p>x86使用的是2片PIC（8259A）级联形成的15个可编程中断。如下图主IPC的2号中断和从IPC连接，所以一共只有15个中断。</p>
<p><img src="/assets/Note/30DaysOs/06_1.png" style="zoom:50%;" /></p>
<p>链接：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvbmdpbnRjaGFyL2FydGljbGUvZGV0YWlscy83OTQzOTQ2Ng==">8259A详细工作原理<i class="fa fa-external-link-alt"></i></span></p>
<p>PIC 初始化（对相关寄存器进行配置）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_pic</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* PIC初始化 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	io_out8(PIC0_IMR,  <span class="number">0xff</span>  ); <span class="comment">/* 禁止所有中断 */</span></span><br><span class="line">	io_out8(PIC1_IMR,  <span class="number">0xff</span>  ); <span class="comment">/* 禁止所有中断 */</span></span><br><span class="line"></span><br><span class="line">	io_out8(PIC0_ICW1, <span class="number">0x11</span>  ); <span class="comment">/* 边缘触发模式（edge trigger mode） */</span></span><br><span class="line">	io_out8(PIC0_ICW2, <span class="number">0x20</span>  ); <span class="comment">/* IRQ0-7由INT20-27接收 */</span></span><br><span class="line">	io_out8(PIC0_ICW3, <span class="number">1</span> &lt;&lt; <span class="number">2</span>); <span class="comment">/* PIC1由IRQ2相连 */</span></span><br><span class="line">	io_out8(PIC0_ICW4, <span class="number">0x01</span>  ); <span class="comment">/* 无缓冲区模式 */</span></span><br><span class="line"></span><br><span class="line">	io_out8(PIC1_ICW1, <span class="number">0x11</span>  ); <span class="comment">/* 边缘触发模式（edge trigger mode） */</span></span><br><span class="line">	io_out8(PIC1_ICW2, <span class="number">0x28</span>  ); <span class="comment">/* IRQ8-15由INT28-2f接收 */</span></span><br><span class="line">	io_out8(PIC1_ICW3, <span class="number">2</span>     ); <span class="comment">/* PIC1由IRQ2连接 */</span></span><br><span class="line">	io_out8(PIC1_ICW4, <span class="number">0x01</span>  ); <span class="comment">/* 无缓冲区模式 */</span></span><br><span class="line"></span><br><span class="line">	io_out8(PIC0_IMR,  <span class="number">0xfb</span>  ); <span class="comment">/* 11111011 PIC1以外全部禁止 */</span></span><br><span class="line">	io_out8(PIC1_IMR,  <span class="number">0xff</span>  ); <span class="comment">/* 11111111 禁止所有中断 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<strong>ICW2</strong>我们实现将IRQ和INT号相绑定</p>
<p>大家可能会对此有兴趣， 所以再详细介绍一下。 中断发生以后， 如果CPU可以受理这个中断， CPU就会命令PIC发送2个字节的数据。 这2个字节是怎么传送的呢？ CPU与PIC用IN或OUT进行数据传送时， 有数据信号线连在一起。 PIC就是利用这个信号线发送这2个字节数据的。 送过来的数据是“0xcd 0x??”这两个字节。 由于电路设计的原因， 这两个字节的数据在CPU看来， 与从内存读进来的程序是完全一样的， 所以CPU就把送过来的“0xcd 0x??”作为机器语言执行。这恰恰就是把数据当作程序来执行的情况。 这里的0xcd就是调用BIOS时使用的那个INT指令。 我们在程序里写的“INT 0x10”， 最后就被编译成了“0xcd0x10”。 所以， CPU上了PIC的当， 按照PIC所希望的中断号执行了INT指令。</p>
<p>注意这里的IRQ全部绑定到了INT 20开始的位置，PIC的中断一般默认都是设置在此位置，其他的中断号一般是为其他类型的中断准备的。</p>
<p><strong>鼠标是IRQ12， 键盘是IRQ1，对应的INT是于INT 0x2c和INT 0x21。</strong>这似乎是规定好的。</p>
<p>中断与函数跳转很相似，但是需要IRETD作为中断返回的标志，这个指令不能使用C语言编写，所以需要汇编的帮助。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;因为inthandler21定义在别的文件所以要加上extern</span><br><span class="line">EXTERN	_inthandler21</span><br><span class="line">_asm_inthandler21:</span><br><span class="line">		PUSH	ES</span><br><span class="line">		PUSH	DS</span><br><span class="line">		PUSHAD</span><br><span class="line">		MOV		EAX,ESP</span><br><span class="line">		PUSH	EAX</span><br><span class="line">		MOV		AX,SS</span><br><span class="line">		MOV		DS,AX</span><br><span class="line">		MOV		ES,AX</span><br><span class="line">		CALL	_inthandler21</span><br><span class="line">		POP		EAX</span><br><span class="line">		POPAD</span><br><span class="line">		POP		DS</span><br><span class="line">		POP		ES</span><br><span class="line">		IRETD</span><br></pre></td></tr></table></figure>
<p>关于在DS和ES中放入SS值的部分， 因为C语言自以为是地认为“DS也好， ES也好，SS也好， 它们都是指同一个段”， 所以如果不按照它的想法设定的话， 函数inthandler21就不能顺利执行。 所以， 虽然麻烦了一点， 但还是要这样做。</p>
<p>然后我们只需要对<code>inthandler21</code>和其他类似的中断函数进行编写了</p>
<p>通过<code>set_gatedesc</code>配置中断记录表，这个函数在前面提到过</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// INT 21键盘中断</span></span><br><span class="line">set_gatedesc(idt + <span class="number">0x21</span>, (<span class="keyword">int</span>) asm_inthandler21, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">INT 27 IRQ中断</span></span><br><span class="line"><span class="comment">PIC0中断的不完整策略</span></span><br><span class="line"><span class="comment">这个中断在Athlon64X2上通过芯片组提供的便利，只需执行一次</span></span><br><span class="line"><span class="comment">这个中断只是接收，不执行任何操作</span></span><br><span class="line"><span class="comment">为什么不处理？</span></span><br><span class="line"><span class="comment">	→  因为这个中断可能是电气噪声引发的、只是处理一些重要的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">set_gatedesc(idt + <span class="number">0x27</span>, (<span class="keyword">int</span>) asm_inthandler27, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br><span class="line"><span class="comment">// INT 2c鼠标中断</span></span><br><span class="line">set_gatedesc(idt + <span class="number">0x2c</span>, (<span class="keyword">int</span>) asm_inthandler2c, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br></pre></td></tr></table></figure>
<h3 id="fifo-缓冲配置">FIFO 缓冲配置</h3>
<p>中断几乎是无时无刻不再发生的，处理一个中断的过程中可能有其他中断发生，所以我们需要把处理中断的程序编写的越短越好（操作系统中中断是有优先级的，这里作者并没有明确的说明）</p>
<p>所以在我们处理键盘鼠标这类外部设备的中断时，获取到数据之后不用急忙处理，而是将其放置到一个缓冲区中，等到之后处理。这个缓冲区的大小和其他设计很值得考量。作者给出了一个FIFO缓冲区的实现:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* FIFO */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bootpack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAGS_OVERRUN		0x0001</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fifo8_init</span><span class="params">(struct FIFO8 *fifo, <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 初始化FIFO缓冲区 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fifo-&gt;size = size;</span><br><span class="line">	fifo-&gt;buf = buf;</span><br><span class="line">	fifo-&gt;<span class="built_in">free</span> = size; <span class="comment">/* 缓冲区大小 */</span></span><br><span class="line">	fifo-&gt;flags = <span class="number">0</span>;</span><br><span class="line">	fifo-&gt;p = <span class="number">0</span>; <span class="comment">/* 下一个数据写入位置 */</span></span><br><span class="line">	fifo-&gt;q = <span class="number">0</span>; <span class="comment">/* 下一个数据读出位置 */</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fifo8_put</span><span class="params">(struct FIFO8 *fifo, <span class="keyword">unsigned</span> <span class="keyword">char</span> data)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 向FIFO传送数据并保存 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fifo-&gt;<span class="built_in">free</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* 没有空间了，溢出 */</span></span><br><span class="line">		fifo-&gt;flags |= FLAGS_OVERRUN;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;buf[fifo-&gt;p] = data;</span><br><span class="line">	fifo-&gt;p++;</span><br><span class="line">	<span class="keyword">if</span> (fifo-&gt;p == fifo-&gt;size) &#123;</span><br><span class="line">		fifo-&gt;p = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;<span class="built_in">free</span>--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fifo8_get</span><span class="params">(struct FIFO8 *fifo)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 从FIFO取得一个数据 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">if</span> (fifo-&gt;<span class="built_in">free</span> == fifo-&gt;size) &#123;</span><br><span class="line">		<span class="comment">/* 如果缓冲区为空则返回-1 */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	data = fifo-&gt;buf[fifo-&gt;q];</span><br><span class="line">	fifo-&gt;q++;</span><br><span class="line">	<span class="keyword">if</span> (fifo-&gt;q == fifo-&gt;size) &#123;</span><br><span class="line">		fifo-&gt;q = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;<span class="built_in">free</span>++;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fifo8_status</span><span class="params">(struct FIFO8 *fifo)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 报告一下积攒是数据量 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fifo-&gt;size - fifo-&gt;<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现还是比较容易的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inthandler21</span><span class="params">(<span class="keyword">int</span> *esp)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 来自PS/2键盘的中断 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BOOTINFO</span> *<span class="title">binfo</span> =</span> (struct BOOTINFO *) ADR_BOOTINFO;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> data, s[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">/* 通知PIC IRQ-01 已经受理完毕 否则不处理下一次中断 */</span></span><br><span class="line">	io_out8(PIC0_OCW2, <span class="number">0x61</span>);</span><br><span class="line">	data = io_in8(PORT_KEYDAT);</span><br><span class="line">	fifo8_put(&amp;keyfifo, data);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在<code>inthandler21</code>里面只需要对数据保存即可，然后在<code>bootpack.c</code>主循环中显示对应的信息即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bootpack.c</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		io_cli();</span><br><span class="line">		<span class="keyword">if</span> (fifo8_status(&amp;keyfifo) + fifo8_status(&amp;mousefifo) == <span class="number">0</span>) &#123;</span><br><span class="line">			io_stihlt();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (fifo8_status(&amp;keyfifo) != <span class="number">0</span>) &#123;</span><br><span class="line">				i = fifo8_get(&amp;keyfifo);</span><br><span class="line">				io_sti();</span><br><span class="line">				<span class="built_in">sprintf</span>(s, <span class="string">&quot;%02X&quot;</span>, i);</span><br><span class="line">				boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484,  <span class="number">0</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">31</span>);</span><br><span class="line">				putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, <span class="number">0</span>, <span class="number">16</span>, COL8_FFFFFF, s);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fifo8_status(&amp;mousefifo) != <span class="number">0</span>) &#123;</span><br><span class="line">				i = fifo8_get(&amp;mousefifo);</span><br><span class="line">				io_sti();</span><br><span class="line">				<span class="built_in">sprintf</span>(s, <span class="string">&quot;%02X&quot;</span>, i);</span><br><span class="line">				boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, <span class="number">32</span>, <span class="number">16</span>, <span class="number">47</span>, <span class="number">31</span>);</span><br><span class="line">				putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, <span class="number">32</span>, <span class="number">16</span>, COL8_FFFFFF, s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对鼠标的操作也是类似的</p>
<h2 id="鼠标控制">4. 鼠标控制</h2>
<p>参考代码解释：<span class="exturl" data-url="aHR0cHM6Ly93d3cudHdibG9ncy5uZXQvYS81ZDczN2YxOWJkOWVlZTUzMjdmZjdmNjQvemgtY24=">粗略阅读haribote鼠标管理程序 mouse.c<i class="fa fa-external-link-alt"></i></span></p>
<p>要使鼠标中断可以被CPU响应，除了配置中断记录表还需要执行激活鼠标的指令，所以我们需要配置两个装置，一个是鼠标控制电路，一个是鼠标本身。鼠标控制电路包含在键盘控制电路中，只要键盘控制电路初始化完成，鼠标电路控制器也就激活完成了。</p>
<p>键盘电路初始化代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT_KEYDAT 0x0060</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT_KEYSTA 0x0064</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT_KEYCMD 0x0064</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYSTA_SEND_NOTREADY 0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYCMD_WRITE_MODE 0x60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KBC_MODE 0x47</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_KBC_sendready</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    等待键盘控制电路准备完毕</span></span><br><span class="line"><span class="comment">    因为键盘控制电路的工作没有CPU快，需要循环判断是否准备好</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((io_in8(PORT_KEYSTA) &amp; KEYSTA_SEND_NOTREADY) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_keyboard</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化键盘控制电路 */</span></span><br><span class="line">    wait_KBC_sendready();</span><br><span class="line">    io_out8(PORT_KEYCMD, KEYCMD_WRITE_MODE);</span><br><span class="line">    wait_KBC_sendready();</span><br><span class="line">    io_out8(PORT_KEYDAT, KBC_MODE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在之前的键盘程序上并没有对键盘进行初始化（感觉是默认初始化的），在初始化后就可以激活鼠标了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYCMD_SENDTO_MOUSE 0xd4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOUSECMD_ENABLE 0xf4</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个函数与init_keyboard函数非常相似。 不同点仅在于写入的数据不同。 如果往键</span></span><br><span class="line"><span class="comment">盘控制电路发送指令0xd4， 下一个数据就会自动发送给鼠标。 我们根据这一特性来</span></span><br><span class="line"><span class="comment">发送激活鼠标的指令。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_mouse</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 激活鼠标 */</span></span><br><span class="line">    wait_KBC_sendready();</span><br><span class="line">    io_out8(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE);</span><br><span class="line">    wait_KBC_sendready();</span><br><span class="line">    io_out8(PORT_KEYDAT, MOUSECMD_ENABLE);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* 顺利的话,键盘控制其会返送回ACK(0xfa)*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>激活过程很简单，只是对相应的端口输出数据即可，<strong>鼠标一旦激活就会返回发送一个0xfa的答复信息</strong></p>
<p>接下来就是从鼠标获取数据了，因为和键盘共用一个控制电路，所以获取数据的代码很类似，两者是通过中断号区分的。<strong>由于12号IRQ在从片上所以需要告知从片受理完成</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FIFO8</span> <span class="title">mousefifo</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inthandler2c</span><span class="params">(<span class="keyword">int</span> *esp)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 来自PS/2鼠标的中断 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data;</span><br><span class="line">    io_out8(PIC1_OCW2, <span class="number">0x64</span>); <span class="comment">/* 通知PIC1 IRQ-12的受理已经完成 */</span></span><br><span class="line">    io_out8(PIC0_OCW2, <span class="number">0x62</span>); <span class="comment">/* 通知PIC0 IRQ-02的受理已经完成 */</span></span><br><span class="line">    data = io_in8(PORT_KEYDAT);</span><br><span class="line">    fifo8_put(&amp;mousefifo, data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鼠标信息由三个字节的数据构成，而且需要丢弃掉鼠标激活时发送的<code>0xfa</code>，其他便比较简单了，作者构建了一个鼠标缓冲，当接收到完整的三个字节后重新打印鼠标，实现鼠标的移动</p>
<p><strong>鼠标返回的数据主要由鼠标按键信息，垂直和水平偏移量构成，主要注意鼠标的坐标系和屏幕是上下颠倒的</strong></p>
<p>具体处理信息和鼠标三字节结构体字节分配在下面的链接中有很详细的说明</p>
<p>具体代码实现过程见：https://www.twblogs.net/a/5d737f19bd9eee5327ff7f64/zh-cn</p>
<p>但是没有处理画面叠加的问题，所以会有鼠标涂抹掉其他画面，第八天的<strong><em>通往32位模式之路</em></strong>放到下一次笔记</p>
<p>效果图如下：</p>
<p><img src="/assets/Note/30DaysOs/08_1.gif" alt="效果图" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>30天自制操作系统</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络自顶向下 第6版 阅读笔记</title>
    <url>/2020/03/02/2020-03-02-Compute-Networking-A-Top-Down-Approach-6th/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Ryb3k5MjIvQ29tcHV0ZXItTmV0d29yay9ibG9iL21hc3Rlci/orqHnrpfmnLrnvZHnu5zoh6rpobblkJHkuIvmlrnms5XnrZTmoYgo6Iux5paH56ys5YWt54mIKS5wZGY=">书本配套答案<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>Github：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dlaWp1bi1MaW4vTm90ZXMvdHJlZS9tYXN0ZXIvQ29tcHV0ZS1OZXR3b3JraW5nLUEtVG9wLURvd24tQXBwcm9hY2gtNnRo">笔记-计算机网络自顶向下 第6版<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<a id="more"></a>
<h2 id="chapter-1-计算机网络和因特网">Chapter 1 计算机网络和因特网</h2>
<h3 id="网络边缘">1. 网络边缘</h3>
<h4 id="物理媒介">物理媒介</h4>
<p>分为两类：导引型（guided media），非导引型（unguided media）</p>
<ul>
<li>双绞铜线（Twisted-Pair Copper Wire）</li>
<li>同轴电缆（Coaxial Cable）</li>
<li>光纤（Fiber Optics）</li>
<li>陆地无线电信道（Terrestrial Radio Channels）</li>
<li>卫星无线电信道（Satellite Radio Channel）</li>
</ul>
<h3 id="网络核心">*2. 网络核心</h3>
<blockquote>
<p>the mesh of packet switches and links that interconnects the Internet’s end systems</p>
</blockquote>
<h4 id="i.-packet-switching-分组交换">i. Packet Switching 分组交换</h4>
<blockquote>
<p>breaks <strong>long messages</strong> into smaller chunks of data known as <strong>packets</strong>. Between source and destination, each packet travels through <strong>communication links</strong> and <strong>packet switches</strong> (for which there are two predominant types, routers and linklayer switches)</p>
<p>Packets are transmitted over each communication link at a rate equal to the <strong>full transmission rate of the link.</strong></p>
</blockquote>
<h5 id="a.-store-and-forward-transmission-存储转发传输">a. Store-and-Forward Transmission 存储转发传输</h5>
<p>Store-and-forward transmission means that the packet switch <strong>must receive the entire packet before it can begin to transmit the first bit of the packet</strong> onto the outbound link.</p>
<p>P个分组经过N条链路，每一个分组大小是L，速率为R</p>
<p>端到端的时延是：<span class="math inline">\((N+P-1)\frac{L}{R}\)</span></p>
<h5 id="b.-queuing-delays-and-packet-loss">b. Queuing Delays and Packet Loss</h5>
<p>Packet Swith have a <strong>output buffer(output queue),</strong> which stores packets that the router is about to send into that link. In addition to the <strong>store-and-forward delays</strong>, packets suffer output buffer <strong>queuing delays</strong>. When the output buffer is full, <strong>packet loss</strong> will occur.</p>
<h5 id="c.-forwarding-tables-and-routing-protocols">c. Forwarding Tables and Routing Protocols</h5>
<p>each router has a <strong>forwarding table</strong> （转发表）that maps destination addresses (or portions of the destination addresses) to that router’s outbound links.</p>
<h4 id="ii.-circuit-switching-电路交换">ii. Circuit Switching 电路交换</h4>
<blockquote>
<p>the resources needed along <strong>a path (buffers, link transmission rate) to provide for communication between the end systems are reserved</strong> for the duration of the communication session between the end systems</p>
<p><strong>end-to-end</strong> connection</p>
</blockquote>
<h5 id="multiplexing-in-circuit-switched-networks">Multiplexing in Circuit-Switched Networks</h5>
<ul>
<li><p>frequency-division multiplexing (FDM) 频分复用 ：</p>
<p>The width of the range of frequency is called, not surprisingly, the <strong>bandwidth</strong>.</p></li>
<li><p>time-division multiplexing (TDM) 时分复用:</p>
<p>circuit switching is <strong>wasteful</strong> because the dedicated circuits are idle during <strong>silent periods</strong>(静默期)</p></li>
</ul>
<h4 id="iii.-packet-switching-versus-circuit-switching">iii. Packet Switching Versus Circuit Switching</h4>
<h5 id="packet-switching">Packet Switching</h5>
<ul>
<li>it offers better sharing of transmission capacity</li>
<li>it is simpler, more efficient, and less costly to implement</li>
<li>great for bursty data</li>
<li>but excessive congestion possible</li>
</ul>
<h5 id="circuit-switching">Circuit Switching</h5>
<ul>
<li>good for real-time serives</li>
<li>silent periods would cause time waste</li>
</ul>
<h4 id="iv.-a-network-of-networks">IV. A Network of Networks</h4>
<ul>
<li>ISP: 互联网服务提供商</li>
<li>IXP： Internet Exchange Point 因特网交换点 保证同级ISP对等（peering）</li>
<li>content provider networks：内容提供商网络</li>
</ul>
<h3 id="delay-loss-and-throughput">3. *Delay, Loss, and Throughput</h3>
<blockquote>
<p>in Packet-Switched Networks</p>
</blockquote>
<h4 id="types-of-delay">Types Of Delay</h4>
<ul>
<li><p><strong>nodal processing delay</strong>（节点处理时延）:</p>
<p>The time required to <strong>examine the packet’s header</strong> and <strong>determine where to direct the packet</strong> is part of the processing delay.</p></li>
<li><p><strong>Queuing Delay</strong>（排队时延）：</p>
<p>At the queue, the packet experiences a queuing delay as it waits to be transmitted onto the link.</p></li>
<li><p><strong>Transmission Delay</strong>（传输时延）：</p>
<p>Denote the length of the packet by L bits, and denote the transmission rate of the link from router A to router B by R bits/sec. The transmission delay is L/R</p></li>
<li><p><strong>Propagation Delay</strong>（传播时延）：</p>
<p>Once a bit is pushed into the link, it needs to propagate to router B. The time required to propagate from the beginning of the link to router B is the propagation delay</p></li>
</ul>
<h4 id="queuing-delay-and-packet-loss">Queuing Delay and Packet Loss</h4>
<ul>
<li><strong>traffic intensity</strong>（流量强度）： let <em>a</em> denote the <strong>average rate at which packets</strong> arrive at the queue (<em>a</em> is in units of packets/sec)（包到达平均速度）Recall that R is the transmission rate（传输速度）; Also suppose, for simplicity, that all packets consist of L bits. Then the average rate at which bits arrive at the queue is <em>La</em> bits/sec（包到达路由平均速度） The ratio <em>La/R</em>, called the traffic intensity. 保证流量强度&lt;=1才能正常工作</li>
<li><strong>Packet Loss</strong>（丢包）：With no place to store such a packet, a router will drop that packet; that is, the packet will be lost.</li>
</ul>
<h4 id="end-to-end-delay">End-to-End Delay</h4>
<p>suppose there are <strong>N - 1</strong> routers between the source host and the destination host</p>
<p>$ d_{end-end} = N(d_{proc}+d_{trans}+d_{prop})$</p>
<h4 id="throughput-in-computer-networks">Throughput in Computer Networks</h4>
<ul>
<li><strong>instantaneous throughput</strong>:at any instant of time is the rate (in bits/sec) at which Host B is receiving the file</li>
<li><strong>average throughput</strong>: For all file</li>
<li>the <strong>throughput</strong> depends not only on the transmission rates of the links along the path, but also on the intervening traffic</li>
</ul>
<h3 id="protocol-layers-and-their-service-models">4. Protocol Layers and Their Service Models</h3>
<h4 id="layered-architecture">Layered Architecture</h4>
<blockquote>
<p>Protocol layering has conceptual and structural advantages</p>
<p>the protocols of the various layers are called the <strong>protocol stack</strong></p>
</blockquote>
<p>Five-layer Internet protocol stack:</p>
<ol type="1">
<li><p><strong>Application Layer</strong>: HTTP</p>
<p>The application layer is where <strong>network applications and their application-layer protocols</strong> reside. this packet of information at the application layer as a <strong>message</strong>（报文）.</p></li>
<li><p><strong>Transport Layer</strong>：TCP UDP</p>
<p>The Internet’s transport layer transports application-layer messages between application endpoints. Transport-layer packet as a <strong>segment</strong>(报文段).</p>
<p>TCP guaranteed delivery of application-layer messages to the destination and flow control (that is, sender/receiver speed matching) But UDP not.</p></li>
<li><p><strong>Network Layer</strong>：IP</p>
<p>The Internet’s network layer is responsible for moving network-layer packets known as <strong>datagrams</strong> (数据报)from one host to another.</p></li>
<li><p><strong>Link Layer</strong>:</p>
<p>To move a packet from one node (host or router) to the next node in the route, the network layer relies on the services of the link layer. The services provided by the link layer depend on the <strong>specific link-layer protocol</strong>(特定链路层协议) that is employed over the link. refer to the linklayer packets as <strong>frames.</strong>（帧）</p></li>
<li><p><strong>Physical Layer</strong>：</p>
<p>the job of the physical layer is to <strong>move the individual bits</strong> within the frame from one node to the next.</p></li>
</ol>
<p><strong>OSI Model</strong>：</p>
<blockquote>
<p>There are application layer, presentation layer, session layer, transport layer, network layer, data link layer, and physical layer from up to down.</p>
</blockquote>
<ul>
<li><strong>presentation layer</strong> is to provide services that allow communicating applications to interpret the meaning of data exchanged. These services include <strong>data compression</strong> and <strong>data encryption</strong> as well as <strong>data description</strong>.</li>
<li><strong>The session layer</strong> provides for <strong>delimiting and synchronization of data exchange</strong>(数据交换和定界), including the means to build a checkpointing and recovery scheme.</li>
</ul>
<h4 id="encapsulation">Encapsulation</h4>
<p>we see that at each layer, a packet has two types of fields: <strong>header fields</strong>（首部字段） and a <strong>payload field</strong>（有效载荷字段）. The payload is typically a packet from the layer above.</p>
<p>In every layer, the layer encapsulates the data from last layer as payload field, then add its own header information, to build whole information.</p>
<h2 id="chapter-2-application-layer">Chapter 2 Application Layer</h2>
<blockquote>
<p>2.2 2.5 2.6 are important</p>
<p>DNS protocol not important</p>
<p>2.3 2.4-</p>
</blockquote>
<h3 id="principles-of-network-applications">1. Principles of Network Applications</h3>
<h4 id="i.-network-application-architectures">i. Network Application Architectures</h4>
<blockquote>
<p>two predominant（主要的） architectural paradigms used in modern network applications: the client-server architecture or the peer-to-peer (P2P) architecture</p>
</blockquote>
<ul>
<li><p><strong>the client-server architecture：</strong></p>
<p>client and server are separate and fixed, and they perform they own functions</p></li>
<li><p><strong>P2P architecture:</strong></p>
<p>Because the peers（对等方） communicate without passing through a dedicated（专用的） server, the architecture is called peer-to-peer. These peers can be server also can be clientz.</p>
<p>P2P is <strong>self-scalability and cost effective</strong>. And have three <strong>challenges</strong>: ISP Friendly, Security, Incentives（激励）.</p></li>
</ul>
<h4 id="ii.-processes-communicating">ii. Processes Communicating</h4>
<blockquote>
<p>In truth, server and client are just two process</p>
</blockquote>
<p>A process sends messages into, and receives messages from, the network through a software interface called a socket（套接字）. It is also referred to as the Application Programming Interface (API) between the application and the network</p>
<p>We use <strong>IP address and port number</strong> to do addressing process.</p>
<h4 id="iii.-transport-services-available-to-applications">iii. Transport Services Available to Applications</h4>
<ul>
<li>Reliable Data Transfer</li>
<li>Throughput</li>
<li>Timing</li>
<li>Security</li>
</ul>
<h4 id="iv.-transport-services-provided-by-the-internet">IV. Transport Services Provided by the Internet</h4>
<ul>
<li><p>TCP Servies</p>
<p>Connection-oriented service and Reliable data transfer service</p></li>
<li><p>UDP</p>
<p>UDP is a no-frills, lightweight transport protocol, providing minimal services. UDP is <strong>connectionless, unreliable</strong>. UDP provides <strong>no guarantee</strong> that the message will ever reach the receiving process. Furthermore, messages that do arrive at the receiving process may arrive <strong>out of order</strong>. And no congestion-control mechanism（拥塞机制）.</p></li>
</ul>
<h4 id="v.-services-not-provided-by-internet-transport-protocols">V. Services Not Provided by Internet Transport Protocols</h4>
<p>But in our brief description of TCP and UDP, conspicuously（明显的） missing was any mention of throughput or timing guarantees—services not provided by today’s Internet transport protocols.</p>
<h3 id="the-web-and-http">*2. The Web and HTTP</h3>
<h4 id="i.-overview-of-http">i. Overview of HTTP</h4>
<p>The <strong>HyperText Transfer Protocol (HTTP)</strong>, the Web’s application-layer protocol, is at the heart of the Web. . Because an HTTP server maintains no information about the clients, HTTP is said to be a <strong>stateless protocol</strong>（无状态协议）. We also remark that the <strong>Web uses the client-server application architecture,</strong></p>
<h4 id="ii.-non-persistent-and-persistent-connections">ii. Non-Persistent and Persistent Connections</h4>
<blockquote>
<p>Attention: 对多并发的例子中，线程之间对其他线程的连接一般是不可见的</p>
<p>流水线式不一定是绝对好的，本质是提高链路的利用率（充分利用带宽时延积）</p>
<p>先获取HTML然后在获取其它对象</p>
<ol type="1">
<li>可能会因为头包过大造成链路阻塞</li>
<li>返回必须按照接收顺序，已处理好的必须等前一个发送后才可以发送</li>
</ol>
</blockquote>
<ul>
<li><strong>non-persistent connections</strong>: each request/response pair be sent over a separate TCP connection</li>
<li><strong>persistent connections</strong>: all of the requests and their corresponding responses be sent over the same TCP connection，注意持久化一般是流水线</li>
</ul>
<p><strong>round-trip time (RTT 往返时延)</strong>：the time it takes for a small packet to travel from client to server and then back to the client</p>
<p><strong>the total response time:(总响应时间)</strong> two RTTs plus the transmission time at the server of the HTML file.</p>
<p>Non-persistent connections have some <strong>shortcomings</strong>.</p>
<ul>
<li>a brand-new connection must be established and maintained for each requested object.</li>
<li>each object suffers a delivery delay of two RTTs</li>
</ul>
<h4 id="iii.-http-message-format">iii. HTTP Message Format</h4>
<ol type="1">
<li><p>HTTP Request Message</p>
<ul>
<li>request line（请求行）: first line
<ul>
<li>method field: <strong>GET, POST</strong>, HEAD, PUT, and DELETE</li>
<li>URL field</li>
<li>HTTP Version field</li>
</ul></li>
<li>header line（首部行）: subsequent line
<ul>
<li>Host : specifies the host on which the object resides</li>
<li>Connection : whether use persistent connections</li>
<li>User-agent : specifies the user agent , that is, the browser type. This header line is useful because the server can actually send different versions of the same object to different types of user agents.</li>
<li>Accept-language: indicates that the user prefers language version</li>
<li>POST method: has an entity body for post data, but get also can do use work with saving data in URLs.</li>
</ul></li>
</ul></li>
<li><p>HTTP Request Message</p>
<ul>
<li><p>status line : first line</p>
<p>version + status code + phrase</p>
<ul>
<li>200 OK : succeeded</li>
<li>301 Moved Permanently : Requested object has been permanently moved and new URL will be returned</li>
<li>400 Bad Request : the request could not be understood by the server.</li>
<li>404 Not Found : The requested document does not exist on this server</li>
<li>505 HTTP Version Not Supported : ~~~</li>
</ul></li>
<li><p>header line: subsequent line :</p>
<ul>
<li>Connection : tell the client that whether close the TCP connection after sending the message</li>
<li>Date : <strong>indicates the time and date when the HTTP response was created and sent by the server</strong>. Note that this is not the time when the object was created or last modified; it is the time when the server retrieves the object from its file system, inserts the object into the response message, and sends the response message.</li>
<li>Server : analogous to the User-agent</li>
<li>Last-Modified : the time and date when the object was created or last modified</li>
<li>Content-Length : data size</li>
<li>Content-Type : data type such as HTML</li>
</ul></li>
<li><p>entity body : save data</p></li>
</ul></li>
</ol>
<h4 id="iv.-user-server-interaction-cookies">iv. User-Server Interaction: Cookies</h4>
<blockquote>
<p>cookies allow sites to keep track of users</p>
</blockquote>
<p>Cookie has four components:</p>
<ol type="1">
<li>a cookie header line in the HTTP <strong>response</strong> message</li>
<li>a cookie header line in the HTTP <strong>request</strong> message</li>
<li>a cookie file kept on the user’s end system and managed by the user’s <strong>browser</strong></li>
<li>a back-end database at <strong>the Web site</strong></li>
</ol>
<p>Although cookies often simplify the Internet shopping experience for the user, they are controversial because they can also be considered as an invasion of privacy</p>
<h4 id="v.-web-caching">V. Web Caching</h4>
<blockquote>
<p>A Web cache—also called a proxy server（代理服务器）—is a network entity that satisfies HTTP requests on the behalf of an origin Web server</p>
</blockquote>
<p>It works like this:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/web_cache_1.png" /></p>
<p>Note that a cache is <strong><em>both a server and a client</em></strong> at the same time.</p>
<p>Advantages:</p>
<ul>
<li><strong><em>A Web cache can substantially reduce the response time for a client request</em></strong>, particularly if the bottleneck bandwidth between the client and the origin server is much less than the bottleneck bandwidth between the client and the cache （加速）</li>
<li>Web caches can substantially reduce traffic on an institution’s access link to the Internet. So they does not have to upgrade bandwidth as quickly, thereby reducing costs. （减少通信量降低带宽不耗钱）</li>
<li>Web caches can substantially reduce Web traffic in the Internet as a whole, thereby improving performance for all applications. （降低网络流量，提高性能）</li>
</ul>
<p><strong>Content Distribution Networks (CDNs)</strong> （内容分发网络）: A CDN company installs many geographically distributed caches throughout the Internet, thereby localizing much of the traffic.</p>
<h4 id="vi.-the-conditional-get">VI. The Conditional GET</h4>
<blockquote>
<ul>
<li>the request message uses the GET method</li>
<li>the request message includes an <strong>If-ModifiedSince</strong>: header line</li>
</ul>
</blockquote>
<p>Use the conditional get to guarantee the file in proxy server is up to date.</p>
<h3 id="dnsthe-internets-directory-service">5. DNS—The Internet’s Directory Service</h3>
<blockquote>
<p>domain name system: a directory service that translates hostnames to IP addresses 53端口</p>
</blockquote>
<p>Definition:</p>
<ol type="1">
<li>a distributed database implemented in a hierarchy of DNS servers</li>
<li>an application-layer protocol that allows hosts to query the distributed database</li>
</ol>
<h4 id="i.-services-provided-by-dns">i. Services Provided by DNS</h4>
<ul>
<li>Host aliasing</li>
<li>Mail server aliasing</li>
<li>Load distribution（负载分配）（一个域名对应多个服务器IP）</li>
</ul>
<h4 id="ii.-overview-of-how-dns-works">ii. Overview of How DNS Works</h4>
<ul>
<li>centralized design: A simple design for DNS would have one DNS server that contains all the mappings
<ul>
<li>A single point of failure</li>
<li>Traffic volume</li>
<li>Distant centralized database</li>
<li>Maintenance</li>
</ul></li>
<li>distributed hierarchical design: uses a large number of servers, organized in a hierarchical fashion and distributed around the world
<ul>
<li>root DNS servers : In the Internet there are 13 root DNS servers</li>
<li>top-level domain (TLD) servers</li>
<li>authoritative DNS servers（权威域名服务器）: Every organization with publicly accessible hosts (such as Web servers and mail servers) on the Internet must provide publicly accessible DNS records that map the names of those hosts to IP addresses</li>
<li>local DNS server : A local DNS server does not strictly belong to the hierarchy of servers but is nevertheless central to the DNS architecture; When a host makes a DNS query, the query is sent to the local DNS server, which acts a proxy.
<ul>
<li>recursive：如果全部采用这种方式会给更服务器极大的压力</li>
<li>iterative</li>
</ul></li>
</ul></li>
</ul>
<h4 id="iv.-dns-records-and-messages">iv. DNS Records and Messages</h4>
<p>resource records (RRs): provide hostname-to-IP address mappings</p>
<p><strong>format : (Name, Value, Type, TTL)</strong></p>
<ul>
<li>Type = A : Name is a hostname and Value is the IP address for the hostname.</li>
<li>Type = NS : Name is a domain (such as foo.com) and Value is the hostname of an authoritative DNS server that knows how to obtain the IP addresses for hosts in the domain</li>
<li>Type = CNAME : Value is a canonical hostname for the alias hostname Name</li>
<li>Type = MX : Value is the canonical name of a mail server that has an alias hostname Name</li>
</ul>
<h3 id="电子邮件">电子邮件</h3>
<p>3个组成部分：用户代理，邮件服务器，SMTP</p>
<h4 id="smtp保存状态">SMTP(保存状态)</h4>
<p>25 号端口，简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。</p>
<h4 id="pop3">POP3</h4>
<p>Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议</p>
<h4 id="imap保存状态">IMAP（保存状态）</h4>
<p>Internet Mail Access Protocol，即交互式邮件存取协议</p>
<p>开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上</p>
<h3 id="ftp保存状态">FTP（保存状态）</h3>
<p>两个TCP连接，一个控制连接，一个控制数据连接（20，21端口）</p>
<h2 id="chapter-3-transport-layer">Chapter 3 Transport Layer</h2>
<blockquote>
<p>A transport-layer protocol provides for <strong>logical communication</strong> between application <strong><em>processes</em></strong> running on different hosts.</p>
<p>3.6 不做要求</p>
</blockquote>
<p>###　3.1 Introduction and Transport-Layer Services</p>
<h4 id="relationship-between-transport-and-network-layers">Relationship Between Transport and Network Layers</h4>
<p>transport layer lies just above the network layer in the protocol stack. Whereas a transport-layer protocol provides logical communication between <strong><em>processes</em></strong> running on different hosts, a network-layer protocol provides logical communication between <em>hosts</em>.</p>
<h4 id="overview-of-the-transport-layer-in-the-internet">Overview of the Transport Layer in the Internet</h4>
<ul>
<li><p>IP service model —— <strong>best-effort delivery service</strong></p>
<p>IP makes its “best effort” to deliver segments between communicating hosts, but it makes no guarantees. So IP is unreliable service.</p></li>
<li><p>multiplexing &amp; demultiplexing</p>
<p>Extending <strong>host-to-host</strong> delivery to <strong>process-to-process</strong> delivery</p></li>
<li><p>TCP</p>
<p><strong>reliable data transfer and provides congestion control</strong>. TCP congestion control prevents any one TCP connection from swamping the links and routers between communicating hosts with an excessive amount of traffic.</p></li>
</ul>
<h3 id="multiplexing-and-demultiplexing">3.2 Multiplexing and Demultiplexing</h3>
<p>a process can have one or more <strong><em>sockets</em></strong>, doors through which data passes from <strong>the network to the process</strong> and through which data passes from the process to the network.</p>
<ul>
<li><p>demultiplexing: delivering the data in a transport-layer segment to the correct socket</p></li>
<li><p>multiplexing:</p>
<p>gathering data chunks at the source host from <strong>different sockets</strong>, encapsulating each data chunk with header information (that will later be used in demultiplexing) to create segments, and passing the segments to the network layer</p></li>
</ul>
<p>Socket:</p>
<ol type="1">
<li>unique identifiers to identify UDP, TCP sockets</li>
<li>the <strong>source port number field</strong> and the <strong>destination port number field</strong></li>
</ol>
<p>the port number ranges from 0 to 65535 (16 bits to express), [0, 1024) is well-known port numbers</p>
<h4 id="connectionless-multiplexing-and-demultiplexing">Connectionless Multiplexing and Demultiplexing</h4>
<p>可能是因为UDP是无连接，而TCP是有连接的协议的区分</p>
<p>UDP socket is fully identified by a <strong>two-tuple</strong> consisting of a <strong>destination IP address and a destination port number</strong>.</p>
<h4 id="connection-oriented-multiplexing-and-demultiplexing">Connection-Oriented Multiplexing and Demultiplexing</h4>
<p>identified by four values:</p>
<ol type="1">
<li>the source port number in the segment</li>
<li>the IP address of the source host</li>
<li>the destination port number in the segment</li>
<li>its own IP address</li>
</ol>
<p>当一个UDP服务器接收到一个UDP报文段时，它会根据收到的UDP报文段的源IP和源端口号，把数据发送回客户端，它并不需要创建一个新的套接字来处理该报文段；</p>
<p>而对于一个TCP服务器，当它接受一个连接时，它会产生一个新的套接字，然后通过新的套接字来与客户端通信，也就是通过新的套接字来把数据发送回给客户端。由于每一个连接都会产生一个新的套接字，所以具有不同的源IP或源端口号的连接就是一个不同的连接，对应着产生的新的不同的套接字 原文链接：https://blog.csdn.net/ljianhui/article/details/21660629</p>
<h3 id="connectionless-transport-udp">3.3 Connectionless Transport: UDP</h3>
<ul>
<li><p><em>No connection state.</em> TCP maintains connection state in the end systems.</p></li>
<li><em>Small packet header overhead.</em> The TCP segment has 20 bytes of header over head in every segment, whereas UDP has only 8 bytes of overhead.</li>
<li><p>we mention that it is possible for an application to have reliable data transfer when using UDP. This can be done if reliability is built into the application itself</p></li>
</ul>
<h4 id="udp-segment-structure">UDP Segment Structure</h4>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_7.png" style="zoom:50%;" /></p>
<h4 id="udp-checksum">UDP Checksum</h4>
<p>UDP at the sender side performs the 1s complement of the sum of all the 16-bit words in the segment, with any overflow encountered during the sum being wrapped around(<strong>add the overflow bits with the sum</strong>)</p>
<h3 id="principles-of-reliable-data-transfer">3.4 Principles of Reliable Data Transfer</h3>
<h4 id="building-a-reliable-data-transfer-protocol">Building a Reliable Data Transfer Protocol</h4>
<ol type="1">
<li><p><strong>rdt1.0</strong></p>
<p>the underlying channel is completely reliable</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_9.png" style="zoom:50%;" /></p></li>
<li><p><strong>rdt2.0</strong>: Reliable Data Transfer over a Channel with Bit Errors</p></li>
</ol>
<p>an ARQ (Automatic Repeat reQuest) protocols</p>
<p>include RDT2.0-3, gbn, sr, tcp</p>
<ul>
<li><p>checksum</p></li>
<li><p>feedback (ACK,NAK)</p></li>
<li><p>resend</p></li>
</ul>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_10.png" style="zoom:50%;" /></p>
<ol start="3" type="1">
<li><p><strong>rdt2.1</strong>: can detect ACK or NAK errors based on 2.0</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_11.png" style="zoom:50%;" /> <img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_12.png" style="zoom:50%;" /></p></li>
<li><p><strong>rdt2.2</strong>: implement without NAK based on 2.1</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_13.png" style="zoom:50%;" /> <img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_14.png" style="zoom:50%;" /></p></li>
<li><p><strong>rdt3.0</strong>: Reliable Data Transfer over a Lossy Channel with Bit Errors</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_15.png" style="zoom:50%;" /></p></li>
</ol>
<h4 id="pipelined-reliable-data-transfer-protocols">Pipelined Reliable Data Transfer Protocols</h4>
<ol type="1">
<li><p>Stop&amp;Wait: rdt</p></li>
<li><p>PipeLine: gbn, sr, tcp in order.</p></li>
</ol>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_19.png" style="zoom:50%;" /></p>
<p>Example:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_22.png" style="zoom:50%;" /></p>
<p>The window size will move as long as getting the ACK.</p>
<p><strong>only a single timer</strong>, which can be thought of as a timer for the oldest transmitted but not yet acknowledged packet. If an ACK is received but there are still additional transmitted but not yet acknowledged packets, the timer is restarted. If there are no outstanding, unacknowledged packets, the timer is stopped.</p>
<ul>
<li><p><strong>Selective Repeat (SR)</strong></p>
<p>sequence-number space format:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_23.png" style="zoom:50%;" /></p>
<p>Actions in sender:</p>
<ol type="1">
<li>Data received from above</li>
<li>Timeout: <strong>each packet must now have its own logical timer</strong>, since only a single packet will be transmitted on timeout</li>
<li>ACK received: <strong>the windows will move right to the unacknowledged packet with the smallest sequence number</strong> when received the most left ACK</li>
</ol>
<p>The SR receiver will acknowledge a correctly received packet whether or not it is in order. Out-of-order packets are buffered until any missing packets (that is, packets with lower sequence numbers) are received, at which point a batch of packets can be delivered in order to the upper layer.</p>
<p>Actions in receiver:</p>
<ol type="1">
<li>Packet with sequence number in [rcv_base, rcv_base+N-1] is correctly received. In this case, the received packet falls within the receiver’s window and a selective ACK packet is returned to the sender. If the packet was not previously received, it is buffered. If this packet has a sequence number <strong>equal to the base of the receive window (rcv_base in Figure 3.22), then this packet, and any previously buffered and consecutively numbered (beginning with rcv_base)</strong> packets are delivered to the upper layer. The receive window is then moved forward by the number of packets delivered to the upper layer.</li>
<li>Packet with sequence number in [rcv_base-N, rcv_base-1] is correctly received. return an ACK</li>
</ol>
<p><strong>SR’s problem</strong>: can’t know <strong><em>a new packet or a retransmission?</em></strong></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_27.png" style="zoom:70%;" /></p>
<p>The solution of this problem: <strong><em>the window size must be less than or equal to half the</em></strong> <strong><em>size of the sequence number space for SR protocols.</em></strong></p></li>
</ul>
<p><strong>Summary:</strong></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/T3_1.png" style="zoom:70%;" /></p>
<h3 id="connection-oriented-transport-tcp">3.5 Connection-Oriented Transport: TCP</h3>
<p>GBN-SR 窗口不变, TCP 窗口可以变</p>
<h4 id="the-tcp-connection">The TCP Connection</h4>
<ul>
<li>connection-oriented</li>
<li>full-duplex service（全双工）</li>
<li>point-to-point</li>
<li>three-way handshake</li>
<li><strong>maximum segment size (MSS):</strong> The maximum amount of data that can be grabbed and placed in a segment</li>
<li><strong>maximum transmission unit (MTU):</strong> the length of the largest link-layer frame that can be sent by the local sending host</li>
</ul>
<h4 id="tcp-segment-structure">TCP Segment Structure</h4>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_29.png" style="zoom:50%;" /></p>
<ul>
<li><strong>Sequence Numbers(SEQ)</strong>: the byte-stream number of the first byte in the segment</li>
<li><strong>Acknowledgment Numbers(ACK)</strong>: Host A puts in its segment is the sequence number of the next byte Host A is expecting from Host B（想要的下一个序号）TCP is said to provide <strong>cumulative acknowledgments</strong></li>
</ul>
<p>Example：</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_31.png" style="zoom:50%;" /></p>
<h4 id="round-trip-time-estimation-and-timeout">Round-Trip Time Estimation and Timeout</h4>
<p>The sample RTT, denoted SampleRTT, for a segment is the amount of time between when the segment is sent (that is, passed to IP) and when an acknowledgment for the segment is received.</p>
<p>TCP never computes a SampleRTT for a segment that has been retransmitted; it only measures SampleRTT for segments that have been transmitted once.</p>
<ul>
<li>use <strong>exponential weighted moving average (EWMA)</strong> to estimate RTT</li>
</ul>
<p><span class="math inline">\(EstimatedRTT = (1 – \alpha) • EstimatedRTT + \alpha • SampleRTT\)</span></p>
<ul>
<li>In addition to having an estimate of the RTT, it is also valuable to have a measure of the variability of the RTT.</li>
</ul>
<p>$ DevRTT = (1 – ) • DevRTT + •┃ SampleRTT – EstimatedRTT ┃$</p>
<ul>
<li>use this formula the get RTT time</li>
</ul>
<p>$ TimeoutInterval = EstimatedRTT + 4 • DevRTT$</p>
<h4 id="reliable-data-transfer">Reliable Data Transfer</h4>
<ul>
<li><strong>Doubling the Timeout Interval</strong></li>
<li><strong>Fast Retransmit</strong>:In the case that three duplicate ACKs are received (except the first ACK)</li>
</ul>
<h4 id="flow-control">Flow Control</h4>
<p>TCP流控是因为应用层处理速度太慢了, 发送者和接收者的协调,拥塞是路由器和发送者</p>
<p>eliminate the possibility of the sender overflowing the receiver’s buffer. Flow control is thus a speed-matching service—matching the rate at which the sender is sending against the rate at which the receiving application is reading</p>
<p>TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制</p>
<p>A通过TCP连接向B发送一个大文件</p>
<ul>
<li>LastByteRead: 主机B上的应用程序进程从缓存独出的数据流的最后一个字节的编号</li>
<li>LastByteRevd: 网络到达已放入接收缓存的最后一个字节编号</li>
</ul>
<p>保持下式成立</p>
<p>$ LastByteRcvd-LastByteRead RevBuffer $</p>
<p>接收窗口用rwnd表示，可得 <span class="math inline">\(rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]\)</span></p>
<p>在发送方有 <span class="math inline">\(LastByteSent-LastByteAcked \le rwnd\)</span></p>
<p><strong>当主机B接收窗口为空时，主机A继续发送只有一个字节数据的报文段，避免A被阻塞的情况</strong></p>
<h4 id="tcp-connection-management">TCP Connection Management</h4>
<p>MSS在传输SYN时传输确定, TCP可以将包合并发就合并发, SYN 包要独占一个序列号 SYN：1.同步网络参数 2.同步序列号 FIN：表示不发了，但可以接收</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_39.png" style="zoom:50%;" /></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_40.png" style="zoom:50%;" /></p>
<h3 id="tcp-congestion-control">3.7 TCP Congestion Control</h3>
<p><strong>each side of a TCP connection</strong> consists of a <strong>receive buffer, a send buffer, and several variables</strong> (LastByteRead, rwnd, and so on). The TCP congestion-control mechanism operating at the sender keeps track of an additional variable, the congestion window. <strong>The congestion window</strong>, denoted cwnd, imposes a constraint on the rate at which a TCP sender can send traffic into the network.</p>
<p>TCP uses acknowledgments to trigger (or clock) its increase in congestion window size, TCP is said to be <strong>self-clocking</strong>.</p>
<p><strong>书本中的TCP标准遵循单一重传定时器的推荐</strong></p>
<p><strong>FSM</strong>：</p>
<p>对快速重传的快速恢复的cwnd有减半加三（考虑重传时没有拥塞）和不加三两种操作，这里采用不加三</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_52.png" style="zoom:70%;" /></p>
<p><strong>TCP congestion-control algorithm</strong>:</p>
<ol type="1">
<li><p>Slow Start</p>
<p><strong>begin with 1 MSS</strong> then <strong>doubling</strong> of the last sending rate every RTT until meets ssthresh or a loss, then enter congestion avoidance</p></li>
<li><p>congestion avoidance</p>
<p><strong>linear increase</strong> (of 1 MSS per RTT) until meet a loss, then <strong>set the ssthresh to half</strong> and enter fast recovery</p></li>
<li><p>fast recovery</p>
<p>两个版本在超时后都置为1, 丢包（快速重传）处理不一样</p>
<ul>
<li>Tahoe: set cwnd to 1 MSS</li>
<li>Reno: set the rate to the half of the last rate (real fast recovery)</li>
</ul></li>
</ol>
<p>Example:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_53.png" /></p>
<p>TCP is <strong>fair</strong></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_56.png" style="zoom:50%;" /></p>
<p>these two connection will infinitely approach <em>the equal bandwidth share line</em>.</p>
<h2 id="chapter-4-the-network-layer">Chapter 4 The Network Layer</h2>
<h3 id="introduction">4.1 Introduction</h3>
<ul>
<li><strong>Forwarding（转发）</strong>: When a packet arrives at a router’s input link, the router must move the packet to the appropriate output link</li>
<li><strong>Routing</strong>: The network layer must determine the route or path taken by packets as they flow from a sender to a receiver. The algorithms that calculate these paths are referred to as routing algorithms</li>
</ul>
<p>Every router has a <strong>forwarding table</strong>.</p>
<p>ATM services models:</p>
<ul>
<li>CBR: <strong>Constant bit rate (CBR) ATM network service.</strong></li>
<li>ABR: <strong>Available bit rate (ABR) ATM network service</strong></li>
</ul>
<h3 id="virtual-circuit-and-datagram-networks">4.2 Virtual Circuit and Datagram Networks</h3>
<h4 id="virtual-circuit-networks">Virtual-Circuit Networks</h4>
<p>consists of:</p>
<ul>
<li>a <strong>path</strong> (that is, a series of links and routers) between the source and destination hosts</li>
<li><strong>VC numbers</strong>, one number for each link along the path</li>
<li>entries in the <strong>forwarding table</strong> in each router along the path</li>
</ul>
<p>Whenever a new VC is established across a router, an entry is added to the forwarding table. Similarly, whenever a VC terminates, the appropriate entries in each table along its path are removed.</p>
<p><strong>three identifiable phases in a virtual circuit</strong>:</p>
<ol type="1">
<li>VC setup</li>
<li>Data transfer</li>
<li>VC teardown</li>
</ol>
<h4 id="datagram-networks">Datagram Networks</h4>
<p>the router uses <strong><em>the longest prefix matching rule</em></strong> in datagram networks.</p>
<p>Because forwarding tables in datagram networks <strong>can be modified at any time</strong>, a series of packets sent from one end system to another may follow different paths through the network and may arrive <strong>out of order</strong>.</p>
<h3 id="whats-inside-a-router">4.3 What’s Inside a Router?</h3>
<h4 id="architecture">Architecture</h4>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_6.png" style="zoom:50%;" /></p>
<h4 id="switching">Switching</h4>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_8.png" style="zoom:50%;" /></p>
<h4 id="where-does-queueing-occur">Where Does Queueing Occur?</h4>
<p>the router’s memory can eventually be exhausted and packet loss will occur when no memory is available to store arriving packets.</p>
<p><strong>packet scheduler（分组调度）</strong>:</p>
<p><strong>active queue management（AQM 主动队列管理）</strong></p>
<ul>
<li>drop-tail（弃尾）</li>
<li>Random Early Detection (RED随机早期检测)</li>
</ul>
<p><strong>head-of-the-line (HOL) blocking（线路前部阻塞）</strong>: 前一个分组和其他的输入端口竞争，阻塞了后面没有冲突的分组的发送</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_11.png" style="zoom:50%;" /></p>
<h4 id="the-routing-control-plane">The Routing Control Plane</h4>
<p>software pass....</p>
<h3 id="ip">4.4 IP</h3>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_12.png" style="zoom:60%;" /></p>
<h4 id="datagram-format">Datagram Format</h4>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_13.png" style="zoom:50%;" /></p>
<p>此处校验和计算方法和UDP处出现的校验和计算方法一致</p>
<p><strong>IP Datagram Fragmentation</strong></p>
<p>datagram: 4000 bytes</p>
<p>MTU: 1500 bytes</p>
<p>IP header: 20 bytes</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/T4_2.png" style="zoom:50%;" /></p>
<h4 id="ipv4-addressing">IPv4 Addressing</h4>
<p>The boundary between the host and the physical link is called an <strong>interface</strong>.</p>
<p>To determine the subnets, detach each interface from its host or router, creating islands of isolated networks, with interfaces terminating the end points of the isolated networks. Each of these isolated networks is called a subnet. 没有穿越路由器属于一个子网</p>
<p>子网可用IP地址需要减2，一个是主机位全0的子网地址和主机位全1的子网广播地址</p>
<p>子网本身IP地址：前缀+全零</p>
<p>子网本身IP地址：前缀+全1(直接广播地址)（对目标子网广播）</p>
<p>255.255.255.255 子网广播地址（受限广播地址）（广播本子网）</p>
<p>0.0.0.0 网卡本身地址</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_17.png" style="zoom:50%;" /></p>
<ul>
<li><p><strong>Classless Interdomain Routing (CIDR 无类别区域间路由选择)</strong></p>
<p>a.b.c.d/x ; use prefix can reduce the size of the forwarding table</p></li>
<li><p><strong>classful addressing 分类编址</strong></p>
<p>A：8 bits ；B：16 bits；C：24bits</p></li>
</ul>
<h4 id="dhcp-the-dynamic-host-configuration-protocol">DHCP: the Dynamic Host Configuration Protocol</h4>
<p>a <strong>plug-and-play protocol</strong>(即插即用协议)</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_21.png" style="zoom:50%;" /></p>
<p>因为可能存在多个DHCP服务器所以需要二次确认，客户端选择一个IP并告知（一般都是第一个）</p>
<h4 id="network-address-translation-nat">Network Address Translation (NAT)</h4>
<p>use a <strong>NAT translation table</strong> at the NAT router, and to include port numbers as well as IP addresses in the table entries</p>
<p>NAT interferes with P2P applications.</p>
<p>可以采用第三方来通信 （Skype）</p>
<p><strong>NAT traversal</strong>（NAT穿越）克服两台主机同属于不同NAT之后的通信，使用UPnP(Universal Plug and Play)协议</p>
<h4 id="internet-control-message-protocol-icmp">Internet Control Message Protocol (ICMP)</h4>
<p>The most typical use of ICMP is for error reporting</p>
<p>使用IP协议的网络层协议</p>
<h4 id="ipv6">IPv6</h4>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_24.png" style="zoom:50%;" /></p>
<ul>
<li>Next hdr:交付到哪一个协议（TCP/UDP）和v4的协议字段相同</li>
<li>IPv6不允许在路由器上分片和组装</li>
<li>IPv6没有选项字段，使得其为定长40字节</li>
<li>首部校验和消失，完全交付给上层协议处理</li>
<li>payload length: 数据长度</li>
</ul>
<p><strong>Transitioning from IPv4 to IPv6</strong></p>
<ul>
<li><p><strong>dual-stack</strong>：使用既可以处理v4也可以处理v6的路由器，但可能丢失流标签（或者其他v6特有标签）</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_25.png" style="zoom:50%;" /></p></li>
<li><p><strong>tunneling</strong>（建隧道）：将v6整体作为v4的数据段传递</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_26.png" style="zoom:50%;" /></p></li>
</ul>
<h3 id="routing-algorithms">4.5 Routing Algorithms</h3>
<p>classification</p>
<ol type="1">
<li><strong>global routing algorithm(LS)</strong> &amp; <strong>decentralized routing algorithm(DV)</strong></li>
<li><strong>static routing algorithms</strong> &amp; <strong>Dynamic routing algorithms</strong></li>
<li><strong>load-sensitive algorithm</strong> &amp; <strong>load-insensitive(RIP, OSPF, BGP)</strong></li>
</ol>
<h4 id="link-state-algorithm-ls">Link-State Algorithm (LS)</h4>
<ul>
<li>D(v): cost of the least-cost path from the source node to destination v as of this iteration of the algorithm.</li>
<li>p(v): previous node (neighbor of v) along the current least-cost path from the source to v.</li>
<li>N' : subset of nodes; v is in N’ if the least-cost path from the source to v is definitively known.</li>
</ul>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/LS.png" style="zoom:50%;" /></p>
<p>Example:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/T4_3.png" style="zoom:50%;" /></p>
<p>Then we can get the forward table of u:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_28.png" style="zoom:50%;" /></p>
<p>oscillations occur in any algorithm, not just an LS algorithm, that uses a congestion or delay-based link metric</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_29.png" style="zoom:60%;" /></p>
<p>One way to avoid such self synchronization is for each router to randomize the time it sends out a link advertisement.</p>
<h4 id="the-distance-vector-dv-routing-algorithm">The Distance-Vector (DV) Routing Algorithm</h4>
<ul>
<li>For each neighbor v, the cost <strong><em>c(x,v)</em></strong> from x to directly attached neighbor,</li>
<li>Node x’s distance vector, that is, <strong>Dx</strong> = [Dx (y): y in N], containing x’s estimate of its cost to all destinations, y, in N</li>
<li>The distance vectors of each of its neighbors, that is, <strong>Dv</strong> = [Dv (y): y in N] for each neighbor v of x</li>
</ul>
<p>use this formula to update forwarding table:</p>
<p>$D_x(y)=min_v{c(x,v)+D_v(y) } $</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/DV.png" style="zoom:50%;" /></p>
<p>Examlpe:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_30.png" style="zoom:65%;" /></p>
<h4 id="distance-vector-algorithm-adding-poisoned-reverse">Distance-Vector Algorithm: Adding Poisoned Reverse</h4>
<p>好消息: 链路开销减小, 迭代次数少便收敛</p>
<p>坏消息 链路开销增加, 可能陷入无穷迭代（原因在于消息的虚假，增加的这条链路被其他节点引用但无法更新）</p>
<p>https://blog.csdn.net/tianlongtc/article/details/80261581</p>
<p>毒性逆转：The idea is simple—if z routes through y to get to destination x, then z will advertise to y that its distance to x is infinity</p>
<h4 id="a-comparison-of-ls-and-dv-routing-algorithms">A Comparison of LS and DV Routing Algorithms</h4>
<ul>
<li>Message complexity：</li>
<li>Speed of convergence（收敛速度）：DV收敛慢，可能遇到环路和无穷计数，LS较快</li>
<li>Robustness（健壮性）：LS更健壮，路由器故障时，DV会无穷欺骗</li>
</ul>
<h4 id="hierarchical-routing">Hierarchical Routing</h4>
<ul>
<li><p><strong>autonomous systems (ASs)</strong>: consisting of a group of routers that are typically under the same administrative control</p></li>
<li><p><strong>intra autonomous system routing protocol</strong>: The routing algorithm running within an autonomous system</p></li>
<li><strong>gateway routers</strong>: forwarding packets to destinations outside the AS</li>
<li><strong>inter-AS routing protocol</strong>: obtaining reachability information from neighboring ASs and propagating the reachability information to all routers internal to the AS</li>
<li><p><strong>hot-potato routing</strong>: 如果有两个网关都可以通向到另外一个AS那么简单的选择最近的那一个就可以</p></li>
</ul>
<h3 id="routing-in-the-internet">4.6 Routing in the Internet</h3>
<p><strong>intra autonomous system routing protocol</strong> also named <strong>interior gateway protocols</strong></p>
<ol type="1">
<li>Routing Information Protocol (RIP) DV(下层ISP或企业)</li>
<li>Open Shortest Path First (OSPF) LS (上层ISP)</li>
</ol>
<h4 id="intra-as-routing-in-the-internet-rip">Intra-AS Routing in the Internet: RIP</h4>
<p><strong>hop</strong>: the number of subnets traversed along the shortest path from source router to destination subnet, including the destination subnet</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_34.png" style="zoom:50%;" /></p>
<p>The maximum cost of a path is limited to 15 in RIP.</p>
<p>In RIP, routing updates are exchanged between neighbors approximately every 30 seconds using a <strong>RIP response message</strong>(RIP advertisements)</p>
<p>Example:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_35.png" style="zoom:50%;" /></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_36.png" style="zoom:50%;" /></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_37.png" style="zoom:50%;" /></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_38.png" style="zoom:50%;" /></p>
<h4 id="intra-as-routing-in-the-internet-ospf">Intra-AS Routing in the Internet: OSPF</h4>
<p>OSPF broadcasts routing information to <strong>all</strong> other routers in the autonomous system</p>
<p>Some of the advances embodied in OSPF：</p>
<ol type="1">
<li><em>Security</em></li>
<li><em>Multiple same-cost paths</em>（允许使用多条路径发送）</li>
<li><em>Integrated support for unicast and multicast routing</em></li>
<li><em>Support for hierarchy within a single routing domain</em></li>
</ol>
<p>OSPF可以配置为多个区域，每个区域都有区域边界路由器（<strong>area border routers</strong>）负责向流域以外的分组提供路由选择。AS内只有一个主干区域（backbone），主干的主要作用是为AS内其他区域之间的流量提供路由选择，包括了所有区域边界路由器和一些非边界路由器。在AS内区域间的路由选择要求分组首先路由到一个区域边界路由去，然后听过主干路由到位于母的区域的边界路由器</p>
<h4 id="inter-as-routing-bgpborder-gateway-protocol">Inter-AS Routing: BGP（Border Gateway Protocol）</h4>
<p>*<strong>BGP转发的对象是前缀（子网）</strong></p>
<p>BGP provides each AS a means to</p>
<ol type="1">
<li>Obtain subnet reachability information from neighboring ASs.</li>
<li>Propagate the reachability information to all routers internal to the AS</li>
<li>Determine “good” routes to subnets based on the reachability information and on AS policy</li>
</ol>
<p>Most importantly, BGP allows each subnet to advertise its existence to the rest of the Internet.</p>
<ul>
<li><strong>BGP peers</strong>：TCP连接的两个端点</li>
<li><strong>BGP session</strong>：发送BGP报文的TCP连接</li>
<li><strong>external BGP</strong> (<strong>eBGP</strong>) <strong>session</strong>：跨越AS</li>
<li><strong>internal BGP</strong> (<strong>iBGP</strong>) <strong>session</strong>：内部</li>
</ul>
<p>每一个AS都有一个ASN（autonomous system number），但是桩（stub）AS没有，这种AS只承担目的地址为本AS的流量。AS号是ICANN 分配的</p>
<p>When a router advertises a prefix across a BGP session, it includes with the prefix a number of BGP attributes. In BGP jargon, a prefix along with its attributes is called a route</p>
<ul>
<li><em>AS-PATH</em>:包含了前缀的通告已经听过的那些AS</li>
<li>Providing the critical link between the inter-AS and intra-AS routing protocols, the NEXT-HOP attribute has a subtle but important use. <strong>The NEXT-HOP is the router interface that begins the AS-PATH.</strong></li>
</ul>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/BGP_routing.png" style="zoom:50%;" /></p>
<h2 id="chapter-5-the-link-layer-links-access-networks-and-lans">Chapter 5 The Link Layer: Links, Access Networks, and LANs</h2>
<h3 id="introduction-to-the-link-layer">5.1 Introduction to the Link Layer</h3>
<ul>
<li><strong>node</strong>: any device that runs a link-layer protocol</li>
<li><strong>links:</strong>the communication channels that connect adjacent nodes along the communication path</li>
<li><strong>link-layer frame</strong>: link-layer data transmission format</li>
</ul>
<h4 id="the-services-provided-by-the-link-layer">The Services Provided by the Link Layer</h4>
<ol type="1">
<li><em>Framing</em>(成帧)</li>
<li><em>Link access</em>(链路接入)</li>
<li><em>Reliable delivery.</em></li>
<li><em>Error detection and correction</em></li>
</ol>
<h4 id="where-is-the-link-layer-implemented">Where Is the Link Layer Implemented?</h4>
<p><strong>network adapter</strong> also named <strong>network interface card (NIC)</strong></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/5_2.png" style="zoom:50%;" /></p>
<h3 id="error-detection-and--correction-techniques">5.2 Error-Detection and -Correction Techniques</h3>
<p>use <strong>error-detection and -correction bits(EDC)</strong> to detect and correct error bits</p>
<p>Even with the use of error-detection bits there still may be <strong>undetected bit errors</strong></p>
<h4 id="parity-checks">Parity Checks</h4>
<p>奇偶校验只需要查看加上检验比特(奇偶校验位)的1 是奇数还是偶数</p>
<p>二维奇偶校验:</p>
<p>对每一行每一列都进行奇偶校验,然后对列行奇偶校验位进行奇偶校验, 就校验可以检测和纠正单个比特错误,可以检测但是不能纠正两个比特的任意错误组合</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/5_5.png" style="zoom:50%;" /></p>
<p>The ability of the receiver to both detect and correct errors is known as <strong>forward error correction (FEC前向纠错)</strong>.</p>
<h4 id="checksumming-methods">Checksumming Methods</h4>
<p>和UDP/TCP中的类似</p>
<h4 id="cyclic-redundancy-check-crc">Cyclic Redundancy Check (CRC)</h4>
<p>also named <strong>polynomial codes</strong>(多项式编码)</p>
<ol type="1">
<li><p>确定多项式 例如 x3+x2+1 = 1101</p></li>
<li><p>在目标码后加上多项式码长度-1 的0</p></li>
<li><p>做模2除法(除的过程不是减是异或)</p></li>
</ol>
<p>把最后的余数添加到原码的末尾,在接收端使用相同多项式除看余数是否是0</p>
<h3 id="multiple-access-links-and-protocols">5.3 Multiple Access Links and Protocols</h3>
<ul>
<li><strong>point-to-point link</strong>: consists of a single sender at one end of the link and a single receiver at the other end of the link</li>
<li><strong>broadcast link</strong>: enables a single source node to send a copy of a packet to a subset of the other network nodes</li>
</ul>
<ol type="1">
<li>channel partitioning protocols 信道划分协议</li>
<li>random access protocols 随机访问协议</li>
<li>taking-turns protocols 轮流协议</li>
</ol>
<p>a multiple access protocol for a broadcast channel of rate R bits per second should have the following desirable characteristics:</p>
<ol type="1">
<li><p>当仅有一个节点发送数据时,具有R bps的吞吐量</p></li>
<li><p>当M给节点发送时,每个结点吞吐量为 R/M bps的平均传输速率</p></li>
<li><p>协议是分散的,不会因为某个主节点故障而使整个系统崩溃</p>
<p>no special node to coordinate transmissions</p>
<p>no synchronization of clocks, slots</p></li>
<li><p>协议是简单的,使实现不昂贵</p></li>
</ol>
<h4 id="channel-partitioning-protocols">Channel Partitioning Protocols</h4>
<ul>
<li><p>time-division multiplexing (TDM): divides time into time frames and further divides each time frame into N time slots(时隙) 仅有一个节点他的速度任然是R/N的速度</p></li>
<li><p>frequency-division multiplexing (FDM): 将R bps 信道划分为不同的频段, 具有TDM的缺点</p></li>
</ul>
<h4 id="random-access-protocols">Random Access Protocols</h4>
<ul>
<li><p><strong>Slotted ALOHA (时隙 ALOHA)</strong>:</p>
<p>有如下假设:</p>
<ul>
<li>All frames consist of exactly L bits.</li>
<li>Time is divided into slots of size L/R seconds (that is, a slot equals the time to transmit one frame).</li>
<li>Nodes start to transmit frames only at the beginnings of slots.</li>
<li>The nodes are synchronized so that each node knows when the slots begin.</li>
<li>If two or more frames collide in a slot, then all the nodes detect the collision event before the slot ends.</li>
</ul>
<p>p 是一个0-1的概率, 有如下操作:</p>
<ul>
<li>当节点要发送一个新帧时,需要在下一个时隙开始并在该时隙传输整个帧</li>
<li>如果没有碰撞则成功传输,不需要考虑重传</li>
<li>如果有碰撞,该结点在时隙结束之前检测到碰撞,之后以p在之后的每一杠时隙重传,直到成功</li>
</ul>
<p>此协议需要时钟同步,但是当只有一个结点时,效率是R</p>
<p>此协议效率定义为:有大量活跃结点发送大量帧时,长期运行中成功时隙的份额</p>
<p>在p的概率下 N个结点的效率为<span class="math inline">\(Np(1-p)^{N-1}\)</span> N趋于无穷时有极限1/e = 0.37</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/5_10.png" style="zoom:50%;" /></p></li>
<li><p>ALOHA</p>
<p>时隙ALOHA的无时钟同步版本, 效率降低一半</p></li>
<li><p>Carrier Sense Multiple Access (CSMA 载波监听多路访问)</p>
<p>规则:</p>
<ol type="1">
<li><em>Listen before speaking</em>, this is called <strong>carrier sensing</strong></li>
<li><em>If someone else begins talking at the same time, stop talking</em>, this is called <strong>collision detection</strong></li>
</ol>
<p>These two rules are embodied in the family of <strong>carrier sense multiple access(CSMA)</strong> and <strong>CSMA with collision detection (CSMA/CD)</strong> protocols</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/5_12.png" style="zoom:50%;" /></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/5_13.png" style="zoom:50%;" /></p>
<p>CSMA/CD 的运行</p>
<ol type="1">
<li>The adapter obtains a datagram from the network layer, prepares a link-layer frame, and puts the frame adapter buffer.</li>
<li>If the adapter senses that the channel is idle (that is, there is no signal energy entering the adapter from the channel 即在96比特时间内没有检测到信道上有信号), it starts to transmit the frame. If, on the other hand, the adapter senses that the channel is busy, it waits until it senses no signal energy and then starts to transmit the frame.</li>
<li>While transmitting, the adapter monitors for the presence of signal energy coming from other adapters using the broadcast channel.</li>
<li>If the adapter transmits the entire frame without detecting signal energy from other adapters, the adapter is finished with the frame. If, on the other hand, the adapter detects signal energy from other adapters while transmitting, it aborts the transmission (that is, it stops transmitting its frame).</li>
<li>After aborting, the adapter waits a random amount of time and then returns to step 2.</li>
</ol>
<p>选择随机回退时间算法:</p>
<p><strong>binary exponential backoff(二进制指数后退)</strong>algorithm</p>
<p>经历n次碰撞之后,结点随机的从<span class="math inline">\(\{0,1,2,...,2^n-1\}\)</span>选择一个值作为回退时间</p></li>
</ul>
<h4 id="taking-turns-protocols">Taking-Turns Protocols</h4>
<p>Recall that two desirable properties of a multiple access protocol are (1) when only one node is active, the active node has a throughput of R bps, and (2) when M nodes are active, then each active node has a throughput of nearly R/M bps. The ALOHA and CSMA protocols have this first property but not the second.</p>
<ul>
<li><strong>polling protocol(轮询协议)</strong>: 在一个主结点的控制下轮询各个结点</li>
<li><strong>token-passing protocol(令牌传递协议)</strong>:结点构成一个环,将令牌传递,有令牌的发送,结束后传递给下一个</li>
</ul>
<p>具有单点失效性</p>
<h3 id="switched-local-area-networks">5.4 Switched Local Area Networks</h3>
<h4 id="link-layer-addressing-and-arp">Link-Layer Addressing and ARP</h4>
<ul>
<li><p><strong>MAC(LAN address, a physical address)</strong>: 48 bits, FF-FF-FF-FF-FF-FF <strong>broadcast address</strong></p></li>
<li><p><strong>Address Resolution Protocol (ARP)</strong>:</p>
<p>ARP 维护一个ARP表</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/5_18.png" style="zoom:50%;" /></p>
<p>表中没有所需要的项时,就会发送一个ARP分组并向子网广播获取对方的MAC地址,当需要发送到子网以外时,需要先获取网关路由器的MAC地址,然后一步步转发出去</p></li>
</ul>
<h4 id="ethernet">Ethernet</h4>
<ul>
<li>hub(集线器): 比特级复制数据,可以达到广播的目的</li>
<li>switch(交换机):存储转发功能,且无碰撞(因为有缓存)</li>
</ul>
<p>结构:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/5_20.png" style="zoom:50%;" /></p>
<p>以太网技术提供不可靠服务,接收方会执行CRC校验,失败则丢弃,但不对发送方产生任何的反馈信息</p>
<h4 id="link-layer-switches">Link-Layer Switches</h4>
<ul>
<li><strong>Filtering</strong>: determines whether a frame should be forwarded to some interface or should just be dropped.</li>
<li><strong>Forwarding</strong>: determines the interfaces to which a frame should be directed, and then moves the frame to those interfaces.</li>
</ul>
<p>一个目的MAC通过一个接口x到达交换机有3种情况:</p>
<ol type="1">
<li>没有此目的MAC的表项则广播</li>
<li>此表项和x已经关联,丢弃</li>
<li>不等于x的y接口是此目的MAC 则转发</li>
</ol>
<p>交换机是自学习的,即插即用,双工设备</p>
<ol type="1">
<li>初始交换机为空</li>
<li>对每个接口接收到的帧,存储 MAC, 接口, 时间信息</li>
<li>在老化期(aging time)之后没有收到该地址作为源的帧删除</li>
</ol>
<p>交换机的优点:</p>
<ol type="1">
<li><em>Elimination of collisions</em></li>
<li><em>Heterogeneous links</em>(异质的链路)</li>
<li><em>Management</em></li>
</ol>
<p>交换机和路由器比较:</p>
<ul>
<li><p>交换机: 即插即用、高转发过滤速率、没有提供广播风暴保护措施</p></li>
<li><p>路由器：一般不会死循环（TTL）、广播风暴有有防火墙保护，非即插即用，处理时间长</p></li>
</ul>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统结构 张晨曦-第二版 整理</title>
    <url>/2020/05/24/2020-05-24-Computer-System-Architecture-Note/</url>
    <content><![CDATA[<blockquote>
<p>Github：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dlaWp1bi1MaW4vTm90ZXMvdHJlZS9tYXN0ZXIv6K6h566X5py657O757uf57uT5p6ELeW8oOaZqOabpi3nrKzkuozniYg=">笔记-计算机系统结构-张晨曦-第二版<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<a id="more"></a>
<h2 id="第一章-计算机系统结构的基本概念">第一章 计算机系统结构的基本概念</h2>
<p>第一台通用电子计算机诞生于1946年</p>
<p>计算机技术的飞速发展得益于两个方面</p>
<ol type="1">
<li>计算机制造技术的发展</li>
<li>计算机系统结构的创新</li>
</ol>
<p>系统结构的重大转折：</p>
<ol type="1">
<li>从单纯依靠指令级并行转向开发线程级并行和数据级并行</li>
<li>计算机系统结构在计算机的发展中有着极其重要的作用</li>
</ol>
<h3 id="计算机系统结构的概念">1.2 计算机系统结构的概念</h3>
<h4 id="计算机系统的层次结构">计算机系统的层次结构</h4>
<ol type="1">
<li>计算机系统＝硬件/固件＋软件</li>
<li>计算机语言从低级向高级发展</li>
<li>从计算机语言的角度，把计算机系统按功能划分成多层次结构</li>
</ol>
<h4 id="计算机系统结构的定义">计算机系统结构的定义</h4>
<ol type="1">
<li><p>计算机系统结构的经典定义：程序员所看到的计算机属性，即概念性结构与功能特性</p></li>
<li><p>按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性</p></li>
<li><p>Amdahl提出的系统结构：传统机器语言级程序员所看到的计算机属性</p>
<p>属性主要为：</p>
<ul>
<li>指令系统</li>
<li>数据表示</li>
<li>寻址规则</li>
<li>寄存器定义</li>
<li>中断系统</li>
<li>机器工作状态的定义和切换</li>
<li>存储系统</li>
<li>信息保护</li>
<li>I/O结构</li>
</ul></li>
<li><p><strong>广义的系统结构定义：指令集结构、组成、硬件</strong></p></li>
<li><p>计算机系统结构概念的<strong>实质</strong>：确定计算机系统中软、硬件的界面，界面之上是软件实现的功能，界面之下是硬件和固件实现的功能</p></li>
</ol>
<h4 id="计算机组成和计算机实现">计算机组成和计算机实现</h4>
<p>一种体系结构可以有多种组成，一种组成可以有多种物理实现</p>
<ol type="1">
<li><p><strong>计算机系统结构</strong>：计算机系统的软、硬件的界面</p></li>
<li><p><strong>计算机组成</strong>：计算机系统结构的逻辑实现</p>
<p>物理机器级内各事件的排序方式与控制方式、各部件的功能以及各部件之间的联系</p></li>
<li><p><strong>计算机实现</strong>：计算机组成的物理实现（器件技术（起主导作用）、微组装技术）</p></li>
</ol>
<h4 id="计算机系统结构的分类">计算机系统结构的分类</h4>
<ol type="1">
<li><p><strong>冯氏分类法：用系统的最大并行度对计算机进行分类</strong></p>
<p>最大并行度：计算机系统在单位时间内能够处理的最大的二进制位数</p></li>
<li><p><strong>Flynn分类法：按照指令流和数据流的多倍性进行分类</strong></p>
<ul>
<li>指令流：计算机执行的指令序列</li>
<li>数据流：由指令流调用的数据序列</li>
<li>多倍性：在系统受限的部件上，同时处于同一执行阶段的指令或数据的最大数目</li>
</ul>
<p>可以分为四类：</p>
<ul>
<li>单指令流单数据流(SISD)</li>
<li>单指令流多数据流(SIMD)</li>
<li>多指令流单数据流(MISD)</li>
<li>多指令流多数据流(MIMD)</li>
</ul>
<p>以上四类的基本结构：IS：指令流，DS：数据流，CS：控制流，CU：控制部件，PU：处理部件，MM和SM：存储器</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/1-1.jpg" style="zoom:50%;" /></p></li>
</ol>
<h3 id="定量分析技术">1.3 定量分析技术</h3>
<h4 id="计算机系统结构的定量原理">计算机系统结构的定量原理</h4>
<ol type="1">
<li><p>以经常性事件为重点(大概率事件优先)</p></li>
<li><p>Amdahl定律</p>
<p>系统性能加速比：<strong><span class="math inline">\(加速比=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}\)</span></strong></p>
<p>加速比依赖于两个因素：</p>
<ol type="1">
<li><p>可改进比例：改进前的系统中，可改进部分的执行时间在总的执行时间中所占的比例</p></li>
<li><p>部件加速比：可改进部分改进后性能提高的倍数，改进前所需的执行时间于改进后执行时间的比</p></li>
<li><p>改进后的程序总执行时间： <span class="math display">\[
 \begin{align}
 总执行时间_{改进后} &amp;= 不可改进部分的执行时间 + 可改进部分改进后的执行时间 \nonumber \\
 总执行时间_{改进后} &amp;= (1-可改进比例)\times总执行时间_{改进前}+\frac{可改进比例\times总执行时间_{改进前}}{部件加速比}  \nonumber \\
 &amp;= [(1-可改进比例)+\frac{可改进比例}{部件加速比}]\times总执行时间_{改进前} \nonumber
 \end{align}
 \]</span></p></li>
<li><p>可得加速比为： <span class="math display">\[
 \begin{align}
 加速比 &amp;= \frac{总执行时间_{改进前}}{总执行时间_{改进后}} \nonumber\\
 &amp;= \frac{1}{(1-可改进比例)+\frac{可改进比例}{部件加速比}} \nonumber
 \end{align}
 \]</span></p></li>
<li><p>是一种性能改进的递减规则，如果只针对整个任务的一部分进行改进和优化，那么所获得的加速比不超过1/(1－可改进比例)</p></li>
</ol></li>
<li><p>CPU性能公式</p>
<ol type="1">
<li><p>执行一个程序所需的CPU时间</p>
<p><strong>CPU时间 = 执行程序所需的时钟周期数×时钟周期时间</strong></p>
<p>时钟周期时间是系统时钟频率的倒数</p></li>
<li><p>每条指令执行的平均时钟周期数CPI</p>
<p><strong>CPI = 执行程序所需的时钟周期数/IC，IC所执行的指令条数</strong> 程序执行的CPU时间可以写为：IC ×CPI ×时钟周期时间</p></li>
<li>CPU的性能取决于3个参数：
<ol type="1">
<li>时钟周期时间：取决于硬件实现技术和计算机组成</li>
<li>CPI：取决于计算机组成和指令集结构</li>
<li>IC：取决于指令集结构和编译技术</li>
</ol></li>
<li><p>CPU性能公式进一步细化：</p>
<p>CPIi ：第i种指令的处理时间 ICi ：在程序中第i种指令出现的次数 <span class="math inline">\(CPU时钟周期数=\sum_{i=1}^{n}{CPI_i\times IC_i}\)</span></p>
<p><span class="math inline">\(CPI=\frac{时钟周期数}{IC} = \sum_{i=1}^{n}{CPI_i\times \frac{IC_i}{IC}}\)</span></p></li>
</ol></li>
<li><p>程序的局部性原理</p>
<p>程序执行时所访问的存储器地址分布不是随机的，而是相对地簇聚</p>
<p>常用的应该经验规则：程序执行时间的90%都是在执行程序中10%的代码</p>
<ul>
<li><p>程序的时间局部性：</p>
<p>程序即将用到的信息很可能就是目前正在使用的信息</p></li>
<li><p>程序的空间局部性：</p>
<p>程序即将用到的信息很可能与目前正在使用的信息在空间上相邻或者临近</p></li>
</ul></li>
</ol>
<h4 id="计算机系统的性能测评">计算机系统的性能测评</h4>
<ol type="1">
<li><p>执行时间和吞吐率</p>
<p>用户角度：单个程序的执行时间</p>
<p>数据管理与：吞吐率（单位时间里能够完成的任务）</p></li>
<li><p>主要标准：执行程序的时间</p>
<ol type="1">
<li>MIPS，每秒百万条指令数 <span class="math display">\[
 \begin{align}
 MIPS &amp;= 指令条数/(执行时间\times 10^6) \nonumber \\
 &amp;= 时钟频率/(CPI\times 10^6) \nonumber
 \end{align}
 \]</span></li>
</ol></li>
<li><p>MFLOPS，每秒百万次浮点操作次数 = 程序中的浮点操作次数 /（执行时间×10^6）</p></li>
<li><p>利用基准测试程序</p></li>
</ol>
<h3 id="计算机系统结构的发展">1.4 计算机系统结构的发展</h3>
<h4 id="冯诺依曼结构">冯·诺依曼结构</h4>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/1-2.jpg" style="zoom:50%;" /></p>
<p>主要特点：（存储程序计算机）</p>
<ul>
<li>以运算器为中心。</li>
<li>在存储器中，指令和数据同等对待</li>
<li>存储器是按地址访问、按顺序线性编址的一维结构，每个单元的位数是固定的</li>
<li>指令的执行是顺序的</li>
<li>指令由操作码和地址码组成</li>
<li>指令和数据均以二进制编码表示，采用二进制运算</li>
</ul>
<h3 id="计算机系统中并行性的发展">1.5 计算机系统中并行性的发展</h3>
<h4 id="并行性的概念">并行性的概念</h4>
<ol type="1">
<li>并行性：计算机系统在同一时刻或者同一时间间隔内进行多种运算或操作，只要在时间上相互重叠，就存在并行性
<ul>
<li>同时性：两个或两个以上的事件在同一时刻发生。</li>
<li>并发性：两个或两个以上的事件在同一时间间隔内发生。</li>
</ul></li>
<li>从执行程序的角度来看，并行性等级从低到高可分为
<ul>
<li>指令内部并行</li>
<li>指令级并行</li>
<li>线程级并行</li>
<li>任务级或过程级并行</li>
<li>作业或程序级并行</li>
</ul></li>
<li>提高并行性的技术途径
<ul>
<li>时间重叠</li>
<li>资源重复</li>
<li>资源共享</li>
</ul></li>
</ol>
<h2 id="第二章-计算机指令集结构mips">第二章 计算机指令集结构（MIPS）</h2>
<ul>
<li><p>CISC（复杂指令集计算机）</p>
<p>增强指令功能，把越来越多的功能交由硬件来实现，并且指令的数量也是越来越多。</p></li>
<li><p>RISC（精简指令集计算机） 尽可能地把指令集简化，不仅指令的条数少，而且指令的功能也比较简单。</p></li>
</ul>
<h2 id="第三章-流水线技术">第三章 流水线技术</h2>
<h3 id="重叠执行和先行控制">3.1 重叠执行和先行控制</h3>
<h4 id="重叠执行">重叠执行</h4>
<p>二次重叠执行过程如下：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-1.png" style="zoom:48%;" /></p>
<p>此时，执行n条指令花费的时间为<span class="math inline">\(T=(2+n)t\)</span></p>
<p>有以下优点：</p>
<ul>
<li>时间缩短</li>
<li>部件利用率提高</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要增加更多的硬件</li>
<li>需要设置独立的取指令部件，指令分析部件和指令执行部件</li>
</ul>
<p>存在主存的访问冲突问题（读写主存），有以下四种解决方法：</p>
<ul>
<li><p>设置两个独立编址的存储器： 指令存储器（存放指令）、数据存储器（存放数据）</p></li>
<li><p>指令和数据仍然混合存放在同一个主存中，但设置两个Cache：指令Cache、数据Cache，<strong>程序空间和数据空间相互独立的系统结构被称为哈佛结构</strong></p></li>
<li><p>指令和数据仍然混合存放在同一个主存中，但主存采用多体交叉结构</p></li>
<li><p>在主存和指令分析部件之间增设指令缓冲站（又被称为先行指令缓冲站 ）</p>
<p>先行指令缓冲站的组成如下：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-2.jpg" style="zoom:50%;" /></p>
<ul>
<li>指令缓冲存储区和相应的控制逻辑
<ul>
<li>按队列方式工作</li>
<li>只要指令缓冲站不满，它就自动地向主存控制器发取指令请求，不断地预取指令</li>
</ul></li>
<li>指令分析部件
<ul>
<li>每分析完一条指令，就自动向指令缓冲站发出取下一条指令的请求。指令取出之后就把指令缓冲站中的该指令作废</li>
<li>指令缓冲站中存放的指令的条数是动态变化的</li>
</ul></li>
<li>两个程序计数器
<ul>
<li>先行程序计数器PC1：用于从主存预取指令</li>
<li>现行程序计数器PC：用来记录指令分析部件当前正在分析的指令的地址</li>
</ul></li>
</ul></li>
</ul>
<p>当每个子过程执行的时间不相等时，会出现部件空闲的情况：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-3.png" style="zoom:48%;" /></p>
<h4 id="先行控制">先行控制</h4>
<ol type="1">
<li><p>先行控制技术：缓冲技术和预处理技术的结合</p>
<ul>
<li>缓冲技术：在工作速度不固定的两个功能部件之间设置缓冲器，用以平滑它们的工作</li>
<li>预处理技术：预取指令、对指令进行加工以及预取操作数等。</li>
</ul></li>
<li><p>采用先行控制方式的处理机结构</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-4.jpg" style="zoom:50%;" /></p>
<p>特点：</p>
<ul>
<li>缓冲站按先进先出的方式工作</li>
<li>每个存储单元由3部分组成：先行地址字段、先行操作数字段、标志字段</li>
</ul></li>
</ol>
<h3 id="流水线的基本概念">3.2 流水线的基本概念</h3>
<h4 id="什么是流水线">什么是流水线</h4>
<ol type="1">
<li>流水线技术
<ul>
<li>把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件来实现</li>
<li>把多个处理过程在时间上错开，依次通过各功能段，这样，每个子过程就可以与其他的子过程并行进行</li>
</ul></li>
<li>流水线中的每个子过程及其功能部件称为流水线的级或段，段与段相互连接形成流水线。流水线的段数称为流水线的深度</li>
<li>流水技术的特点
<ul>
<li>流水线把一个处理过程分解为若干个子过程（段），每个子过程由一个专门的功能部件来实现</li>
<li>流水线中各段的时间应尽可能相等，否则将引起流水线堵塞、断流。<strong>时间长的段将成为流水线的瓶颈</strong></li>
<li>流水线每一个功能部件的后面都要有一个缓冲寄存器（锁存器），称为流水寄存器，在相邻的两段之间传送数据，以保证提供后面要用到的数据，并把各段的处理工作相互隔离</li>
<li><strong>流水技术适合于大量重复的时序过程，只有在输入端不断地提供任务，才能充分发挥流水线的效率</strong></li>
<li>流水线需要有通过时间和排空时间
<ul>
<li>通过时间：第一个任务从进入流水线到流出结果所需的时间</li>
<li>排空时间：最后一个任务从进入流水线到流出结果所需的时间</li>
</ul></li>
</ul></li>
</ol>
<h4 id="流水线的分类">流水线的分类</h4>
<ul>
<li><p>单功能流水线于多功能流水线</p>
<ul>
<li>单功能：只能完成一种固定功能的流水线</li>
<li>多功能：流水线的各段可以进行不同的连接，以实现不同的功能</li>
</ul></li>
<li><p>静态与动态流水线</p>
<ul>
<li>静态流水线：在同一时间内，多功能流水线中的各段只能按同一种功能的连接方式工作，只有输入为一串相同的运算任务时，流水的效率才得到充分的发挥</li>
<li>动态流水线：在同一时间内，多功能流水线中的各段可以按照不同的方式连接，同时执行多种功能</li>
</ul>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-5.png" style="zoom:75%;" /></p></li>
<li><p>部件级、处理机级及处理机间流水线</p>
<ul>
<li>部件级流水线（运算操作流水线）：把处理机的算术逻辑运算部件分段，使得各种类型的运算操作能够按流水方式进行</li>
<li>处理机级流水线（指令流水线）：把指令的解释执行过程按照流水方式处理。把一条指令的执行过程分解为若干个子过程，每个子过程在独立的功能部件中执行</li>
<li>处理机间流水线（宏流水线）：它是由两个或者两个以上的处理机串行连接起来，对同一数据流进行处理，每个处理机完成整个任务中的一部分</li>
</ul></li>
<li><p>线性流水线和非线性流水线</p>
<ul>
<li>线性流水线：流水线的各段串行连接，没有反馈回路。数据通过流水线中的各段时，每一个段最多只流过一次</li>
<li>非线性流水线：流水线中除了有串行的连接外，还有反馈回路</li>
</ul></li>
<li><p>顺序流水线和乱序流水线</p>
<ul>
<li>顺序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序完全相同。每一个任务在流水线的各段中是一个跟着一个顺序流动的。</li>
<li>乱序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序可以不同，允许后进入流水线的任务先完成（从输出端流出）</li>
</ul></li>
<li><p>标量处理机与向量流水处理机</p>
<ul>
<li>标量处理机：处理机不具有向量数据表示和向量指令，仅对标量数据进行流水处理</li>
<li>向量流水处理机：具有向量数据表示和向量指令的处理机</li>
</ul></li>
</ul>
<h3 id="流水线的性能指标">3.3 流水线的性能指标</h3>
<h4 id="吞吐率">吞吐率</h4>
<blockquote>
<p>在单位时间内流水线所完成的任务数量或输出结果的数量，<span class="math inline">\(TP=\frac{n}{T_k}\)</span>，其中n为任务数，<span class="math inline">\(T_k\)</span>为处理完成n个任务所用的时间</p>
</blockquote>
<ol type="1">
<li><p>各段时间均相等的流水线</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-6.jpg" style="zoom:50%;" /></p>
<p>由图可以得出，此流水线的实际吞吐率为:</p>
<p><span class="math inline">\(TP=\frac{n}{(k+n-1)\Delta t}\)</span></p>
<p>最大吞吐率为：</p>
<p><span class="math inline">\(TP_{max} = lim_{n\rightarrow \infty} \frac{n}{(k+n-1)\Delta t} = \frac{1}{\Delta t}\)</span></p></li>
<li><p>各段不完全相等的流水线</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-7.jpg" style="zoom:70%;" /></p>
<p>实际吞吐率如下：</p>
<p><span class="math inline">\(TP = \frac{n}{\sum_{i=1}^{k}\Delta t_i+(n-1)max(\Delta t_1, \dots,\Delta t_k)}\)</span></p>
<p>同样的最大吞吐率为：</p>
<p><span class="math inline">\(TP_{max} = \frac{1}{max(\Delta t_1, \dots,\Delta t_k)}\)</span></p></li>
</ol>
<p>解决流水线瓶颈问题的常用方法</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-8.jpg" style="zoom:50%;" /></p>
<ol type="1">
<li><p>细分瓶颈段</p>
<p>对上图<span class="math inline">\(S_3\)</span>，将其划分为3个子流水线段即可</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-9.jpg" style="zoom:50%;" /></p></li>
<li><p>重复设置瓶颈段</p>
<p>使用空间弥补的方法，对$S_3 $只需要设置3个即可</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-10.jpg" style="zoom:50%;" /></p>
<p>重置后的时空图如下：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-11.jpg" style="zoom:50%;" /></p></li>
</ol>
<h4 id="加速比">加速比</h4>
<blockquote>
<p>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比</p>
</blockquote>
<p>即：<span class="math inline">\(S=\frac{T_s}{T_k}\)</span>，<span class="math inline">\(T_s\)</span>为顺序执行所用的时间，<span class="math inline">\(T_k\)</span>为流水线后的时间</p>
<ol type="1">
<li><p>流水线各段时间相等</p>
<p>此时流水线实际加速比为：<span class="math inline">\(S=\frac{nk}{k+n-1}\)</span>，最大加速比为k，当<span class="math inline">\(n\rightarrow \infty\)</span>时取到</p></li>
<li><p>流水线的各段时间不完全相等时 <span class="math display">\[
 S=\frac{n\sum_{i=1}^k \Delta t_i}{\sum_{i=1}^k \Delta t_i+(n-1)max{\Delta t_1,\dots,\Delta t_k}}
 \]</span></p></li>
</ol>
<h4 id="效率">效率</h4>
<blockquote>
<p>流水线中的设备实际使用时间与整个运行时间的比值，即流水线设备的利用率。由于流水线有通过时间和排空时间，所以在连续完成n个任务的时间内，各段并不是满负荷地工作</p>
</blockquote>
<p>从时空图上看，效率就是n个任务占用的时空面积和k个段总的时空面积之比</p>
<ol type="1">
<li><p>各段时间相等：</p>
<p>根据面积比可以得出：<span class="math inline">\(E=\frac{n\Delta t}{(k+n-1)\Delta t} = \frac{n}{k+n-1}\)</span>，可以看出和吞吐率有关系，为<span class="math inline">\(E=TP\Delta t\)</span>，同样的和加速比也有关系，<span class="math inline">\(E = \frac{S}{k}\)</span></p></li>
<li><p>各段时间不相等时： <span class="math display">\[
 E=\frac{n\sum_{i=1}^k \Delta t_i}{k[\sum_{i=1}^k \Delta t_i+(n-1)\times max{\Delta t_1,\dots,\Delta t_k}]}
 \]</span></p></li>
</ol>
<h4 id="流水线设计中的若干问题">流水线设计中的若干问题</h4>
<ol type="1">
<li><p>瓶颈问题</p>
<ul>
<li>理想情况下，流水线在工作时，其中的任务是同步地每一个时钟周期往前流动一段</li>
<li>当流水线各段不均匀时，机器的时钟周期取决于瓶颈段的延迟时间</li>
<li>在设计流水线时，要尽可能使各段时间相等</li>
</ul></li>
<li><p>流水线的额外开销</p>
<ul>
<li>流水寄存器需要建立时间和传输延迟</li>
<li>时钟偏移开销</li>
</ul>
<p>注意几个细节：</p>
<ul>
<li>流水线并不能减少（而且一般是增加）单条指令的执行时间，但却能提高吞吐率</li>
<li>增加流水线的深度（段数）可以提高流水线的性能</li>
<li>流水线的深度受限于流水线的额外开销</li>
<li>当时钟周期小到与额外开销相同时，流水已没意义。因为这时在每一个时钟周期中已没有时间来做有用的工作</li>
</ul></li>
<li><p>冲突问题</p></li>
</ol>
<h3 id="流水线的相关与冲突">3.4 流水线的相关与冲突</h3>
<h4 id="经典5段流水线">经典5段流水线</h4>
<p>虚线代表此处仅花费时钟单元的一半时间, 可以在前半段时间写回后半段从寄存器读取</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-13.jpg" style="zoom:50%;" /></p>
<ol type="1">
<li><p>取指令周期IF</p></li>
<li><p>指令译码/读寄存器周期（ID）</p></li>
<li><p>执行/有效地址计算周期（EX）</p>
<p>4种不同指令所进行的操作不同：</p>
<ul>
<li>存储器访问指令：ALU把所指定的寄存器的内容与偏移量相加，形成用于访存的有效地址</li>
<li>寄存器－寄存器ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读取的数据进行运算</li>
<li>寄存器－立即数ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读取的第一操作数和立即数进行运算</li>
<li>分支指令：ALU把偏移量与PC值相加，形成转移目标的地址。同时，对在前一个周期读出的操作数进行判断，确定分支是否成功</li>
</ul></li>
<li><p>存储器访问／分支完成周期（MEM）</p>
<p>该周期处理的指令只有load、store和分支指令（分支“成功”，就把转移目标地址送入PC）。其他类型的指令在此周期不做任何操作</p></li>
<li><p>写回周期（WB）</p>
<p>ALU运算指令和load指令在这个周期把结果数据写入通用寄存器组</p></li>
</ol>
<p>采用流水线实现时需要解决的问题：</p>
<ol type="1">
<li>要保证不会在同一时钟周期要求同一个功能段做两件不同的工作</li>
<li>避免IF段的访存（取指令）与MEM段的访存（读/写数据）发生冲突</li>
<li>ID段和WB段都要访问同一寄存器文件，<strong>把写操作安排在时钟周期的前半拍完成，把读操作安排在后半拍完成</strong>，解决对同一寄存器的访问冲突</li>
<li>考虑PC的问题，在MEM段进行的分支和IF段取下一个PC的冲突</li>
</ol>
<h4 id="相关与流水线冲突">相关与流水线冲突</h4>
<h5 id="相关">相关</h5>
<blockquote>
<p>两条指令之间存在某种依赖关系。如果两条指令相关，则它们就有可能不能在流水线中重叠执行或者只能部分重叠执行</p>
</blockquote>
<p>有三种类型：</p>
<p><strong>前提条件：对于两个指令i，j且i在j前</strong></p>
<ul>
<li><p><strong>数据相关（真数据相关）</strong></p>
<p>满足下列条件表明j与i数据相关，数据相关具有传递性</p>
<ul>
<li>指令j使用指令i产生的结果</li>
<li>指令j与k数据相关，k与i数据相关</li>
</ul>
<p>寄存器的数据相关比较容易检测，单存储器检测比较复杂，因为有效地址生成的规则复杂</p></li>
<li><p><strong>名相关</strong></p>
<p>如果两条指令使用相同的名，但是它们之间并<strong>没有数据流动</strong>（不存在数据相关），则称这两条指令存在名相关，如果一条指令中的名改变了，并不影响另外一条指令的执行</p>
<ul>
<li>反相关：指令j写的名＝指令i读的名</li>
<li>输出相关：指令j写的名＝指令i写的名</li>
</ul>
<p>通过<strong>换名技术</strong>消除名相关：通过改变指令中操作数的名来消除名相关，对于寄存器操作数进行换名称为寄存器换名</p></li>
<li><p><strong>控制相关</strong></p>
<p>控制相关是指由分支指令引起的相关，有以下两个限制</p>
<ul>
<li>与一条分支指令控制相关的指令不能被移到该分支之前，否则这些指令就不受该分支控制了</li>
<li>如果一条指令与某分支指令不存在控制相关，就不能把该指令移到该分支之后</li>
</ul></li>
</ul>
<h5 id="流水线冲突">流水线冲突</h5>
<blockquote>
<p>是指对于具体的流水线来说，由于相关的存在，使得指令流中的下一条指令不能在指定的时钟周期执行</p>
</blockquote>
<p>带来的问题：</p>
<ul>
<li>导致错误的执行结果</li>
<li>流水线可能会出现停顿，从而降低流水线的效率和实际的加速比</li>
</ul>
<p>当一条指令被暂停时，在该暂停指令之后流出的所有指令都要被暂停，而在该暂停指令之前流出的指令则继续进行（否则就永远无法消除冲突）</p>
<p>有三种类型：</p>
<ul>
<li><p><strong>结构冲突</strong></p>
<p>因硬件资源满足不了指令重叠执行的要求而发生的冲突</p>
<p>有些流水线处理机只有一个存储器，将数据和指令放在一起，访存指令会导致访存冲突</p>
<p><strong>通过插入暂停周期（气泡）</strong>解决，或者设置独立的指令存储器和数据存储器或者设置独立的Cache</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-14.jpg" style="zoom:40%;" /></p>
<p>插入气泡后：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-15.jpg" style="zoom:40%;" /></p>
<p>结构冲突有时候是允许的，可以减少硬件成本</p></li>
<li><p><strong>数据冲突</strong></p>
<p>当指令在流水线中重叠执行时，因需要用到前面指令的执行结果而发生的冲突</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-16.jpg" style="zoom:40%;" /></p>
<p><strong>前提条件：对于两个指令i，j且i在j前</strong>，有以下三种类型：</p>
<ul>
<li><p>写后读冲突RAW</p>
<p>在i写之前j去读，对于真数据相关</p></li>
<li><p>写后写冲突WAW</p>
<p>在i写入之前j先写，对应输出相关</p>
<p>仅发生在这样的流水线中：</p>
<ul>
<li>流水线中不只一个段可以进行写操作</li>
<li>当先前某条指令停顿时，允许其后续指令继续前进</li>
</ul>
<p>我们之前的5段流水线不会发生</p></li>
<li><p>读后写冲突WAR</p>
<p>在i读之前j先写，对应反相关</p>
<p>仅发生这样的流水线中：</p>
<ul>
<li>有些指令的写结果操作提前了，而且有些指令的读操作滞后了</li>
<li>指令被重新排序了</li>
</ul>
<p>我们之前的5段流水线不会发生</p></li>
</ul>
<p><strong>通过定向技术（也称为旁路或短路），减少数据冲突引起的停顿：</strong></p>
<p>关键思想：在某条指令产生计算结果之前，后面等待使用该结果的指令并不一定立即需要该结果，如果能够将该计算结果从其产生的地方（ALU出口）直接送到其他指令需要它的地方（ALU入口），那么就可以避免停顿。</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-17.jpg" style="zoom:40%;" /></p>
<p>并不是所有的数据冲突都可以用定向技术来解决，必要时需要增加<strong>暂停</strong>：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-18.jpg" style="zoom:40%;" /></p>
<p><strong>通过编译器解决数据冲突</strong></p>
<p>改变指令的执行顺序解决数据冲突</p></li>
<li><p><strong>控制冲突</strong></p>
<p>流水线遇到分支指令和其他会改变PC值的指令所引起的冲突</p>
<p>处理分支指令最简单的方法：排空流水线，给流水线带来3个时钟周期的延迟</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-19.jpg" style="zoom:70%;" /></p>
<p>由分支指令引起的延迟为<strong>分支延迟</strong></p>
<p>可采取两种措施来减少分支延迟</p>
<ul>
<li>在流水线中尽早判断出分支转移是否成功</li>
<li>尽早计算出分支目标地址</li>
</ul>
<p>下面的讨论中，我们假设：这两步工作被提前到ID段完成，即分支指令是在ID段的末尾执行完成，所带来的分支延迟为一个时钟周期</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-20.jpg" style="zoom:50%;" /></p>
<p><strong>减少分支延迟的方法</strong>:</p>
<p>共同点:</p>
<ul>
<li>对分支的处理方法在程序的执行过程中始终是不变的，是静态的</li>
<li><p>要么总是预测分支成功，要么总是预测分支失败</p></li>
<li><p><strong>预测分支失败</strong></p>
<p>允许分支指令后的指令继续在流水线中流动，就好象什么都没发生似的 若确定分支失败，将分支指令看作是一条普通指令，流水线正常流动</p>
<p>要保证：分支结果出来之前不会改变处理机的状态，以便一旦猜错时，处理机能够回退到原先的状态</p></li>
</ul></li>
<li><p><strong>预测分支成功</strong></p>
<p>假设分支转移成功，并从分支目标地址处取指令执行。 起作用的前题：先知道分支目标地址，后知道分支是否成功 前述5段流水线中，这种方法没有任何好处</p></li>
<li><p><strong>延迟分支</strong></p>
<p>从逻辑上“延长”分支指令的执行时间。把延迟分支看成是由原来的分支指令和若干个延迟槽构成，不管分支是否成功，都要按顺序执行延迟槽中的指令</p>
<pre><code>  &lt;img src=&quot;/assets/Note/计算机系统结构-张晨曦-第二版/3-21.jpg&quot; style=&quot;zoom:70%;&quot; /&gt;</code></pre>
<p>分支延迟指令的调度:</p>
<ul>
<li><p>从前调度</p>
<ul>
<li>从目标处调度</li>
</ul></li>
<li><p>从失败处调度</p></li>
</ul>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-22.jpg" style="zoom:70%;" /></p>
<pre><code>  分支延迟受到两个方面的限制：</code></pre>
<ul>
<li>可以被放入延迟槽中的指令要满足一定的条件
<ul>
<li>编译器预测分支转移方向的能力。</li>
</ul>
<p>进一步改进：分支取消机制（取消分支） 当分支的实际执行方向和事先所预测的一样时，执行分支延迟槽中的指令，否则就将分支延迟槽中的指令转化成一个空操作</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-23.jpg" style="zoom:70%;" /></p></li>
</ul></li>
</ul>
<h3 id="向量处理机">3.5 向量处理机</h3>
<blockquote>
<p>在流水线处理机中，设置向量数据表示和相应的向量指令，称为向量处理机。 不具有向量数据表示和相应的向量指令的流水线处理机，称为标量处理机</p>
</blockquote>
<h2 id="第四章-指令级并行">第四章 指令级并行</h2>
<h3 id="指令级并行的概念-ilp">4.1 指令级并行的概念 ILP</h3>
<p>几乎所有的处理机都利用流水线来使指令重叠并行执行，以达到提高性能的目的。这种指令之间存在的潜在并行性称为指令级并行 ILP：Instruction-Level Parallelism</p>
<h3 id="指令的调度">4.2 指令的调度</h3>
<h4 id="静态和动态调度">静态和动态调度</h4>
<ul>
<li><p>静态调度</p>
<p><strong>依靠编译器</strong>对代码进行静态调度，以减少相关和冲突。它不是在程序执行的过程中、而是在编译期间进行代码调度和优化。通过把相关的指令拉开距离来减少可能产生的停顿</p></li>
<li><p>动态调度</p>
<p>在程序的执行过程中，<strong>依靠专门硬件</strong>对代码进行调度，减少数据相关导致的停顿</p>
<p>优点：</p>
<ol type="1">
<li>能够处理一些在编译时情况不明的相关（比如涉及到存储器访问的相关），并简化了编译器</li>
<li>能够使本来是面向某一流水线优化编译的代码在其他的流水线（动态调度）上也能高效地执行</li>
</ol>
<p>但增加了硬件复杂性</p></li>
</ul>
<h4 id="非线性流水线的调度问题">非线性流水线的调度问题</h4>
<p>非线性流水线中由于有些段需要在时间上复用，就不能像线性流水线那样逐时段连续地输入指令。把前一条指令输入开始到下一条指令输入为止的时间差，称为<strong>启动距离</strong></p>
<p>那些会引起冲突的启动距离，被称为禁止启动距离。将在任何时间都不会发生冲突的启动距离称为启动循环</p>
<h4 id="最优调度方法">最优调度方法</h4>
<p>为了避免冲突，就要对指令输入流水线的时间进行控制，这个任务就是流水线的无冲突调度。方案如下：</p>
<ol type="1">
<li><p><strong>根据预约表写出禁止向量</strong></p>
<p>禁止向量：各个段内的X标记的差的集合</p></li>
<li><p><strong>由禁止向量变换成初始冲突向量</strong></p>
<p>使用<span class="math inline">\(初始冲突向量：C_0=(C_mC_{m-1}\dots C_2C_1)\)</span>，m为冲突向量的最大值，根据禁止向量，令<span class="math inline">\(C_m = 1\)</span>，仅当<span class="math inline">\(m \in 禁止向量\)</span></p></li>
<li><p><strong>根据初始冲突向量推算出全部冲突向量</strong></p>
<p>从初始冲突向量出发，检查其中0的位，假设初始向量中<span class="math inline">\(C_k = 0\)</span>，就将初始向量右移K位之后和初始向量执行或运算，若得到一个新的向量，继续检查0的位，执行右移运算，并和<span class="math inline">\(C_0\)</span>做或运算，直到不存在新的向量</p></li>
<li><p><strong>画出表示冲突向量迁移的有向图</strong></p>
<p>节点值为向量，边权为右移的位数，构建有向图</p></li>
<li><p><strong>从全部调度方案中选出最优调度法</strong></p>
<p>从<strong>各个闭合回路</strong>（不需要从初始向量出发）中找出平均间隔最小的一个，平均间隔为边权和除以边数</p></li>
</ol>
<p>例题：</p>
<p>某单功能流水线预约表如下：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>t1</th>
<th>t2</th>
<th>t3</th>
<th>t4</th>
<th>t5</th>
<th>t6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>S1</td>
<td>×</td>
<td></td>
<td></td>
<td></td>
<td>×</td>
<td></td>
</tr>
<tr class="even">
<td>S2</td>
<td></td>
<td>×</td>
<td></td>
<td></td>
<td></td>
<td>×</td>
</tr>
<tr class="odd">
<td>S3</td>
<td></td>
<td></td>
<td>×</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>S4</td>
<td></td>
<td></td>
<td></td>
<td>×</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>请确定最佳调度方案。按此方案输入8个指令时，性能指标如何？</p>
<p>禁止向量为：<span class="math inline">\(F={4}\)</span>，初始冲突向量为：<span class="math inline">\(C_0 = (1000)\)</span></p>
<p>获取状态转换图：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-1.jpg" style="zoom:50%;" /></p>
<p>其中5权值边可以看作是0C，右移5位形成的，构建成新的闭合回路</p>
<p>可以获得调度方案如下：</p>
<table>
<thead>
<tr class="header">
<th>回路</th>
<th>平均间隔</th>
<th>回路</th>
<th>平均间隔</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1,5</td>
<td>6/2</td>
<td>2,1,2,5</td>
<td>10/4</td>
</tr>
<tr class="even">
<td>1,1,5</td>
<td>7/3</td>
<td>2,3,5</td>
<td>10/3</td>
</tr>
<tr class="odd">
<td><strong>1,1,1,5</strong></td>
<td><strong>8/4</strong></td>
<td>3,5</td>
<td>8/2</td>
</tr>
<tr class="even">
<td>1,2,5</td>
<td>8/3</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="odd">
<td>1,2,3,5</td>
<td>11/4</td>
<td>3,2,5</td>
<td>10/3</td>
</tr>
<tr class="even">
<td>2,5</td>
<td>7/3</td>
<td>3,2,1,5</td>
<td>11/4</td>
</tr>
<tr class="odd">
<td>2,1,5</td>
<td>8/3</td>
<td>2,3</td>
<td>5/2</td>
</tr>
</tbody>
</table>
<p>最佳方案为1，1，1，5，平均最少延时为2拍</p>
<p>8个指令进入流水线的时空图如下：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-2.jpg" style="zoom:50%;" /></p>
<p>吞吐率 P = 8/(17Δt)； 加速比 S = (6Δt×8)/(17Δt)=48/17 效率 E = (6Δt×8) /(17Δt×4)=12/17</p>
<h4 id="动态调度的基本思想">动态调度的基本思想</h4>
<p>到目前为止我们所使用流水线的最大的局限性，指令必须按序流出和执行，一旦一条指令受阻，其后的指令都将停顿，可以通过乱序执行解决。动态调度的流水线支持多条指令同时处于执行当中。</p>
<p>指令乱序完成带来的最大问题：</p>
<ul>
<li><p>异常处理比较复杂</p></li>
<li><p>动态调度要保持正确的异常行为</p>
<p>只有那些在程序严格按程序顺序执行时会发生的异常，才能真正发生</p></li>
</ul>
<h4 id="tomasulo算法">Tomasulo算法</h4>
<blockquote>
<p>记录和检测指令相关，操作数一旦就绪就立即执行，把发生RAW冲突的可能性减少到最小通过寄存器换名来消除WAR冲突和WAW冲突</p>
</blockquote>
<p>基于MIPS的Tomasulo基本结构：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-3.jpg" style="zoom:50%;" /></p>
<ul>
<li><p>保留站</p>
<p>每个保留站中保存一条已经流出并等待到本功能部件执行的指令（相关信息）包括：操作码、操作数以及用于检测和解决冲突的信息</p>
<p>上图有3个浮点加法器保留站，2个浮点乘法器保留站</p>
<p>每个保留站都有一个标识字段，唯一地标识了该保留站</p></li>
<li><p>公共数据总线CDB</p>
<p>所有功能部件的计算结果都是送到CDB上，由它把这些结果直接送到（播送到）各个需要该结果的地方。在具有多个执行部件且采用多流出（即每个时钟周期流出多条指令）的流水线中，需要采用多条CDB</p></li>
<li><p>load缓冲器和store缓冲器</p>
<p>存放读/写存储器的数据或地址 load缓冲器的作用有3个：</p>
<ul>
<li>存放用于计算有效地址的分量</li>
<li>记录正在进行的load访存，等待存储器的响应</li>
<li>保存已经完成了的load的结果（即从存储器取来的数据），等待CDB传输</li>
</ul>
<p>store缓冲器的作用有3个：</p>
<ul>
<li>存放用于计算有效地址的分量</li>
<li>保存正在进行的store访存的目标地址，该store正在等待存储数据的到达</li>
<li>保存该store的地址和数据，直到存储部件接收</li>
</ul></li>
<li><p>浮点寄存器FP</p>
<p>它们通过一对总线连接到功能部件，并通过CDB连接到store缓冲器</p></li>
<li><p>指令队列</p>
<p>指令部件送来的指令放入指令队列 指令队列中的指令按先进先出的顺序流出</p></li>
<li><p>运算部件</p></li>
</ul>
<p>Tomasulo算法具有以下两个特点:</p>
<ul>
<li>冲突检测和指令执行控制是分布的</li>
<li>计算结果通过CDB直接从产生它的保留站传送到所有需要它的功能部件，而不用经过寄存器</li>
</ul>
<p>指令执行的步骤：</p>
<ol type="1">
<li><p><strong>流出：从指令队列的头部取一条指令</strong></p>
<ul>
<li>如果该指令的操作所要求的保留站有空闲的，就把该指令送到该保留站</li>
<li>如果其操作数在寄存器中已经就绪，就将这些操作数送入保留站</li>
<li>如果其操作数还没有就绪，就把将产生该操作数的保留站的标识送入保留站</li>
<li>一旦被记录的保留站完成计算，它将直接把数据送给保留站</li>
<li>完成对目标寄存器的预约工作</li>
<li>如果没有空闲的保留站，指令就不能流出</li>
</ul></li>
<li><p><strong>执行</strong></p>
<ul>
<li>当两个操作数都就绪后，本保留站就用相应的功能部件开始执行指令规定的操作</li>
<li>load和store指令的执行需要两个步骤：
<ul>
<li>计算有效地址（要等到基地址寄存器就绪）</li>
<li>把有效地址放入load或store缓冲器</li>
</ul></li>
</ul></li>
<li><p><strong>写结果</strong></p>
<p>功能部件计算完毕后，就将计算结果放到CDB上，所有等待该计算结果的寄存器和保留站（包括store缓冲器）都同时从CDB上获得所需要的数据</p></li>
</ol>
<p>Tomasulo示例：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-4.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-5.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-6.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-7.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-8.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-9.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-10.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-11.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-12.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-13.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-14.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-15.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-16.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-17.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-18.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-19.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-20.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-21.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-22.jpg" style="zoom:50%;" /></p>
<h3 id="动态分支预测技术">4.3 动态分支预测技术</h3>
<p>所开发的ILP越多，控制相关的制约就越大，分支预测就要有更高的准确度</p>
<p><strong>动态分支预测：</strong>在程序运行时，根据分支指令过去的表现来预测其将来的行为</p>
<p>分支预测的有效性取决于:</p>
<ul>
<li><p>预测的准确性</p></li>
<li><p>预测正确和不正确两种情况下的分支开销</p>
<p>决定分支开销的因素</p>
<ul>
<li>流水线的结构</li>
<li>预测的方法</li>
<li>预测错误时的恢复策略等</li>
</ul></li>
<li><p>采用动态分支预测技术的目的</p>
<ul>
<li>预测分支是否成功</li>
<li>尽快找到分支目标地址（或指令）</li>
</ul></li>
</ul>
<h4 id="采用分支历史表-bht">采用分支历史表 BHT</h4>
<blockquote>
<p>最简单的动态分支预测方法，用BHT来记录分支指令最近一次或几次的执行情况（成功或不成功），并据此进行预测</p>
</blockquote>
<ul>
<li><p>只有1个预测位的分支预测缓冲</p>
<p>记录分支指令最近一次的历史，BHT中只需要1位二进制位</p></li>
<li><p>采用两位二进制位来记录历史</p>
<p>提高预测的准确度，研究结果表明：两位分支预测的性能与n位（n&gt;2）分支预测的性能差不多</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-23.jpg" style="zoom:50%;" /></p></li>
</ul>
<p>适用情况：</p>
<p><strong>判定分支是否成功所需的时间大于确定分支目标地址所需的时间</strong></p>
<p>由于判定分支是否成功和计算分支目标地址都是在ID段完成，所以BHT方法不会给该流水线带来好处。</p>
<h4 id="采用分支目标缓冲器btb">采用分支目标缓冲器BTB</h4>
<p>目标：将分支的开销降为 0</p>
<p>方法：分支目标缓冲</p>
<ul>
<li>将分支成功的分支指令的地址和它的分支目标地址都放到一个缓冲区中保存起来，缓冲区以分支指令的地址作为标识</li>
<li>这个缓冲区就是分支目标缓冲器（Branch-Target Buffer，简记为BTB，或者Branch-Target Cache）</li>
</ul>
<p>结构如下：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-24.jpg" style="zoom:50%;" /></p>
<p>看成是用专门的硬件实现的一张表格。 表格中的每一项至少有两个字段：</p>
<ul>
<li>执行过的成功分支指令的地址；（作为该表的匹配标识 ）</li>
<li>预测的分支目标地址</li>
</ul>
<p>执行流程如下：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-25.jpg" style="zoom:50%;" /></p>
<p>BTB的另一种形式:</p>
<p>在分支目标缓冲器中存放一条或者多条分支目标处的指令，有三个好处：</p>
<ul>
<li>更快地获得分支目标处的指令</li>
<li>可以一次提供分支目标处的多条指令，这对于多流出处理器是很有必要的</li>
<li>使我们可以进行称为分支折叠（branch folding）的优化</li>
</ul>
<h4 id="基于硬件的前瞻执行">基于硬件的前瞻执行</h4>
<p>基本思想（延迟写入）：</p>
<p>对分支指令的结果进行猜测，并假设这个猜测总是对的，然后按这个猜测结果继续取、流出和执行后续的指令。只是执行指令的结果不是写回到寄存器或存储器，而是放到一个称为ROB（ReOrder Buffer）的缓冲器中。等到相应的指令得到“确认”（commit）（即确实是应该执行的）之后，才将结果写入寄存器或存储器</p>
<ol type="1">
<li><p>基于硬件的前瞻执行结合了三种思想</p>
<ul>
<li>动态分支预测。用来选择后续执行的指令</li>
<li>在控制相关的结果尚未出来之前，前瞻地执行后续指令</li>
<li>用动态调度对基本块的各种组合进行跨基本块的调度</li>
</ul></li>
<li><p>对Tomasulo算法加以扩充，就可以支持前瞻执行</p>
<p>把Tomasulo算法的写结果和指令完成加以区分，分成两个不同的段：</p>
<ul>
<li><p>写结果段</p>
<p>把前瞻执行的结果写到ROB中通过CDB在指令之间传送结果，供需要用到这些结果的指令使用</p></li>
<li><p>指令确认段</p>
<p>在分支指令的结果出来后，对相应指令的前瞻执行给予确认。如果前面所做的猜测是对的，把在ROB中的结果写到寄存器或存储器。如果发现前面对分支结果的猜测是错误的，那就不予以确认，并从那条分支指令的另一条路径开始重新执行。</p></li>
</ul></li>
</ol>
<p><strong>实现前瞻的关键思想</strong>：允许指令乱序执行，但必须顺序确认</p>
<p>符合前瞻执行的结构：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-26.jpg" style="zoom:50%;" /></p>
<p>ROB中的每一项由以下4个字段组成：</p>
<ul>
<li><p>指令类型</p>
<p>指出该指令是分支指令、store指令或寄存器操作指令</p></li>
<li><p>目标地址 给出指令执行结果应写入的目标寄存器号（如果是load和ALU指令）或存储器单元的地址（如果是store指令）</p></li>
<li><p>数据值字段 用来保存指令前瞻执行的结果，直到指令得到确认</p></li>
<li><p>就绪字段 指出指令是否已经完成执行并且数据已就绪</p></li>
</ul>
<p>Tomasulo算法中保留站的换名功能是由ROB来完成的</p>
<p><strong>采用前瞻执行机制后，指令的执行步骤</strong>：</p>
<ol type="1">
<li><p>流出</p>
<ul>
<li>从浮点指令队列的头部取一条指令</li>
<li>如果有空闲的保留站（设为r）且有空闲的ROB项（设为b），就流出该指令，并把相应的信息放入保留站r和ROB项b</li>
<li>如果保留站或ROB全满，便停止流出指令，直到它们都有空闲的项</li>
</ul></li>
<li><p>执行</p>
<ul>
<li>如果有操作数尚未就绪，就等待，并不断地监测CDB。(检测RAW冲突)</li>
<li>当两个操作数都已在保留站中就绪后，就可以执行该指令的操作</li>
</ul></li>
<li><p>写结果</p>
<ul>
<li>当结果产生后，将该结果连同本指令在流出段所分配到的ROB项的编号放到CDB上，经CDB写到ROB以及所有等待该结果的保留站</li>
<li>释放产生该结果的保留站</li>
<li>store指令在本阶段完成，其操作为：
<ul>
<li>如果要写入存储器的数据已经就绪，就把该数据写入分配给该store指令的ROB项。</li>
<li>否则，就监测CDB，直到那个数据在CDB上播送出来，这时才将之写入分配给该store指令的ROB项。</li>
</ul></li>
</ul></li>
<li><p>确认</p>
<p>对分支指令、store指令以及其他指令的处理不同</p>
<ul>
<li><p>其他指令（除分支指令和store指令）</p>
<p>当该指令到达ROB队列的头部而且其结果已经就绪时，就把该结果写入该指令的目标寄存器，并从ROB中删除该指令</p></li>
<li><p>store指令</p>
<p>处理与上面类似，只是它把结果写入存储器</p></li>
<li><p>分支指令</p>
<ul>
<li>当预测错误的分支指令到达ROB队列的头部时，清空ROB，并从分支指令的另一个分支重新开始执行（错误的前瞻执行）</li>
<li>当预测正确的分支指令到达ROB队列的头部时，该指令执行完毕</li>
</ul></li>
</ul></li>
</ol>
<h3 id="多指令流出技术">4.4 多指令流出技术</h3>
<ol type="1">
<li>多流出处理机有两种基本风格
<ul>
<li>超标量
<ul>
<li>在每个时钟周期流出的指令条数不固定，依代码的具体情况而定。（有上限）</li>
<li>设这个上限为n，就称该处理机为n流出</li>
<li>可以通过编译器进行静态调度，也可以基于Tomasulo算法进行动态调度</li>
</ul></li>
<li>超长指令字VLIW
<ul>
<li>在每个时钟周期流出的指令条数是固定的，这些指令构成一条长指令或者一个指令包。</li>
<li>指令包中，指令之间的并行性是通过指令显式地表示出来的。</li>
<li>指令调度是由编译器静态完成的</li>
</ul></li>
</ul></li>
<li>超标量处理机与VLIW处理机相比有两个优点
<ul>
<li>超标量结构对程序员是透明的，因为处理机能自己检测下一条指令能否流出，从而不需要重新排列指令来满足指令的流出。</li>
<li>即使是没有经过编译器针对超标量结构进行调度优化的代码或是旧的编译器生成的代码也可以运行，当然运行的效果不会很好</li>
</ul></li>
</ol>
<h4 id="基于动态调度的多流出技术">基于动态调度的多流出技术</h4>
<p>扩展Tomasulo算法：支持两路超标量</p>
<ul>
<li>每个时钟周期流出两条指令</li>
<li>一条是整数指令，另一条是浮点指令</li>
</ul>
<ol type="1">
<li><p>采用一种比较简单的方法</p>
<ul>
<li>指令按顺序流向保留站，否则会破坏程序语义</li>
<li>将整数所用的表结构与浮点用的表结构分离开，分别进行处理，这样就可以同时地流出一条浮点指令和一条整数指令到各自的保留站</li>
</ul></li>
<li><p>有两种不同的方法可以实现多流出</p>
<p>关键在于：对保留站的分配和对流水线控制表格的修改</p>
<ul>
<li>在半个时钟周期里完成流出步骤，这样一个时钟周期就能处理两条指令。</li>
<li>设置一次能同时处理两条指令的逻辑电路</li>
</ul></li>
</ol>
<h4 id="超长指令字技术vliw">超长指令字技术（VLIW）</h4>
<ul>
<li>把能并行执行的多条指令组装成一条很长的指令。（100多位到几百位）</li>
<li>设置多个功能部件</li>
<li>指令字被分割成一些字段，每个字段称为一个操作槽，直接独立地控制一个功能部件</li>
<li>在VLIW处理机中，所有的处理和指令安排都是由编译器完成的</li>
</ul>
<p>VLIW存在的一些问题</p>
<ul>
<li><p>程序代码长度增加了</p>
<ul>
<li>提高并行性而进行的大量的循环展开</li>
<li>指令字中的操作槽并非总能填满</li>
</ul></li>
<li><p>采用了锁步机制</p>
<p>任何一个操作部件出现停顿时，整个处理机都要停顿</p></li>
<li><p>机器代码的不兼容性</p></li>
</ul>
<h4 id="多流出处理器受到的限制">多流出处理器受到的限制</h4>
<ol type="1">
<li>程序所固有的指令级并行性</li>
<li>硬件实现上的困难</li>
<li>超标量和超长指令字处理器固有的技术限制</li>
</ol>
<h5 id="超流水线处理机">超流水线处理机</h5>
<ul>
<li>将每个流水段进一步细分，这样在一个时钟周期内能够分时流出多条指令。这种处理机称为超流水线处理机。</li>
<li>对于一台每个时钟周期能流出n条指令的超流水线计算机来说，这n条指令不是同时流出的，而是每隔1/n个时钟周期流出一条指令实际上该超流水线计算机的流水线周期为1/n个时钟周期</li>
</ul>
<h2 id="第5章-存储层次">第5章 存储层次</h2>
<h3 id="存储器的层次结构">5.1 存储器的层次结构</h3>
<p>假设：S（容量），<span class="math inline">\(T_A\)</span>（访问时间），C（每位价格）</p>
<p>假设由M1和M2构成的两级存储层次</p>
<p>M1的参数为：<span class="math inline">\(S_1,T_{A1},C_1\)</span></p>
<p>M2的参数为：<span class="math inline">\(S_1,T_{A1},C_1\)</span></p>
<ol type="1">
<li><p>每位价格：<span class="math inline">\(C=\frac{C_1S_1+C_2S_2}{S_1+S_2}\)</span></p></li>
<li><p>命中率和失效率</p>
<ul>
<li>命中率：<span class="math inline">\(H=\frac{N_1}{N_1+N_2}\)</span>，N1为访问M1的次数，N2为访问M2的次数</li>
<li>失效率：<span class="math inline">\(F=1-H\)</span></li>
</ul></li>
<li><p>平均访问时间 <span class="math display">\[
 \begin{align}
 T_A &amp;= HT_{A1}+(1-H)(T_{A1}+T_M) \nonumber \\
 &amp;= T_{A1}+(1-H)T_M \nonumber \\
 &amp;= T_A1+FT_M \nonumber \\
 \end{align} \nonumber
 \\
 T_M 为失效开销，从向M_2发出访问请求到把整个数据块调入M_1中所需的时间 \\
 T_M = T_{A2} + T_B \\
 T_B为传送一个信息块所需的时间
 \]</span></p></li>
</ol>
<ul>
<li>“Cache－主存”层次：弥补主存速度的不足</li>
<li>“主存－辅存”层次： 弥补主存容量的不足</li>
</ul>
<h3 id="cache的基本知识">5.2 Cache的基本知识</h3>
<h4 id="映像规则">映像规则</h4>
<ul>
<li><p>全相联规则</p>
<p>主存中的任一块可以被放置到Cache中的任意一个位置</p></li>
<li><p>直接映像</p>
<p>主存中的每一块只能被放置到Cache中唯一的一个位置，取模运算（模Cache的块数）</p></li>
<li><p>组相联映像</p>
<p>主存中的每一块可以被放置到Cache中唯一的一个组中的任何一个位置</p>
<p>若主存第i 块映象到第k 组，则：$K=i G $，G为Cache的组数</p>
<p>n路组相联，每组中有n个块，n也称为相联度，相联度越高，Cache空间的利用率就越高，块冲突概率就越低，失效率也就越低</p></li>
</ul>
<h4 id="查找算法">查找算法</h4>
<p>通过查找目录表来实现</p>
<p>目录表结构：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-1.png" style="zoom:48%;" /></p>
<h4 id="替换算法">替换算法</h4>
<ul>
<li><p>随机法</p></li>
<li><p>先进先出法FIFO</p></li>
<li><p>最近最少使用法LRU</p>
<p>选择近期最少被访问的块作为被替换的块，选择最久没有被访问过的块作为被替换的块，失效率低</p></li>
</ul>
<h4 id="写策略">写策略</h4>
<p>“写”在所有访存操作中所占的比例：</p>
<p>统计结果表明，对于一组给定的程序：</p>
<ul>
<li>load指令：26％</li>
<li>store指令：9％</li>
</ul>
<p>“写”在所有访存操作中所占的比例：9％/(100％＋26％＋9％)≈7％（100%指：取指令的指令访存） “写”在访问数据Cache操作中所占的比例：9％/(26％＋9％)≈25％</p>
<p>“写”操作必须在确认是命中后才可进行，“写”访问有可能导致Cache和主存内容的不一致</p>
<p>两种写策略：</p>
<ul>
<li><p>写直达法：</p>
<p>执行“写”操作时，不仅写入Cache，而且也写入下一级存储器</p>
<p>易于实现，一致性好</p></li>
<li><p>写回法：</p>
<p>执行“写”操作时，只写入Cache。仅当Cache中相应的块被替换时，才写回主存</p>
<p>速度快，所使用的存储器带宽较低</p></li>
</ul>
<p>采用写直达法时，若在进行“写”操作的过程中CPU必须等待，直到“写”操作结束，则称CPU写停顿，减少写停顿的一种常用的优化技术：<strong>采用写缓冲器</strong></p>
<p>“写”操作时的调块：</p>
<ul>
<li><p>按写分配(写时取)</p>
<p>写失效时，先把所写单元所在的块调入Cache，再行写入</p></li>
<li><p>不按写分配(绕写法)</p>
<p>写失效时，直接写入下一级存储器而不调块</p></li>
</ul>
<p>写策略与调块：</p>
<ul>
<li>写回法 ── 按写分配</li>
<li>写直达法 ── 不按写分配</li>
</ul>
<h4 id="cache的性能分析">Cache的性能分析</h4>
<ul>
<li><p>失效率</p>
<ul>
<li>与硬件速度无关</li>
<li>容易产生一些误导</li>
</ul></li>
<li><p>平均访存时间</p>
<p><strong>平均访存时间 ＝ 命中时间＋失效率×失效开销</strong></p></li>
<li><p>程序执行时间</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-2.png" style="zoom:48%;" /></p></li>
</ul>
<p>Cache失效对于一个CPI较小而时钟频率较高的CPU来说，影响是双重的：</p>
<ul>
<li><p>CPIexecution越低，固定周期数的Cache失效开销的相对影响就越大</p></li>
<li><p>在计算CPI时，失效开销的单位是时钟周期数。因此，即使两台计算机的存储层次完全相同，时钟频率较高的CPU的失效开销较大，其CPI中存储器停顿这部分也就较大</p>
<p><strong>存储器停顿时钟周期数＝访存次数×失效率×失效开销</strong></p></li>
</ul>
<p>因此Cache对于低CPI、高时钟频率的CPU来说更加重要</p>
<h4 id="改进cache的性能">改进Cache的性能</h4>
<ul>
<li><strong>平均访存时间＝命中时间＋失效率×失效开销</strong></li>
<li>可以从三个方面改进Cache的性能：
<ul>
<li>降低失效率</li>
<li>减少失效开销</li>
<li>减少Cache命中时间</li>
</ul></li>
</ul>
<h3 id="降低cache失效率的方法">5.3 降低Cache失效率的方法</h3>
<p>三种失效：</p>
<ul>
<li><p>强制失效</p>
<p>当第一次访问一个块时，该块不在Cache中，需从下一级存储器中调入Cache</p></li>
<li><p>容量失效</p>
<p>如果程序执行时所需的块不能全部调入Cache中，则当某些块被替换后，若又重新被访问，就会发生失效</p></li>
<li><p>冲突失效</p>
<p>在组相联或直接映象Cache中，若太多的块映象到同一组(块)中，则会出现该组中某个块被别的块替换(即使别的组或块有空闲位置)，然后又被重新访问的情况</p></li>
</ul>
<p>失效和Cache容量大小的关系：</p>
<ul>
<li>相联度越高，冲突失效就越少</li>
<li>强制性失效和容量失效不受相联度的影响</li>
<li>强制性失效不受Cache容量的影响，但容量失效却随着容量的增加而减少</li>
<li>大小为N的直接映象Cache的失效率约等于大小为N/2的2路组相联Cache的失效率</li>
</ul>
<p>减少三种失效的方法：</p>
<ul>
<li>强制性失效：增加块大小，预取</li>
<li>容量失效：增加容量</li>
<li>冲突失效：提高相联度</li>
</ul>
<p><strong>许多降低失效率的方法会增加命中时间或失效开销</strong></p>
<h4 id="增加cache块大小">1. 增加Cache块大小</h4>
<p>对于给定的Cache容量，当块大小增加时，失效率开始是下降，后来反而上升了</p>
<p>原因：</p>
<ul>
<li>一方面它减少了强制性失效</li>
<li>另一方面，由于增加块大小会减少Cache中块的数目，所以有可能会增加冲突失效</li>
</ul>
<p>Cache容量越大，使失效率达到最低的块大小就越大</p>
<p>增加块大小会增加失效开销</p>
<h4 id="提高相联度">2. 提高相联度</h4>
<p>采用相联度超过8的方案的实际意义不大</p>
<p>2:1 Cache经验规则：容量为N的直接映象Cache的失效率和容量为N/2的2路组相联Cache的失效率差不多相同</p>
<p>提高相联度是以增加命中时间为代价</p>
<h4 id="增加cache的容量">3. 增加Cache的容量</h4>
<p>最直接的方法是增加Cache的容量 缺点:</p>
<ul>
<li>增加成本</li>
<li>可能增加命中时间</li>
</ul>
<p>这种方法在片外Cache中用得比较多</p>
<h4 id="victim-cache">4. Victim Cache</h4>
<p>一种能减少冲突失效次数而又不影响时钟频率的方法 基本思想：</p>
<p>在Cache和它从下一级存储器调数据的通路之间设置一个全相联的小Cache，用于存放被替换出去的块(称为Victim)，以备重用</p>
<p>作用：对于减小冲突失效很有效，特别是对于小容量的直接映象数据Cache，作用尤其明显</p>
<h4 id="伪相联-cache">5. 伪相联 Cache</h4>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-3.png" style="zoom:60%;" /></p>
<p>伪相联Cache的优点：</p>
<ul>
<li>命中时间小</li>
<li>失效率低</li>
</ul>
<p>基本思想及工作原理：</p>
<p>在逻辑上把直接映象Cache的空间上下平分为两个区。对于任何一次访问，伪相联Cache先按直接映象Cache的方式去处理。若命中，则其访问过程与直接映象Cache的情况一样。若不命中，则再到另一区相应的位置去查找。若找到，则发生了伪命中，否则就只好访问下一级存储器</p>
<h4 id="硬件预取">6. 硬件预取</h4>
<ul>
<li>指令和数据都可以预取</li>
<li>预取内容既可放入Cache，也可放在外缓冲器中。例如：指令流缓冲器</li>
<li>指令预取通常由Cache之外的硬件完成</li>
</ul>
<p>平均访存时间预取 ＝命中时间＋失效率×预取命中率×1＋失效率×（1－预取命中率）×失效开销</p>
<h4 id="编译器控制的预取">7. 编译器控制的预取</h4>
<p>在编译时加入预取指令，在数据被用到之前发出预取请求</p>
<h4 id="编译器优化">8. 编译器优化</h4>
<p>在编译时，对程序中的指令和数据进行重新组织，以降低Cache失效率</p>
<p>数组合并技术、内外循环交换技术、循环融合技术</p>
<h3 id="减少cache失效开销">5.4 减少Cache失效开销</h3>
<h4 id="让读失效优先于写">1. 让读失效优先于写</h4>
<p>Cache中的写缓冲器导致对存储器访问的复杂化：</p>
<p>写缓冲器进行的写入操作是滞后进行的，所以该缓冲器也被称为后行写数缓冲器</p>
<p>解决问题的方法(读失效的处理)：</p>
<ul>
<li>推迟对读失效的处理：（缺点：读失效的开销增加，如50％）</li>
<li>检查写缓冲器中的内容</li>
</ul>
<p>在写回法Cache中，也可采用写缓冲器</p>
<h4 id="写缓冲合并">2. 写缓冲合并</h4>
<ul>
<li>提高写缓冲器的效率</li>
<li>写直达Cache：依靠写缓冲来减少对下一级存储器写操作的时间</li>
<li>如果写缓冲器为空，就把数据和相应地址写入该缓冲器</li>
<li>如果写缓冲器中已经有了待写入的数据，就要把这次的写入地址与写缓冲器中已有的所有地址进行比较，看是否有匹配的项。如果有地址匹配而对应的位置又是空闲的，就把这次要写入的数据与该项合并。这就叫写缓冲合并</li>
<li>如果写缓冲器满且又没有能进行写合并的项，就必须等待</li>
</ul>
<p><strong>提高了写缓冲器的空间利用率，而且还能减少因写缓冲器满而要进行的等待时间</strong></p>
<h4 id="请求字处理技术">3. 请求字处理技术</h4>
<ul>
<li>请求字：从下一级存储器调入Cache的块中，只有一个字是立即需要的</li>
<li>应尽早把请求字发送给CPU：
<ul>
<li>尽早重启动：调块时，从块的起始位置开始读起。一旦请求字到达，就立即发送给CPU，让CPU继续执行</li>
<li>请求字优先：调块时，从请求字所在的位置读起。这样，第一个读出的字便是请求字。将之立即发送给CPU</li>
</ul></li>
</ul>
<p>这种技术在以下情况下效果不大：</p>
<ul>
<li>Cache块较小</li>
<li>下一条指令正好访问同一Cache块的另一部分</li>
</ul>
<h4 id="非阻塞cache技术">4. 非阻塞Cache技术</h4>
<p>即为：Cache失效时仍允许CPU进行其他的命中访问。即允许“失效下命中”</p>
<h4 id="采用两级cache">5. 采用两级Cache</h4>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-4.png" style="zoom:60%;" /></p>
<p>局部失效率与全局失效率：</p>
<ul>
<li><p>局部失效率：</p>
<p>该级Cache的失效次数/到达该级Cache的访问次数</p></li>
<li><p>全局失效率</p>
<p>该级Cache的失效次数/CPU发出的访存的总次数</p>
<p>全局失效率L2＝部分失效率L1×部分失效率L2</p></li>
</ul>
<p>对于第二级Cache，我们有以下结论：</p>
<ul>
<li>在第二级Cache比第一级 Cache大得多的情况下，两级Cache的全局失效率和容量与第二级Cache相同的单级Cache的失效率非常接近。</li>
<li>局部失效率不是衡量第二级Cache的一个好指标，因此，在评价第二级Cache时，应用全局失效率这个指标</li>
</ul>
<p>第二级Cache的参数：</p>
<ul>
<li><p>容量</p>
<p>第二级Cache的容量一般比第一级的大许多</p></li>
<li><p>相联度</p>
<p>第二级Cache可采用较高的相联度或伪相联方法</p></li>
</ul>
<h3 id="减少命中时间">5.5 减少命中时间</h3>
<p>命中时间直接影响到处理器的时钟频率。在当今的许多计算机中，往往是Cache的访问时间限制了处理器的时钟频率</p>
<h4 id="容量小结构简单的cache">1. 容量小、结构简单的Cache</h4>
<p>硬件越简单，速度就越快。应使Cache足够小，以便可以与CPU一起放在同一块芯片上</p>
<p>某些设计采用了一种折中方案：</p>
<p>把Cache的标识放在片内，而把Cache的数据存储器放在片外</p>
<h4 id="虚拟cache">2.虚拟Cache</h4>
<ul>
<li>虚拟Cache：访问Cache的索引以及Cache中的标识都是虚拟地址(一部分)</li>
<li>物理Cache：使用物理地址的传统Cache</li>
</ul>
<p>虚拟索引＋物理标识：</p>
<ul>
<li>优点：兼得虚拟Cache和物理Cache的好处</li>
<li>局限性：Cache容量受到限制（Cache容量≤页大小×相联度）</li>
</ul>
<h4 id="cache访问流水化">3. Cache访问流水化</h4>
<ul>
<li>对第一级Cache的访问按流水方式组织</li>
<li>访问Cache需要多个时钟周期才可以完成</li>
</ul>
<h4 id="trace-cache">4. Trace Cache</h4>
<ul>
<li>开发指令级并行性所遇到的一个挑战是： 当要每个时钟周期流出超过4条指令时，要提供足够多条彼此互不相关的指令是很困难的</li>
<li>一个解决方法：采用Trace Cache 存放CPU所执行的动态指令序列包含了由分支预测展开的指令，该分支预测是否正确需要在取到该指令时进行确认</li>
</ul>
<p>优缺点：</p>
<ul>
<li>地址映象机制复杂。</li>
<li>相同的指令序列有可能被当作条件分支的不同选择而重复存放。</li>
<li>能够提高指令Cache的空间利用率</li>
</ul>
<h4 id="cache优化技术总结">5. Cache优化技术总结</h4>
<p>“＋”号：表示改进了相应指标 “－”号：表示它使该指标变差 空格栏：表示它对该指标无影响 复杂性：0表示最容易，3表示最复杂</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-5.png" style="zoom:60%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-6.png" style="zoom:60%;" /></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统精髓与设计原理 第8版 阅读笔记</title>
    <url>/2020/02/28/2020-02-28-Operating-System-Internals-and-Design-Principles-8th-Note/</url>
    <content><![CDATA[<blockquote>
<p>Github地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dlaWp1bi1MaW4vTm90ZXMvYmxvYi9tYXN0ZXIvT3BlcmF0aW5nLVN5c3RlbS1JbnRlcm5hbHMtYW5kLURlc2lnbi1QcmluY2lwbGVzLTh0aC9ub3RlLm1k">笔记-操作系统精髓与设计原理第8版<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>操作系统是管理计算机硬件与软件资源的系统软件，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。—— 维基百科</p>
<blockquote>
<p>前几章为引言部分 略</p>
</blockquote>
<h2 id="第二部分-进程">第二部分 进程</h2>
<hr />
<h3 id="第三章-进程描述和控制">第三章 进程描述和控制</h3>
<hr />
<h4 id="进程的几个定义">1. 进程的几个定义</h4>
<ul>
<li>一个正在执行的<strong>程序</strong></li>
<li>一个正在<strong>计算机</strong>上执行的程序实例</li>
<li>能分配给<strong>处理器</strong>并由处理器执行的实体</li>
<li>由一组执行的<strong>指令</strong>，一个<strong>当前状态</strong>和一组相关的<strong>系统资源</strong>表征的活动单元</li>
</ul>
<h4 id="基本元素">2. 基本元素</h4>
<p>程序代码 + 数据集</p>
<h4 id="进程控制块-pcb">3. 进程控制块 （PCB）</h4>
<ul>
<li>标识符</li>
<li>状态：新建，运行，就绪，挂起，阻塞，退出</li>
<li>优先级</li>
<li>程序计数器： 保存下一条指令的地址</li>
<li>内存指针：代码 / 数据 / 其它进程的指针</li>
<li>上下文数据：处理器执行时寄存器里的值</li>
<li>I/O 状态信息：I/O 请求； I/O 设备； 文件列表</li>
<li>记账信息：处理器时间，记账号</li>
</ul>
<h4 id="进程状态">4. 进程状态</h4>
<p><strong>轨迹</strong>：进程执行的指令序列</p>
<h5 id="两状态模型">两状态模型</h5>
<p>非运行态 <span class="math inline">\(\Leftrightarrow\)</span> 运行态</p>
<h5 id="五状态模型">五状态模型</h5>
<ul>
<li>运行态：进程正在执行，假设为一个计算机，那么一次最多只有一个进程处于此状态</li>
<li>就绪态：进程做好了准备，随时可以处于运行态</li>
<li>阻塞态：在发生某些事件前不能执行，如 I/O</li>
<li>新建态：已创建 PCB 但还未加载到内存中的进程</li>
<li>退出态：操作系统从可执行进程组释放出的进程</li>
</ul>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/5_states_module.jpg" /></p>
<h4 id="进程的挂起">5. 进程的挂起</h4>
<p><strong>原因</strong>：当所有进程都处于阻塞态时，处理器处于休闲状态。此时将某个进程的一部分或者全部移入磁盘，然后从挂起队列加载一个新进程，放入内存中运行</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/suspended_state.jpg" /></p>
<h5 id="进程挂起的原因">进程挂起的原因</h5>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/suspended_reason.jpg" /></p>
<h4 id="进程创建和终止">6. 进程创建和终止</h4>
<ul>
<li><p>进程创建的原因：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/creat_process_reason.jpg" /></p></li>
<li><p>进程终止的原因：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/end_process_reason.jpg" /></p></li>
</ul>
<h4 id="操作系统控制结构">7. 操作系统控制结构</h4>
<ul>
<li>内存表：跟踪内存和外（虚）存（交换机制）
<ul>
<li>分配给进程的内存</li>
<li>分配给进程的外存</li>
<li>内存块或虚存块的任何保护属性</li>
<li>管理虚存所需要的任何信息</li>
</ul></li>
<li>I/O 表：管理 I/O 设备和通道</li>
<li>文件表：文件管理：是否存在，位置等信息</li>
<li>进程表：内存，I/O， 文件是代表进程而被管理的</li>
</ul>
<h4 id="进程控制结构">8. 进程控制结构</h4>
<p>进程映像：程序 + 数据 + 栈 + 属性</p>
<h5 id="pcb-进程控制块">PCB 进程控制块</h5>
<ul>
<li><p>进程标识信息：存储在PCB中的数字标识符,包括: 进程 ID，父进程 ID，用户 ID</p></li>
<li>进程状态信息（处理器状态信息）：存储所有的程序状态字（PSW）</li>
<li><p>进程控制信息：操作系统协调各种活动进程的额外信息</p></li>
</ul>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/PCB.jpg" /></p>
<h5 id="pcb-的作用">PCB 的作用</h5>
<blockquote>
<p>PCB 是操作系统中最重要的数据结构，包含操作系统所需进程的全部信息</p>
<p>PCB 集合定义了 OS 的状态</p>
</blockquote>
<p>如何在发生错误和变化时，保护 PCB，具体表现为两个问题：</p>
<ul>
<li>一个例程（如中断处理程序）中的错误可能会破坏进程控制块，进而破坏系统对受影响进程的管理能力</li>
<li>进程控制块结构或语义中的设计变化可能会影响到操作系统中的许多模块</li>
</ul>
<h4 id="进程控制">9. 进程控制</h4>
<h5 id="执行模式">执行模式</h5>
<p>特权模式称为系统模式，控制模式或者<strong>内核模式</strong>，非特权模式又称为用户模式</p>
<p><strong>原因</strong>：保护操作系统和重要的操作系统表 不受用户程序的干扰</p>
<p><strong>ELSE</strong>：PCB 中有指示执行模式的位，因事件变化而变化，当用户调用OS服务或中断触发系统例程时，执行模式变为内核模式，返回到用户进程时变为用户模式</p>
<h5 id="内核的典型功能">内核的典型功能</h5>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/OS_kernel_function.jpg" /></p>
<h4 id="进程创建-具体过程">10. 进程创建 具体过程</h4>
<ol type="1">
<li>为新进程分配一个唯一的进程标识符</li>
<li>为进程分配空间</li>
<li>初始化 PCB</li>
<li>设置正确的链接：放入新建/就绪挂起 链表中</li>
<li>创建或扩充其它数据结构：记账文件</li>
</ol>
<h4 id="进程切换">11. 进程切换</h4>
<p>#####　何时切换进程</p>
<blockquote>
<p>可在OS从当前正在运行的进程获得控制器的任何时刻发生</p>
</blockquote>
<ul>
<li>系统中断： 时钟中断（超过运行时间片）；I/O 中断；内存失效</li>
<li>陷阱：处理一个错误和一个异常条件</li>
<li>系统调用：显示请求，调用操作系统函数</li>
</ul>
<h5 id="模式切换">模式切换</h5>
<p>出现中断时，处理器将：</p>
<ul>
<li>将从程序计数器置为中断处理程序的开始地址</li>
<li>从用户模式切换到内核模式，以便中断处理代码包含特权指令</li>
<li>保存已中断例程的上下文</li>
</ul>
<h5 id="进程切换-1">进程切换</h5>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/process_change.jpg" /></p>
<h4 id="操作系统的执行">12. 操作系统的执行</h4>
<blockquote>
<p>第二章指出操作系统的两个特殊事实：</p>
<ul>
<li>OS 和普通软件以相同的方式运行，也是一个程序</li>
<li>OS 会频繁的释放控制权，并依赖于处理器来恢复控制权</li>
</ul>
</blockquote>
<h5 id="无进程内核">无进程内核</h5>
<p>在所有进程外部执行操作系统内核，进程概念只适用于用户程序，操作系统则是则是在特权模式下单独运行的实体</p>
<h5 id="在用户进程内运行">在用户进程内运行</h5>
<p>操作系统是用户调用的一组例程，在用户进程的环境中执行并实现各种功能。进程映像不仅包括自己的程序，数据，栈还包括<strong>内核程序</strong>的程序，数据，和栈区域。操作系统代码和数据位于共享地址空间中，并被所有用户进程所共享。只需要在同一进程中切换模式，而不需要切换进程</p>
<h5 id="基于进程的操作系统">基于进程的操作系统</h5>
<p>把操作系统作为一组系统进程来实现</p>
<p>优点：</p>
<ol type="1">
<li>鼓励模块化操作系统设计原理，使模块间接口最小且最简单</li>
<li>有些非关键系统功能可简单的用独立的进程来实现（例如监视各种资源和状态的程序）</li>
<li>在多处理器和多机环境中很有用</li>
</ol>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/OS_and_userprocess.jpg" /></p>
<h3 id="第四章-线程">第四章 线程</h3>
<hr />
<h4 id="进程和线程">1. 进程和线程</h4>
<h5 id="进程特点">进程特点</h5>
<ul>
<li>资源所有权：进程包括存放进程映像的虚拟地址空间</li>
<li>调度/执行：进程具有执行态和优先级，是可被 OS 调度和执行的实体</li>
</ul>
<blockquote>
<p>这两个特点是独立的，为了区分这两个特点，通常将分派的单位称为线程（轻量级进程 LWP ）</p>
<p>而将资源所有权的单位称为进程（任务）</p>
</blockquote>
<h5 id="多线程">多线程</h5>
<blockquote>
<p>指OS在单个进程内支持多个并发执行路径的能力</p>
</blockquote>
<p>在多线程环境中，进程定义为资源分配单元和一个保护单元，与进程相关联的有：</p>
<ul>
<li>容纳进程映像的虚拟地址空间</li>
<li>对处理器，其它进程，文件，I/O 的受保护访问</li>
</ul>
<p>每个线程都有：</p>
<ul>
<li>一个线程的执行状态</li>
<li>线程上下文，线程可视为进程内运行的一个独立程序计数器</li>
<li>一个执行栈</li>
<li>局部变量的静态存储空间</li>
<li>与其它线程共享的内存和资源的访问</li>
</ul>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_4/thread_module.jpg" /></p>
<p>使用线程的几个例子：</p>
<ul>
<li>前台和后台工作</li>
<li>异步处理</li>
<li>执行速度</li>
<li>模块化程序结构</li>
</ul>
<p><strong>线程的优点</strong></p>
<blockquote>
<p><strong>Why</strong> : 因为线程共享一个地址，内存，文件空间，ULT中不用切换到内核，进程切换需要内核</p>
</blockquote>
<ul>
<li>创建线程的时间少于创建进程的时间</li>
<li>终止线程的时间少于终止进程的时间</li>
<li>同一个内线程切换时间少于进程间切换的时间</li>
<li>线程提高了不同执行程序间通信的效率</li>
</ul>
<h5 id="线程的功能">线程的功能</h5>
<p>线程状态：就绪态，运行态，阻塞态</p>
<p>基本操作：派生，阻塞，解除阻塞，结束</p>
<p>线程同步：同步线程的活动是它们互不干扰且不破坏数据结构，如两个线程向一个链表加入元素，则可能会丢失</p>
<h4 id="线程分类">2. 线程分类</h4>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_4/thread_type.jpg" /></p>
<h5 id="用户级ult">用户级（ULT）</h5>
<p>管理线程的所有工作都由应用程序完成，==内核意识不到线程的存在==（线程在内核看来和进程是一致的）。任何应用程序都可以设计成多线程程序。线程库提供了所有关于线程的操作</p>
<p><strong>ULT相较于KLT的优点</strong>：</p>
<ul>
<li>所有线程都在一个进程的用户地址空间中，线程切换不需要内核模式特权，因此不需要切换到内核状态，节省了两次状态转换，用户到内核和内核到用户</li>
<li>调度因程序的不同而不同</li>
<li>ULT 可以在任何操作系统中运行</li>
</ul>
<p><strong>ULT 相较于 KLT 的缺点</strong>：</p>
<ul>
<li>ULT 执行一个系统调用的话，不仅阻塞当前线程，也会阻塞进程内的所有线程</li>
<li>==多线程应用程序不能利用多处理技术==，这里线程对操作系统是不可见的，内核一次把一个进程分配给处理器，这样一个进程内只能运行一次一个线程，相当于在一个进程内实现了多道程序设计</li>
</ul>
<h5 id="内核级线程klt">内核级线程（KLT）</h5>
<p>管理线程的所有操作由内核完成，应用级只有一个到内核线程实施的应用编程接口（API）</p>
<p><strong>KLT 的优点：</strong></p>
<ul>
<li>内核可以把进程中的多个线程调度到多个处理器中</li>
<li>进程的一个线程阻塞时，不影响其它线程的调度</li>
<li>内核例程也可以是多线程的</li>
</ul>
<p><strong>KLT 的缺点：</strong></p>
<ul>
<li>线程转换时 需要切换到内核状态</li>
</ul>
<h5 id="混合">混合</h5>
<blockquote>
<p>结合两者优点</p>
</blockquote>
<h4 id="多核和多线程">3、多核和多线程</h4>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_4/Amdahl.jpg" /></p>
<blockquote>
<p>并不是核越多越好，管理起来越麻烦，会有更多多余的开销</p>
</blockquote>
<p><strong>影响多核系统上软件性能的因素</strong></p>
<ul>
<li>核的数量</li>
<li>串行代码比例</li>
<li>多处理器任务调度和通信以及高速缓存一致性带来的额外开销</li>
</ul>
<h3 id="第五章-并发性互斥和同步">第五章 并发性：互斥和同步</h3>
<hr />
<p>操作系统的核心问题是进程和线程的管理：</p>
<ul>
<li>多道程序设计技术：管理单处理器中的多个进程</li>
<li>多处理器技术：管理多处理器中的多个进程</li>
<li>分布式处理器技术：管理多台分布式计算机中多个进程的执行（集群）</li>
</ul>
<p><strong><em>并发是所有问题的基础，也是操作系统设计的基础（设计问题：进程通信，资源共享和竞争）</em></strong></p>
<p>出现的环境：</p>
<ul>
<li>多应用程序：程序间动态共享处理器时间</li>
<li>结构化应用程序：。。。</li>
<li>操作系统结构：。。。</li>
</ul>
<h4 id="并发的原理">1、并发的原理</h4>
<h5 id="并发处理的问题难点">并发处理的问题（难点)</h5>
<ul>
<li>全局资源的共享充满了危险</li>
<li>OS很难对资源进行最优化分配</li>
<li>定位程序设计错误非常困难</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">zvoid <span class="title">echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    chin = getchar();</span><br><span class="line">    chout = chin;</span><br><span class="line">    <span class="built_in">putchar</span>(chout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个打印字符的程序很容易发生数据的丢失，出现这种问题的原因是中断可能在进程的任何地方发生，解决方案是控制对共享资源的访问</p>
<h5 id="竞争条件">竞争条件</h5>
<p>竞争条件发生在多个进程或线程读写数据时，其最终结果取决于进程的指令执行顺序</p>
<h5 id="进程的交互">进程的交互</h5>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/interfaceOfProcess.jpg" /></p>
<p>有几个基本概念：</p>
<p><strong><em>临界资源</em></strong> ：就是上面谈到的一个不可分享的资源</p>
<p><strong><em>临界区</em></strong>：使用这一部分资源的程序称为程序的临界区</p>
<p><strong><em>死锁</em></strong>：两个进程互相控制两个资源，但又还需要对方持有的资源才可以继续工作，这样就产生了死锁（两个进程都不能继续工作）</p>
<p><strong><em>饥饿</em></strong>：有三个进程 ABC ，每个进程都需要访问资源 R，资源被 AC 交替访问，却始终没有分配给 B 这样 B 就处于饥饿状态</p>
<h5 id="互斥的要求">互斥的要求</h5>
<blockquote>
<p>互斥：简单来说，就是两个或多个进程需要访问一个不可分享的资源的保护机制</p>
</blockquote>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/demandOfMutex.jpg" /></p>
<h4 id="互斥硬件的支持">2、互斥：硬件的支持</h4>
<h5 id="中断禁用">中断禁用</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">/* 禁用中断 */</span></span><br><span class="line">    <span class="comment">/* 临界区 */</span></span><br><span class="line">    <span class="comment">/* 启用中断 */</span></span><br><span class="line">    <span class="comment">/* 其余部分 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>临界区不能被中断，所以可以保证互斥，为了保证互斥只需要保证一个进程在访问资源的时候不被中断。</p>
<p>但是，这种方法的代价非常高。由于处理器被限制得只能交替执行程序，因此执行的效率会明显降低。而且它不能用于多处理器体系结构。当一个计算机系统含有多个处理器时，通常可能有多个进程同时执行。这种情况下，中断不能保证互斥。因为在多处理器配置中，<strong><em>几个处理器对内存的访问不存在主从关系，处理器之间的行为是无关的，表现出一种对等的关系，处理器之间没有支持互斥的中断机制。</em></strong></p>
<h5 id="专用机器指令">专用机器指令</h5>
<p>在硬件级别上，对存储单元的访问排斥对相同单元的其它访问，因此处理器的设计人员提出了一些机器指令，用与保证两个动作的原子性（不能被中断的指令），<strong>在这个指令执行的过程中，任何其它指令访问内存都将被总之，而且这些动作在一个指令周期中完成</strong></p>
<ul>
<li><strong>比较和交换指令：</strong></li>
</ul>
<p>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *word, <span class="keyword">int</span> testval, <span class="keyword">int</span> newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldval;</span><br><span class="line">    oldval = *word;</span><br><span class="line">    <span class="keyword">if</span>(oldval == testval) *word = newval;</span><br><span class="line">    <span class="keyword">return</span> oldval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用一个测试值检查一个内存单元，如果内存单元的当前值是 <code>testval</code> ，就使用 <code>newval</code> 取代该值，否则保持不变，并返回旧内存值。因此如果返回值和测试值相同，表示内存单元已经被更新，整个过程按原子操作执行，不接受中断。这个过程的另一个版本为返回 <code>bool</code> 值，判断是否完成交换</p>
<ul>
<li><strong>exchange指令</strong></li>
</ul>
<p>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">register</span>, <span class="keyword">int</span> *memory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *memory;</span><br><span class="line">    *memory = *<span class="keyword">register</span>;</span><br><span class="line">    *<span class="keyword">register</span> = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/mutexInHardware.jpg" /></p>
<p><strong>忙等待（自旋等待）</strong>：进程在得到临界区访问权之前，它只能继续执行测试变量的指令来得到访问权，除此之外不能做任何事情</p>
<p>对于上图 <strong>a</strong> ,唯一可以进入临界区的进程是发现 bolt 为0的那个进程，并把bolt置为1在它访问临界区的时候，此时其它的进程都处于忙等待中，访问结束后继续将 bolt 置为 0，此时下一个可以进入临界区的进程就是在这之后最早执行 <code>compare&amp;swap</code> 指令的进程</p>
<p>对于上图<strong>b</strong> ,工作原理和 <strong>a</strong> 几乎一致。由于变量初始化的方式和交换算法的本质，下面的表达式恒成立：</p>
<p><span class="math display">\[ bolt + \sum_ikey_i = n \]</span></p>
<p>若 <code>bolt = 0</code> ，则没有任何一个进程在它的临界区中，若 <code>bolt = 1</code> ，则只有一个进程在临界区中，且为 <strong><em>key为 0</em></strong> 的那个进程</p>
<h5 id="机器指令方法的特点">机器指令方法的特点</h5>
<p>有如下的优点：</p>
<ul>
<li>适用于单处理器或共享内存的多处理器上的任意数量的进程</li>
<li>简单且易于证明</li>
<li>可以用支持多个临界区，每个临界区可以用它自己的变量定义</li>
</ul>
<p>但也有一些严重的缺点：</p>
<ul>
<li>使用了忙等待：在一个进程在等待进入临界区时，它依然在消耗处理器时间</li>
<li>可能饥饿：选择哪个等待进程时任意的，因此有些进程会被无限拒绝进入</li>
<li>可能死锁：考虑单处理器下的情况：进程P1执行专用指令（上面的两个）并进入临界区，然后P1被中断并交给更高优先级的P2执行，P2由于互斥机制讲被拒绝访问，但是由于P1优先级低，它也永远不会被调度执行</li>
</ul>
<h4 id="信号量">3、信号量</h4>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamhjZWx1ZS9wLzcwODAxNDYuaHRtbA==">https://www.cnblogs.com/jhcelue/p/7080146.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>讨论的是提供并发性的操作系统和设计语言的机制</p>
<p>常用的并发机制：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/concurrencyWays.jpg" /></p>
<p>基本原理如下：</p>
<p>两个或多个进程可以通过简单的信号进行合作。强迫一个进程在某个位置停止，直到它接受到一个特定的信号，其中使用了一个称为<strong>信号量</strong>的特殊变量。通过信号量 s 传送信号，进程须执行原语 <code>semSignal(s)</code> 要通过信号量 s 接受信号需要执行原语 <code>semWait(s)</code> 若相应信号未发送则阻塞进程，知道发送完为止</p>
<p>为达到预期效果，可把信号量视为一个值为整数的变量，定义了三个操作：</p>
<ul>
<li>一个信号量可以初始化为非负数</li>
<li><code>semWait</code> 使信号量减 1，若值变成负数，则阻塞执行 <code>semWait</code> 的进程，否则继续执行</li>
<li><code>semSignal</code> 操作使信号量加 1 ，若值小于等于 0 ，则被 <code>semWait</code> 操作阻塞的进程解除阻塞</li>
</ul>
<p>信号量为正数时，代表发出 <code>semWait</code> 后可以继续执行的进程数量，信号量为负数时，每个 <code>semSignal</code> 操作都会将等待进程中的一个进程解除阻塞</p>
<p>对于信号量有三个重要结论：</p>
<ul>
<li>通常，在进程对信号量-1之前，无法提前知道该信号量是否会被阻塞</li>
<li>当进程对信号量+1后，会唤醒另一个进程，两个进程继续并发运行。而在一个单处理器系统中，无法知道哪一个进程会继续运行</li>
<li>向信号量发出信号后，不需要知道是否有另外一个进程在等待，被解除阻塞的进程数要么没有，要么为1</li>
</ul>
<p>信号量原语的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWait</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="comment">// --之后小于0 说明原来 count &lt;= 0</span></span><br><span class="line">    <span class="keyword">if</span> (s.count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 把当前进程插入队列</span></span><br><span class="line">        <span class="comment">// 阻塞当前进程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignal</span><span class="params">(semaphore s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="comment">// ++之后小于等于0 说明原来 count &lt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (s.count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 把进程P从队列移除</span></span><br><span class="line">        <span class="comment">// 把进程P插入就绪队列</span></span><br><span class="line">        <span class="comment">// 这个进程P是未知的</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二元信号量的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_semaphore</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>zero, one&#125; value;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWaitB</span><span class="params">(binary_semaphore)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.value == one) s.value = zero;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 插入阻塞队列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> semSignalB(semaphore s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">queue</span> is empty()) s.value = one;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将进程P解除阻塞</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>理论上二元信号量更易于实现，且可以证明==与普通信号具有同样的表达能力==，非二元信号量也称作<strong>计数信号量</strong>或<strong>一般信号量</strong></p>
</blockquote>
<p>与二元信号量有关的还有<strong><em>互斥锁（Mutex）</em></strong>。互斥是一个编程标志位，用来获取和释放一个对象。可以对一个资源进行<strong>加锁</strong>和<strong>解锁</strong>操作，即为置0和置1，可以由互斥量和二元信号量实现，二者区别在于，<strong>互斥量解锁和加锁的进程必须是同一个进程，二元信号量进行加锁操作，而由另一个进程解锁</strong></p>
<ul>
<li>强信号量：进程按照FIFO策略将进程从队列溢移除的信号量</li>
<li>弱信号量：没有规定队列移除顺序的信号量</li>
</ul>
<p>可以理解==强信号量不会导致饥饿，而弱信号量可能导致饥饿==</p>
<p><strong>信号量机制示例</strong></p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/semaphoreExample.jpg" /></p>
<h5 id="互斥">互斥</h5>
<p>使用信号量的互斥：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/*进程数*/</span>;</span><br><span class="line">semaphore s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWait(s);</span><br><span class="line">        <span class="comment">//临界区</span></span><br><span class="line">        semSignal(s);</span><br><span class="line">        <span class="comment">//Else</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    parbegin(P(<span class="number">1</span>), P(<span class="number">2</span>), ..., P(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/explainAboutMutexInSemaphore.jpg" /></p>
<h5 id="生产者消费者问题">生产者消费者问题</h5>
<p><strong><em>问题描述</em></strong>：有一个或多个生产者生产某种类型的数据，并放置在缓冲区中；有一个消费者从缓冲区中取数据，每次取一项，任何时候只有一个主体访问缓冲区。问题是要确保：当缓冲区已满时，生产者不会继续向其中添加数据，当缓冲区为空时，消费者不会从中移走数据</p>
<p>首先假设缓冲区是无限的，且是一个线性数组，可以使用二元信号量和计数信号量实现</p>
<p><strong>二元信号量错误的方法</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;	<span class="comment">// 缓冲区剩余生产量</span></span><br><span class="line"><span class="comment">// delay：用于解决空的时候消费者不移走数据</span></span><br><span class="line"><span class="comment">// s：用于互斥,控制资源访问</span></span><br><span class="line">binary_semaphore s = <span class="number">1</span>, delay = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(s);</span><br><span class="line">        append(); <span class="comment">// 正式将数据加入缓冲区</span></span><br><span class="line">        n++;</span><br><span class="line">        <span class="comment">// 告诉消费者缓冲区已经有数据了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) semSignal(delay);</span><br><span class="line">        semSignal(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    semWait(delay);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWiat(s);</span><br><span class="line">        take();</span><br><span class="line">        n--;</span><br><span class="line">        semSignal(s);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="comment">// 消费完之后阻塞当前进程 因为在此循环中delay不会为1</span></span><br><span class="line">        <span class="comment">// 如果此处发生中断n的值会被篡改 这个判断也就没有什么意义了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) semWait(delay);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    parbegin(producer,consumer);	<span class="comment">//创建线程/进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么是错误的，可能造成消费完之后继续取</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/wrongInProducer_Consumer.jpg" /></p>
<p>也就是==在消费者消费之后已经不属于互斥资源保护区，发生中断之后不能保护原有变量的值==，正如上图第10行，本来应该阻塞消费者进程，但是由于中断使 n++，并且有重新将 delay 置1，而后恢复消费者进程消费完缓冲区之后 delay 信号仍然为1所以，此时缓冲区为空但是并不会阻塞进程，所以还会继续从已经为空的缓冲区拿东西（也就是 delay 信号并不能匹配了）</p>
<p><strong>二元信号量正确的方法</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;	<span class="comment">// 缓冲区剩余生产量</span></span><br><span class="line"><span class="comment">// delay：用于解决空的时候消费者不移走数据</span></span><br><span class="line"><span class="comment">// s：用于互斥,控制资源访问</span></span><br><span class="line">binary_semaphore s = <span class="number">1</span>, delay = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(S);</span><br><span class="line">        append(); <span class="comment">// 正式将数据加入缓冲区</span></span><br><span class="line">        n++;</span><br><span class="line">        <span class="comment">// 告诉消费者缓冲区已经有数据了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) semSignal(delay);</span><br><span class="line">        semSignal(S);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    semWait(delay);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWiat(s);</span><br><span class="line">        take();</span><br><span class="line">        n--;</span><br><span class="line">        <span class="comment">// 保护变量m这样就不怕之前的n被修改，m属于此进程的不会被篡改</span></span><br><span class="line">        m = n;</span><br><span class="line">        semSignal(s);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="comment">// 消费完之后阻塞当前进程 因为在此循环中delay不会为1</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) semWait(delay);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    parbegin(producer,consumer);	<span class="comment">//创建线程/进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用一般信号量（计数信号量），可得到一种更好的解决方法，如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接把n和信号量联系起来</span></span><br><span class="line">semephore n = <span class="number">0</span>, s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWiat(s);</span><br><span class="line">        append();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWiat(n);</span><br><span class="line">        semWait(s);</span><br><span class="line">        take();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        consume();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()....</span><br></pre></td></tr></table></figure>
<p>如果是有限缓冲区的话，只需要对缓冲区大小也设置信号量保护即可</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sizeofBuffer = <span class="comment">//缓冲区大小</span></span><br><span class="line">semephore n = <span class="number">0</span>, s = <span class="number">1</span>, e = sizeofBuffer;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semwait(e);	<span class="comment">// e表示缓冲区中空的个数</span></span><br><span class="line">        semWiat(s);</span><br><span class="line">        append();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWiat(n);</span><br><span class="line">        semWait(s);</span><br><span class="line">        take();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(e);	<span class="comment">// 已经消耗一个 有空位了</span></span><br><span class="line">        consume();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()....</span><br></pre></td></tr></table></figure>
<h5 id="信号量的实现">信号量的实现</h5>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/implementOfSemaphore.jpg" /></p>
<p>即使用 <code>s.flag</code> 的互斥原语实现了信号量操作的原子性</p>
<h4 id="管程">4、管程</h4>
<blockquote>
<p>管程是一种程序设计语言结构（ C/C++ 语言没有 JAVA 支持）</p>
<p>它提供的功能与信号量相同但是更易于控制</p>
</blockquote>
<h5 id="管程的特点">管程的特点</h5>
<blockquote>
<p>感觉就是把信号量的一些操作给封装了</p>
</blockquote>
<ol type="1">
<li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问</li>
<li>一个进程通过调用管程的一个过程进入管程</li>
<li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其它进程都被阻塞以等待管程可用</li>
</ol>
<h5 id="函数">函数</h5>
<p>管程通过使用<strong>条件变量</strong>来支持同步，这些条件变量包含在管程中，并且只有在管程中才能被访问</p>
<p>有两个函数可以操作条件变量：</p>
<ul>
<li>cwait(c): 使当前进程阻塞在条件c上</li>
<li>csignal(c): 使阻塞在c条件上的一个进程就绪</li>
</ul>
<h5 id="管程的结构">管程的结构</h5>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/tubePassStruct.jpg" /></p>
<h5 id="例子重写消费者生产者问题">例子：重写消费者生产者问题</h5>
<blockquote>
<p>暂略</p>
</blockquote>
<p>这个例子表明，与信号量相比，管程担负的责任不同。对于管程，它有自己的互斥机制：两个进程不能同时访问缓冲区，但是 <strong><em>cwait csignal</em></strong> 原语的位置需要注意。管程优于信号量之处在于，所有的同步机制都被限制在管程内部，因此不但易于验证同步的正确性，而且易于检测出错误。此外若一个管程被正确的编写，则所有进程对受保护资源的访问都是正确的，而对于信号量，只有当所有资源的进程都被正确编写时，资源访问才是正确的。</p>
<h5 id="管程的通知和广播">管程的通知和广播</h5>
<p>上述方法有两个缺陷</p>
<ul>
<li>产生 <code>csignal</code> 的进程在管程内还未结束，则需要两次额外的进程切换：阻塞进程需要一次切换，管程可用时又需要一次切换</li>
<li>与信号有关的进程调度必须非常可靠</li>
</ul>
<p>在新的管程规则（Mesa）中，<code>csignal</code> 原语被 <code>cnotify</code> 代替，</p>
<p><code>cnotify</code> 可以解释如下：当一个正在管程中的进程执行 <code>cnotify(x)</code> 中，会使得x 条件队列得到通知，但发信号的进程还在继续执行。但是由于不能保证在它之前没有其它进程进入管程，因而这个等待进程必须重新检查条件。</p>
<p><code>cbroadcast</code> 原语：广播可以使所有在该条件上等待的进程置于就绪态，当一个进程不知道有多少进程被激活时，这种方法非常方便</p>
<h4 id="消息传递">5、消息传递</h4>
<blockquote>
<p>进程交互式必须满足两个基本要求：<strong>同步和通信</strong>，为实施互斥，进程间需要同步；为实现合作，进程需要交换信息，提供这一方法之一就是消息传递</p>
</blockquote>
<p><strong><em>注</em></strong>：互斥和同步的联系：——摘自<span class="exturl" data-url="aHR0cHM6Ly96aGlkYW8uYmFpZHUuY29tL3F1ZXN0aW9uLzQxNDU5MzU2MC5odG1s">百度知道<i class="fa fa-external-link-alt"></i></span>：</p>
<p>​ 相交进程之间的关系主要有两种，同步与互斥。所谓互斥，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它 们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。所谓同步，是指散布在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。 　　显然，==同步是一种更为复杂的互斥，而互斥是一种特殊的同步==。 　　也就是说互斥是两个线程之间不可以同时运行，它们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但它是必须要安照某种次序来运行相应的线程（也是一种互斥）！ 　　<strong>总结</strong>：互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 　　<strong>同步</strong>：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p>
<p><strong>特点（优点）</strong>：可以在分布式系统、共享内存的多处理器系统和单处理器系统中实现</p>
<p><strong><em>消息传递原语</em></strong>：</p>
<ul>
<li><code>send(destination, message)</code></li>
<li><code>receive(source, message)</code></li>
</ul>
<h5 id="同步">同步</h5>
<blockquote>
<p>两个进程之间的消息通信隐含着某种同步的信息：只有当一个进程发送消息后，接受者才能接受消息</p>
</blockquote>
<p>一个进程发出<code>send</code>或者<code>receive原语</code>后，我们需要确定会发生什么：有三种组合：</p>
<ul>
<li><p>阻塞<code>send</code>，阻塞<code>receive</code>：</p>
<p>发送者和接收者都被阻塞，直到完成信息的投递，也叫做会合，考虑进程间的紧密同步</p></li>
<li><p>无阻塞<code>send</code>，阻塞<code>receive：</code></p>
<p>发送者可以继续，但接收者会被阻塞直到请求的消息到达，适用于服务器给其它的进程提供服务和资源</p></li>
<li><p>无阻塞<code>send</code>，无阻塞<code>receive：</code></p>
<p>不要求任何一方等待</p></li>
</ul>
<h5 id="寻址">寻址</h5>
<blockquote>
<p>两个原语的中确定源进程或目标的方案有两类：<strong>直接和间接寻址</strong></p>
</blockquote>
<p><strong>直接寻址：</strong></p>
<p><code>send</code> 原语包含目标进程的标识号，而 <code>receive</code> 有两种处理方式，一种是显示的指定源进程，该进程需要事先直到希望接受来自哪一个进程的消息。另一种是不指定所期望的源进程，例如打印机接受其它进程的打印请求。</p>
<p><strong>间接寻址：</strong></p>
<p>消息不直接从发送者发送到接收者，而是发送到一个共享数据结构，由临时保存消息的队列组成，称为<strong>信箱</strong>，具有一对一，多对一，一对多，多对多三种形式。其中<strong>多对一</strong>的信箱又叫做<strong>端口</strong>。</p>
<p>进程和信箱的关联可以是静态的，也可以是动态的。</p>
<p>还有就是所有权问题。对于端口来说，信箱的所有几乎都是接受进程（多对一），由接受进程创建，对于通用信箱，可以视信箱为创建它的进程所有和该进程一起终止，或是为操作系统所有，这时销毁信箱需要一个显示命令</p>
<h5 id="消息格式">消息格式</h5>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/messageForm.jpg" /></p>
<h5 id="排队原则">排队原则</h5>
<p>最简单的排队原则是先进先出，还有优先级原则，以及允许接收者检查消息队列并选择下一次接受哪个消息</p>
<h5 id="互斥-1">互斥</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/* 进程数 */</span></span><br><span class="line"><span class="keyword">void</span> P(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    message msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        receive(box, msg);</span><br><span class="line">        <span class="comment">/* 临界区 */</span></span><br><span class="line">        send(box, msg);</span><br><span class="line">        <span class="comment">/* Else */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">create <span class="title">mailbox</span><span class="params">(box)</span></span>;</span><br><span class="line">    send(box, null)</span><br><span class="line">    parbegin(P(<span class="number">1</span>), P(<span class="number">2</span>)...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用无阻塞 <code>send</code> 和阻塞 <code>receive</code> 实现互斥，如果消息被一个进程收取，则另外一个执行 <code>receive</code> 操作的进程将被阻塞</p>
<p><strong>生产者消费者问题：</strong></p>
<p>利用了消息传递的能力，除了传递信号之外，它还传递数据。它使用了两个信箱。当生产者产生数据后，数据将作为 消息发送到信箱 <code>mayconsume</code> ,只要该信箱中有一条消息，消费者就可开始消费。从此之后 <code>mayconsume</code> 用做缓冲区，缓冲区中的数据被组织成消息队列，缓冲区的大小由全局变量 capacity 确定。信箱 <code>mayproduce</code> 最初填满空消息，空消息的数量等于信箱的容量，每次生产使得 <code>mayproduce</code> 中的消息数减少，每次消费使得 <code>mayproduce</code> 中的消息数增多。</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/pcMessage.jpg" /></p>
<h4 id="读者写者问题">6、<strong>读者写者问题</strong></h4>
<p>暂略</p>
<h3 id="第六章-并发死锁和饥饿">第六章 并发：死锁和饥饿</h3>
<hr />
<h4 id="死锁原理">6.1 死锁原理</h4>
<p>死锁定义为一组相互竞争系统资源或进行通信的进程间的<strong>“永久”</strong>阻塞，所有死锁都涉及两个或者多个进程之间对资源需求的冲突。</p>
<p>简单来说两个进程都希望获得已经掌握的资源才能继续执行，就产生了死锁。</p>
<h5 id="资源的分类">资源的分类：</h5>
<ul>
<li>可重用资源：一次仅供一个进程安全使用且不因使用而耗尽的资源。包括处理器、I/O 通道，内存和外存等</li>
<li>可消耗资源：可被创建和销毁的资源。包括中断、信号、消息和 I/O 缓冲取中的消息</li>
</ul>
<p>操作系统中死锁检测、预防和避免方法小结：</p>
<figure>
<img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_6/01.jpg" alt="操作系统中死锁检测、预防和避免方法小结" /><figcaption>操作系统中死锁检测、预防和避免方法小结</figcaption>
</figure>
<h5 id="资源分配图">资源分配图</h5>
<p>表征进程资源分配的有效工具是 Holt 引入的<strong>资源分配图</strong>，如下：</p>
<p>其中方块中原点表示资源的一个实例，边表示请求资源和占有资源</p>
<figure>
<img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_6/02.jpg" alt="操作系统中死锁检测、预防和避免方法小结" /><figcaption>操作系统中死锁检测、预防和避免方法小结</figcaption>
</figure>
<p>如果==资源分配图中出现环，并且环中存在资源实例个数小于环中进程的个数==，则可能导致死锁</p>
<h5 id="死锁的条件">死锁的条件</h5>
<p>死锁有三个必要条件：</p>
<ul>
<li>互斥：一次只有一个进程可以使用资源</li>
<li>占有且等待：当一个进程等待其它进程时，继续占有已分配的资源</li>
<li>不可抢占：不能强行抢占已占有的资源</li>
</ul>
<p><strong>这三个为必要条件并非充分条件</strong>，要产生死锁还需要第四个条件：</p>
<p><strong>循环等待</strong>：存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源</p>
<p>第四个条件是前三个条件的潜在结果，满足前三个条件，然后在特定顺序的进程调度下就有可能产生死锁。</p>
<h4 id="死锁预防">6.2 死锁预防</h4>
<p>死锁预防策略是设计一种系统来排除发生死锁的可能性，死锁预防分为两类</p>
<ul>
<li>间接死锁预防方法，即阻止前面必要条件中的一个即可</li>
<li>直接死锁预防方法：防止循环等待的发生</li>
</ul>
<h5 id="互斥-2">互斥</h5>
<p>此条件不可能禁止，对于多进程的并发执行调度中，互斥是必须满足的条件</p>
<h5 id="占有且等待">占有且等待</h5>
<p>预防此条件，可以==要求进程一次性地请求所有需要的资源，并阻塞这个进程直到所有请求都同时满足==，显然，这个方法是低效的</p>
<ol type="1">
<li>一个进程可能被阻塞很长时间来等待所有的请求被满足，而实际上只要有一部分资源它就可以继续执行</li>
<li>一个进程可能实现并不知道它所需要的所有资源</li>
</ol>
<h5 id="不可抢占">不可抢占</h5>
<ol type="1">
<li>占有某些资源的一个进程进一步申请资源时若被拒绝，则该进程必须释放最初占有的资源，必要时可再次申请这些资源和其它资源</li>
<li>一个进程请求被其它进程占有的资源时，可以抢占另一个进程，要求它释放资源</li>
</ol>
<h5 id="循环等待">循环等待</h5>
<p>循环等待条件可通过定义资源类型的线行顺序来预防，若一个进程分配了R类型的资源，则接下来请求的资源只能是排在R类型之后的资源</p>
<p>类似占有且等待的预防方法，循环等待的预防方法是低效的，会使进程执行速度变慢，且在没必要的情况下拒绝资源访问</p>
<h4 id="死锁避免">6.3 死锁避免</h4>
<p>死锁避免<strong>允许三个必要条件</strong>，但通过特定的选择，确保永远不会到达死锁点，死锁避免可允许更多的并发，<u>死锁避免通过当前的资源分配采取措施，所以需要直到未来进程资源请求的情况</u></p>
<p>书本给出两种死锁避免方法：</p>
<ul>
<li><strong>进程启动拒绝</strong>：若一个进程的请求会导致死锁，则不启动该进程</li>
<li><strong>进程分配拒绝</strong>：若一个进程增加的资源请求会导致死锁，则不允许这一资源分配</li>
</ul>
<h5 id="进程启动拒绝">进程启动拒绝</h5>
<p>考虑 n 个进程和 m 种不同类型资源的系统，有以下定义：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_6/03.jpg" /></p>
<p>从中可以得知：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_6/04.jpg" /></p>
<h5 id="资源分配拒绝">资源分配拒绝</h5>
<p>资源分配拒绝策略，即 <strong>银行家算法</strong>，定义了安全状态和不安全状态，进程请求一组资源时，查看同意此请求之后的状态，若还为安全状态，则分配资源，否则拒绝</p>
<ul>
<li>安全状态：至少有一个资源分配序列不会导致死锁</li>
<li>不安全状态：非安全的一个状态</li>
</ul>
<p>但在此处，不可能真的对所有资源分配序列进行探查，判断是否存在此分配序列，所以通常根据下面的关系式判断是否是安全序列：</p>
<p><span class="math inline">\(C_{ij} - A_{ij} \le V_j , 对所有的j\)</span></p>
<p>一个安全状态的例子：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_6/05.jpg" /></p>
<p><strong>死锁避免的优点</strong>：无须死锁预防的抢占和回滚进程，且与死锁预防相比限制较少</p>
<p><strong>死锁避免的限制</strong>：</p>
<ul>
<li>必须实现声明每个进程请求的最大资源</li>
<li>所讨论的进程必须是无关的，即它们的执行顺序必须没有同步要求的限制</li>
<li>分配的资源数量必须是固定的</li>
<li>在占有资源时，进程不能退出</li>
</ul>
<h4 id="死锁检测">6.4 死锁检测</h4>
<h5 id="死锁检测算法">死锁检测算法</h5>
<p>死锁预防策略非常保守，它们通过限制访问资源和进程上强加约束来解决死锁问题，而 <strong>死锁检测不限制资源访问或约束进程行为，只要有可能就会给进程分配其所需要的资源，操作系统周期性的执行一个算法来检测前面的条件（4）（循环等待条件）</strong></p>
<p>书本中死锁检测的算法，在之前定义的基础上还存在一个请求矩阵 <span class="math inline">\(Q\)</span>，其中 <span class="math inline">\(Q_{ij}\)</span> 表示进程 <span class="math inline">\(i\)</span> 请求资源 <span class="math inline">\(j\)</span> 的数量，此算法主要是一个标记未死锁进程的过程，最初所有进程都是未标记的，然后执行以下步骤：</p>
<ol type="1">
<li>标记 Allocation 矩阵中一行全为零的进程</li>
<li>初始化一个临时向量 W，令 W 等于 Available 向量</li>
<li>查找下标 i，使得对所有的 <span class="math inline">\(1 \le k \le m, Q_{ik} \le W_k\)</span>，若找不到 i，终止</li>
<li>若找到这样的行，标记进程 i，并把 Allocation 矩阵中的相应行加到 W 中，即对所有的 <span class="math inline">\(1\le k \le m, 令 W_k += A_{ik}\)</span>，返回步骤 3</li>
</ol>
<p>简单来说就是查找一个可以在当前可用资源条件下完成的进程，然后释放该进程占用的资源（即此进程可以正常执行，结束后回收资源），然后查找下一个，当不存在此进程的时候，剩余的所有进程都不可能在当前资源条件下执行，所以这些进程是死锁的。</p>
<h5 id="死锁恢复">死锁恢复</h5>
<p>检测到死锁后就需要某种策略来恢复死锁，下面为按复杂度递增的顺序列出可能的方法：</p>
<ol type="1">
<li>取消所有的死锁进程，操作系统最常采用的方法</li>
<li>把每个死锁进程回滚到前面定义的某些检查点，并重新启动</li>
<li>连续取消死锁进程直到不存在死锁，所选取消进程的顺序基于某种最小代价原则，每次取消后重新检测是否存在死锁</li>
<li>连续抢占资源直到不存在死锁，和 3 一样依赖某种最小代价原则，一个资源被抢占的进程必须回滚到获得这个资源之前的某一状态</li>
</ol>
<p>对于（3）（4）可参考以下原则：</p>
<ul>
<li>目前为止小号的处理器时间最小</li>
<li>目前为止产生的输出最少</li>
<li>预计剩下的时间最长</li>
<li>目前位置分配的资源总量最少</li>
<li>优先级最低</li>
</ul>
<h4 id="一种综合的死锁策略">6.5 一种综合的死锁策略</h4>
<p>以上解决死锁的策略都各有优缺点，所以操作系统可以在不同的情况下使用不同的策略</p>
<ul>
<li>把资源分成几组不同的资源类</li>
<li>为预防在资源类之间由于循环等待产生死锁，采用前面的线性排序策略</li>
<li>在一个资源类中，使用该类资源最适合的算法</li>
</ul>
<p>其中资源可分为：</p>
<ul>
<li><strong>可交换空间</strong>：进程交换所用外存中的存储块</li>
<li><strong>进程资源</strong>：可分配的设备、如磁带设备和文件</li>
<li><strong>内存</strong>：可按页或段分配给进程</li>
<li><strong>内部资源</strong>：诸如 I/O 通道</li>
</ul>
<p>在每一类资源中，可采取一下策略确定次序：</p>
<ul>
<li><strong>可交换空间</strong>：要求一次性分配所有请求资源预防死锁</li>
<li><strong>进程资源</strong>：死锁避免通常是有效的，因为进程可以实现声明所需要的资源，采用资源排序的预防策略也是可能的</li>
<li><strong>内存</strong>：对于内存。基于抢占的预防是最适合的策略，当一个进程被抢占后，它被换到外存，释放空间可以解决死锁</li>
<li><strong>内部资源</strong>：可以使用基于资源排序的预防策略</li>
</ul>
<h4 id="哲学家就餐问题">6.6 哲学家就餐问题</h4>
<p>有五位哲学家，它们的就餐在一张圆桌上，圆桌上有5个盘子，盘子之间有一把叉子，每位想吃饭的哲学家就餐时使用盘子两侧的叉子</p>
<p>为避免死锁的风险，可再买5把叉子，另一种方法是只允许四位哲学家同时进入餐厅，由于最多有4位哲学家就座，因而至少有一位哲学家可以拿到两把叉子</p>
<p>两种方案的解决代码如下：（第一种解决方案会导致死锁）</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_6/06.jpg" /></p>
<h2 id="第三部分-内存">第三部分 内存</h2>
<hr />
<h3 id="第七章-内存管理">第七章 内存管理</h3>
<hr />
<p>在单道程序设计系统中（本书主要讨论单道），内存划分为两部分</p>
<ul>
<li>操作系统专用</li>
<li>提供“用户”进程使用</li>
</ul>
<p>简单的内存管理术语：</p>
<ul>
<li>页框：<strong>内存</strong>中固定长度的块</li>
<li>页：<strong>固定长度的数据块</strong>，存储在二级存储中，可以临时复制到内存的页框中</li>
<li>段：<strong>变长数据块</strong>，存储在二级存储中，整个段临时复制到内存中（分段），或将段变为页，然后单独将每页复制到内存中（分段、分页相结合）</li>
</ul>
<h4 id="内存管理的需求">7.1 内存管理的需求</h4>
<h5 id="重定位">重定位</h5>
<p>为了使处理器利用率最大化，程序换出到磁盘后，下次换入到换出之前的内存区域很困难，相反，我们需要把进程重定位到内存的不同区域。这样就会带来寻址的问题。处理器<strong>硬件</strong>和<strong>操作系统软件</strong>必须能以某种方式把程序代码中的内存访问转换为实际的物理内存地址，并反映程序在内存中的当前位置。</p>
<h5 id="保护">保护</h5>
<p>每个进程都应受到保护，以免其它进程有意或无意地干扰。</p>
<p>通常用户进程不能访问操作系统的任何部分，无论是程序还是数据。此外，一个进程中的程序通常不能跳转到另一个进程中的指令，若无特别许可，一个进程的程序不能访问其它进程的数据区。</p>
<p>内存保护需求必须由<strong>处理器（硬件）</strong>而非操作需要（软件）来满足，因为操作系统不能预测程序可能产生的所有内存访问，即使可以预测检查也非常费时。</p>
<h5 id="共享">共享</h5>
<p>任何保护机制都必须具有一定的灵活性，以允许多个进程访问内存的同一部分。内存管理系统在不损害基本保护的前提下，必须允许对内存共享区域进行受控访问。</p>
<h5 id="逻辑组织">逻辑组织</h5>
<p>计算机系统的内存和外存总是被组织成<strong>线性的地址空间</strong>。大多数程序被组织成模块，某些模块是不可修改的，若操作系统和计算机硬件能够有效地处理以某种模块形式组织的用户程序与数据，则会带来许多好处：</p>
<ol type="1">
<li>可以独立地编写和编译模块</li>
<li>通过适度的额外开销，可以为不同的模块提供不同的保护级别</li>
<li>可以引入某种机制，使得模块被多个进程共享</li>
</ol>
<p>最易于满足这些需求的根据是<strong>分段</strong></p>
<h5 id="物理组织">物理组织</h5>
<p>计算机系统分为两级，内存和外存，内存提供快速的访问，成本高，易失性；外存较慢且便宜，非易失性。</p>
<p>在这种两级方案中，系统主要关注的是内存和外存之间信息流的组织，组织这一信息流是由系统负责的，而不能由程序员负责。</p>
<h4 id="内存分区">7.2 内存分区</h4>
<p>内存管理的主要操作是处理器把程序装入内存中执行，内存管理技术由以下几种：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_7/01.jpg" /></p>
<h5 id="固定分区">固定分区</h5>
<p>管理用户内存空间的最简方案就是对它分区，以形成若干边界固定的区域</p>
<p>分区大小：</p>
<ul>
<li>大小相等的分区</li>
<li>大小不等的分区</li>
</ul>
<p><strong>内部碎片</strong>：装入的数据块小于分区大小，因而导致分区内部存在空间浪费，这种现象称为内部碎片</p>
<p><strong>放置算法</strong>：</p>
<p>对于大小相等的分区，只需要把每个进程分配到能够容纳它的最小分区中，每个分区都需要维护一个调度队列，用于保存从这个分区换出的进程</p>
<p>对于大小不等的分区，也可以采取上面这种方式，对于单个分区来说是最优的，可以达到最小的内部碎片，但是从整个系统看不是最佳的，小内存的进程可能被阻塞即使有大的空闲分区，所以一种更可取的方式是为所有的进程只提供一个队列。如果所有都被占据，则必须进行交换，一般优先考虑一些诸如优先级之类的其它因素，或者优先选择换出阻塞的进程而非就绪进程</p>
<p>固定分区方案简单，但存在以下缺点：</p>
<ul>
<li>分区的数量在系统生成阶段已经确定，因而 <strong>限制了系统中活动进程的数量</strong></li>
<li>分区的大小是在系统生成阶段实现设置的，因而 <strong>小作业不能有效地利用分区空间</strong></li>
</ul>
<h5 id="动态分区">动态分区</h5>
<p>对于动态分区，分区长度和数量是可变的，进程装入内存时，系统会给它分配一块与其所需容量完全相等的内存空间，动态分区方法会在内存中形成许多小空洞（外部碎片），内存利用率随之下降</p>
<p>克服外部碎片的一种方法是<strong>压缩</strong>，操作系统不时地移动进程，使得进程占用的空间连续，使得所有空闲空间连成一片。</p>
<p>压缩是一个非常耗时的过程，另外，压缩需要动态重定位的能力，能够把程序从内存的一块区域移动到另一块区域，且不会使程序中的内存访问无效</p>
<p><strong>放置算法</strong>：</p>
<p>可供考虑的放置算法有三种：</p>
<ul>
<li><strong>最佳适配：</strong>选择大小最接近的块，性能较差</li>
<li><strong>首次适配：</strong>从头开始扫描，选择大小足够的第一个可用块，通常是最简单有效的</li>
<li><strong>下次适配：</strong>从上一次放置的位置开始，选择下一个可用块，较首次适配差，常常会在内存的末尾分配空间，导致末尾的 最大空闲存储块很快分裂为小碎片，因此可能会需要更多的压缩</li>
</ul>
<h5 id="伙伴系统">伙伴系统</h5>
<p>伙伴系统中内存块大小为 <span class="math inline">\(2^K\)</span> 个字，<span class="math inline">\(L \le K \le U\)</span>，<span class="math inline">\(2^L\)</span> 表示分配的最小块尺寸，<span class="math inline">\(2^U\)</span> 表示分配的整个内存的大小，伙伴系统简单来说就是，给定大小为 <span class="math inline">\(2^i\)</span> （i为不小于此进程大小的最小整数），然后寻找一个大小为 <span class="math inline">\(2^i\)</span> 的空闲块，每个大小为 <span class="math inline">\(2^i\)</span> 的块都有维护列表，空闲块可以由对半分裂从大小为 <span class="math inline">\(2^{i+1}\)</span> 的列表移出，并在 <span class="math inline">\(2^i\)</span> 列表中产生两个伙伴，当 <span class="math inline">\(2^i\)</span> 列表一对伙伴都未分配时，则合并移入到 <span class="math inline">\(2^{i+1}\)</span> 中，可以由下面算法找到一个 <span class="math inline">\(2^i\)</span> 大小的空闲块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_hole</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == U+<span class="number">1</span>) &lt;failure&gt;;</span><br><span class="line">    <span class="keyword">if</span>(&lt;i_list empty&gt;) &#123;</span><br><span class="line">        get_hole(i+<span class="number">1</span>);</span><br><span class="line">        &lt;split hole into buddies&gt;;</span><br><span class="line">        &lt;put buddies on i_list&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;take first hole on i_list&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_7/02.jpg" /></p>
<p>释放B后的二叉树：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_7/03.jpg" /></p>
<h5 id="重定位-1">重定位</h5>
<p>在内存中放置进程需要的一种技术。进程在重新换入到内存后其地址是不确定的，所以需要<strong>逻辑地址</strong>和<strong>物理地址</strong>的转换</p>
<ul>
<li>逻辑地址：与物理分配地址无关的地址</li>
<li>相对地址：逻辑地址的特例，相对已知点的存储单元</li>
<li>物理地址：在内存中的实际位置</li>
</ul>
<p>重定位的硬件支持如下：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_7/04.jpg" /></p>
<p>基址寄存器为程序在内存中的地址，通过与相对地址相加转换为绝对地址，然后与界限寄存器（即程序的终止位置）比较，如超过界限寄存器则发送错误，产生中断</p>
<h4 id="分页">7.3 分页</h4>
<p>将 <strong>内存和进程都划分为大小固定，相等且比较小的块，在进程中的称为页，在内存中的称为页框</strong>。使用分页技术，每个进程在内存中浪费的空间，仅是进程最后一页一小部分形成的内部碎片，没有外部碎片。</p>
<p>它和固定分区不同的是：<strong>采用分页技术的分区相当小，一个程序可以占据多个分区，并且这些分区<u>不需要是连续的</u></strong>。</p>
<p>实现上述的方法之一是，每个进程维护一个<strong>页表</strong>，<u>页表给出了该进程每页对应页框的位置</u>。在程序中，每个逻辑地址包括一个页号和该页中的偏移量。</p>
<p>为了使分页方案更加方便，<strong>规定页和页框的大小必须是2的幂，以便容易地表示出相对地址</strong>，有以下两个好处：</p>
<ol type="1">
<li>逻辑地址方案对编程者、汇编器和链接是透明的（透明的意思是不可见），程序每个逻辑地址与其相对地址是一致的</li>
<li>用硬件实现允许时动态地址转换比较容易。考虑一个 n+m 位地址，最左边的 n 位是页号，最右边的 m 位是偏移量（偏移量的位数和页的大小存在关系 <span class="math inline">\(2^m = 页大小\)</span>，地址转换经过以下步骤：
<ul>
<li>提取页号，即逻辑地址左侧 n 位</li>
<li>以这个页号为索引，查找进程页表中对应的页框号 k</li>
<li>页框的起始物理地址为 <span class="math inline">\(k\times 2^m\)</span>，被访问字节的物理地址是这个数加上偏移量。可以简单地把偏移量附加到页框号后面来构建物理地址。</li>
</ul></li>
</ol>
<p>简单分页的图形表示如下：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_7/05.jpg" /></p>
<h4 id="分段">7.4 分段</h4>
<p>采用分段技术，可以把程序和与其相关的数据划分到几个段，尽管段的最大长度有限制的，但不要求长度都相等，和分页一样，其逻辑地址由段号和偏移量组成。</p>
<p>同样会产生外部碎片，但是由于块可以设置的很小所以外部碎片也很小，分段也不要求分区是连续的。</p>
<p>分页对程序员是透明的，<strong>分段则是可见的</strong>。为实现模块化设计，程序或数据分段或进一步分段。</p>
<p>采用大小不等的段的另一个结果是，逻辑地址和物理地址不再是简单的对应关系，在简单的分段方案中，每一个进程都有一个<strong>段表</strong>，系统也会维护一个内存中的空闲块列表，<u>段表项必须给出相应段在内存中的起始地址，还必须指明段的长度，以确保不会使用无效地址</u>。</p>
<p>考虑一个 n+m 位的地址，左侧 n 位是段号，右侧 m 位是偏移量，进行地址转换有以下步骤：</p>
<ol type="1">
<li>提取段号，即左侧n位</li>
<li>以这个段号为索引，查找进程段表中该段的起始物理地址</li>
<li>最右侧m位，表示偏移量，若偏移量大于段长度则该地址无效</li>
<li>物理地址为该段起始物理地址与偏移量之和</li>
</ol>
<p>简单分段的图形表示：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_7/06.jpg" /></p>
<p>这里讨论的还是<strong>简单分页和简单分段，进程必须把所有全部加载到内存中</strong>，如果采用了覆盖或者虚存技术，则可以部分加载内存中，这部分在下一章讨论。</p>
<p><a href="https://blog.csdn.net/dongyanxia1000/article/details/51425141"><strong>覆盖：</strong></a>所谓<strong><em>覆盖</em></strong>，就是把一个大的程序划分为<strong>一系列覆盖</strong>，每个覆盖就是一个相对独立的程序单位，<strong>把程序执行时并不要求同时装入内存的覆盖组成一组，称为覆盖段</strong>。<strong><em>一个覆盖段内的覆盖共享同一存储区域</em>，</strong>该区域成为覆盖区，它与覆盖段一一对应。显然，为了使一个覆盖区能为相应覆盖段中的每个覆盖在不同时刻共享，其大小应<strong><em>由覆盖段中的最大覆盖</em></strong>来确定。</p>
<blockquote>
<p>分段的段表给出了基地址和页号本质上是一致的，分页中页号乘以页大小即为基地址所以直接和偏移量拼接即可，段地址长度不一，所以需要给出长度过滤无效地址</p>
</blockquote>
<h3 id="第八章-虚拟内存">第八章 虚拟内存</h3>
<hr />
<p>简单的虚拟内存相关定义：</p>
<ul>
<li><p><strong>虚拟内存</strong>：</p>
<p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。</p></li>
<li><p><strong>虚拟地址</strong>：</p>
<p>在虚拟内存中分配给某一位置的地址，使得该位置可被访问，如同内存</p></li>
<li><p><strong>虚拟地址空间</strong>：分配某进程的虚拟存储</p></li>
<li><p><strong>地址空间</strong>：用户某进程的内存地址范围</p></li>
<li><p><strong>实地址</strong>：内存中存储位置的地址</p></li>
</ul>
<hr />
<h4 id="硬件和控制结构">8.1 硬件和控制结构</h4>
<p>分页和分段存在着这样的特点：</p>
<ul>
<li><strong>进程中所有的内存访问都是逻辑地址。</strong>意味着一个进程可被换入或换出内存（只需要更新页表或段表即可），因此进程可在执行过程中的不同的时刻占据不同区域</li>
<li><strong>一个进程可划分为许多块，执行中不需要连续的位于内存中。</strong>页表和段表的使用保证这一特点</li>
</ul>
<p>这样的特点可以使得一个进程在执行的过程中，<strong>该进程不需要所有页或段都在内存中</strong>，只需要在内存保存下一条指令所在块，以及将访问的数据块即可。（这里的块都代表页或段）</p>
<p>进程执行过程中任何时刻都在内存中的部分称为进程的 <strong>常驻集（resident set）</strong>，只要所有的内存访问都是常驻集中的单元，执行就可以顺利进行，并且处理器可以判断是否如此。当访问一个不再内存中（驻留集）的逻辑地址，会产生一个中断，操作系统会将此进程置于 <strong>阻塞态</strong> ，为此操作系统产生一个 <strong>磁盘I/O读请求</strong>，在执行此 I/O 期间，操作系统可以调度另一个进程运行，在读入内存后（按某种置换策略），产生一个 I/O 中断，操作系统则将原来被阻塞的进程置为 <strong>就绪态</strong>。</p>
<p>内存又称为 <strong>实存储器</strong>，简称实存，但程序员或用户感觉到的是一个更大的内存，且通常分配在磁盘上，称为 <strong>虚拟内存（virtual memory）</strong>，简称虚存。虚存支持更有效的系统并发度，解除用户与内存之间没有必要的紧密联系。</p>
<p>分页和分段的特点：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/01.jpg" /></p>
<h5 id="局部性和虚拟内存">局部性和虚拟内存</h5>
<hr />
<p>虚拟内存的开销收到 <strong>系统抖动（thrashing）</strong>的影响。在虚存的机制下操作系统读取一块到内存，通常要将另一块换出，如果这块正好在将要用到之前换出，操作系统不得不很快的将它收回，会 <strong>导致处理器大部分的时间都用于交换块而非执行指令</strong>。</p>
<p>避免系统抖动的算法都根据最近的历史来猜测将来最可能用到的块。这类推断基于<strong>局部性原理</strong>（一个进程中程序和数据引用的集簇倾向）</p>
<p>局部性原理表明虚存方案是可行的，要使虚存比较实用且有效，需要两方面因素：</p>
<ol type="1">
<li>必须有对分页或分段方案的硬件支持</li>
<li>操作系统必须有管理页或段在内存和辅存之间移动的软件</li>
</ol>
<h5 id="分页-1">分页</h5>
<hr />
<blockquote>
<p>主要有二级页表、倒排页表、转换检测缓冲区等结构</p>
</blockquote>
<p>虚存分页和简单分页一样都有页表，其中 <strong>页表项（Page Table Entry，PTE）</strong> 相比简单分页也多了一些内容，如下：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/02.jpg" /></p>
<p>其中的 <strong>P</strong> 表示它所对应的页当前是否在内存中，如果在内存中，则还包括页框号，另一位是<strong>修改位（M）</strong>表示相应的内容装入内存后是否发生变化，若没有改变则无需重新写入辅存，否则需要用该页更新原来的页。</p>
<p>同简单分页类似，逻辑地址依然由页号和偏移量组成，而物理地址由页框号和偏移量组成，页表的长度基于进程长度的变化而变化，以下给出了一种硬件实现：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/03.jpg" /></p>
<p>上述页表的简单处理在虚存空间大的时候会导致页表项的也十分大，一种解决方案是在虚存中保存页表，这意味着 <strong>页表和其它页一样服从分页管理</strong>，一个进程在运行时，它的页表至少有一部分在内存中，这一部分包括正在运行的页的页表项，有一种 <strong>两级层次页表结构</strong> 来组织大型页表，典型情况如下：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/04.jpg" /></p>
<p>以上是 32 位地址两级方案的例子，假设采用字节级寻址，页尺寸为 <span class="math inline">\(4KB (2^{12})\)</span> ,则 <span class="math inline">\(4GB (2^{32})\)</span> 虚拟地址空间由 <span class="math inline">\(2^{20}\)</span> 页组成，若这些页的每一页都由一个4字节的页表项映射，则可创建由 <span class="math inline">\(2^{20}\)</span> 页表项组成的页表，这时需要 <span class="math inline">\(4MB(2^{22})\)</span> 的内存空间。这个由 <span class="math inline">\(2^{10}\)</span> 页组成的巨大用户页表可以保留在虚存中，并由一个包括 <span class="math inline">\(2^{10}\)</span> 个页表项的根页表映射，根页表占据的内存为 <span class="math inline">\(4KB(2^{12})\)</span>，二级页表的地址转换如下图：（根页表的页表项存4KB页表每一页的基地址）</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/05.jpg" /></p>
<hr />
<p>即使是二级页表，页表大小与虚拟地址空间的大小成正比，可以使用<strong>倒排页表</strong>替代这种结构，==称为“倒排”的原因是，它使用页框号而非虚拟页号来索引页表项，它的大小是固定的==，在虚存空间特别大的时候开销比多级页表少。</p>
<p>在这种方法中，虚拟地址的页号部分使用一个散列函数映射到散列表中。散列表包含指向倒排表的指针，而倒排表中含有页表项，页表项包含以下内容：</p>
<ul>
<li><strong>页号</strong>：虚拟地址的页号部分</li>
<li><strong>进程标识符</strong>：使用该页的进程，页号和标识符确定一个特定进程的一页</li>
<li><strong>控制位</strong>：包含一些标记，如有效，访问，修改和锁定信息</li>
<li><strong>链指针</strong>：以为散列函数可能会将多个值散列到一个区域，所以存在链（下一项的索引值）</li>
</ul>
<p>下图是一个n位页号m位数索引倒排表的页表结构图：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/06.jpg" /></p>
<hr />
<p>每次虚存访问都可能会引起两次物理内存访问：</p>
<ul>
<li>取相应的页表项</li>
<li>取需要的数据</li>
</ul>
<p>因此简单的虚拟内存方案会导致内存访问时间加倍，为克服这个问题，可以采用 <strong>转换检测缓冲区（Translation Lookaside Buffer，TLB）</strong>（一个特殊的高速缓存，包含最近用过的页表项）。给定一个虚拟地址，处理器首先检查TLB，若需要的页表项在其中，则检索页框号形成实地址，若未找到则使用页号检索检查页表。然后查看其”存在位“状态，若不在内存中，则会产生一次内存访问故障，称为<strong>缺页（page fault）</strong>中断，此时由操作系统负责装入所需要的页，并更新页表。基本机理如下：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/07.jpg" /></p>
<p>TLB使用流程如下，图中未显示磁盘I/O过程中可以调度另外进程执行。根据局部性原理大多数虚存访问都位于最近使用过的页中，所以此方案可以提高性能。</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/08.jpg" /></p>
<p>TLB 的实际组织还有许多额外细节，由于 TLB 仅包含整个页表中的部分表项，因此不能简单地把页号编入 TLB 的索引，所以 TLB 的项必须包含页号和完整的页表项（和倒排表一样），这两种技术对应直接映射（索引）和关联映射，如下所示：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/09.jpg" /></p>
<p>虚存机制须与高速缓冲系统（内存高缓）进行交互。首先，内存系统查看 TLB 是否存在匹配的页表项，若不存在则从页表中读取页表项。产生一个 TAG 标记和其余部分组成的实地址后，查看高速缓存中是否存在，若有则返回给 CPU，若没有，则从内存中检索这个字。若被访问的字在磁盘中，则包含该字的页必须装入内存，且所在的块须装入高速缓存，且其页表项必须更新。</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/10.jpg" /></p>
<hr />
<p>页尺寸是一个重要的硬件设计决策，页越小，内部碎片总量越少；另一方面，页越小，每个进程需要的页数量越多，页表也会变得更大。大页表不容易存储(二级页表)会导致产生两次缺页中断（读取页表，读取页），但大页表又利于数据块传送。大体来说，<strong>缺页率</strong>和<strong>页尺寸</strong>和分配的<strong>页框数</strong>有关系。</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/11.jpg" /></p>
<p>页尺寸的设计问题还与物理内存大小和程序大小有关。</p>
<h5 id="分段-1">分段</h5>
<hr />
<p>分段组织与非段式有许多优点：</p>
<ol type="1">
<li>简化了对不断增长的数据结构的处理</li>
<li>允许程序独立地改变或重新编译</li>
<li>有助于进程间的共享</li>
<li>有助于保护</li>
</ol>
<p>类似的虚存分段和简单分段一样也为每个进程维护一个段表，段表项包含存在位和修改位，以及该段的起始地址和长度。分段的地址转换如下图：（这里虚拟地址是段号，图片有误）</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/12.jpg" /></p>
<hr />
<h5 id="段页式">段页式</h5>
<p>分段和分页各有所长，在段页式系统中，用户地址空间被程序员划分为许多段，每段划分为和内存页框大小相同的页。逻辑地址仍然由段号和偏移量组成，段偏移量可视为指定段中的页号和页偏移量。其地址转换如下图：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/13.jpg" /></p>
<h4 id="操作系统软件">8.2 操作系统软件</h4>
<p>操作系统内存管理设计取决于三个基本的选择：</p>
<ul>
<li>是否使用虚存技术</li>
<li>是使用分页还是分段，或同时使用两者</li>
<li>为各种存储管理特征采用的算法</li>
</ul>
<p>前两者取决于所用的硬件平台（当前计算机主流提供了虚存的支持，且纯分段的系统也越来越少，<strong>结合分段分页后操作系统内存管理问题都是面向分页的</strong>）第三个就是操作系统软件领域的问题，也是本节所述。</p>
<p>虚拟内存的操作系统策略：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/14.jpg" /></p>
<p>上表不存在一种绝对的最佳策略，<strong>在所有的策略中都要做到通过适当的安排，使得一个进程在执行时，访问一个未命中的页中的字的概率最小</strong>。</p>
<h5 id="读取策略">读取策略</h5>
<hr />
<p>读取策略决定某页何时取入内存，常用的两种方法是请求分页和预先分页</p>
<ul>
<li><strong>请求分页（demand paging）</strong>：只有当访问到某页中的一个单元时才将该页取入内存，开始缺页率高由于局部性原理之后缺页率会逐渐减少</li>
<li><strong>预先分页（prepaging）</strong>：利用大多数辅存设备的寻道时间和合理的延迟，一次读取多个连续的页，如果额外读取的页没有使用到，则低效</li>
</ul>
<h5 id="放置策略">放置策略</h5>
<hr />
<p>在纯分段系统中，放置策略并不是重要的设计问题（最佳适配、首次适配等均可）<strong>对于分页和段页式系统，如何放置通常无关紧要，因为地址转换硬件和内存访问硬件能以相同的效率为任何页框组合执行相应的功能</strong></p>
<h5 id="置换策略">置换策略</h5>
<hr />
<p>置换策略涉及到的问题有：</p>
<ul>
<li>给每个活动进程分配多少页框</li>
<li>计划置换的页集是局限于那些产生缺页中断的进程还是所有页框都在内存中的进程</li>
<li>在计划置换的页集中，选择换出哪一页</li>
</ul>
<p>前两个为驻留集管理，之后讨论，置换策略专指第三个概念</p>
<p><strong>页框锁定</strong>：注意的是对于被锁定的页框，则不能被用于置换，锁定是给每个页框关联一个锁定位实现的，可以包含在页框表和当前的页表中</p>
<p>基本算法有：</p>
<ul>
<li><p><strong>最佳（Optimal，OPT）</strong>：</p>
<p>选择置换下次访问距当前时间最长的那些页，这种方法是最优的，但是操作系统必须直到将来的事件，因此不可能实现，仅作为一种衡量标准</p></li>
<li><p><strong>最近最少使用（Least Recently Used，LRU）</strong>：</p>
<p>置换内存中最长时间未被引用的页，根据局部性原理，这也是最近最不可能访问到的页，其性能接近OPT策略，但较难实现，开销大</p></li>
<li><p><strong>先进先出（First In First Out，FIFO）</strong>：</p>
<p>将分配给进程的页框视为一个循环缓冲区，并按循环方式移动页，需要一个指针在页框中循环，这种策略实际是置换驻留在内存时间最长的页，但通常导致频繁的换入换出页</p></li>
<li><p><strong>时钟（CLock）</strong>：</p>
<p>最简单的时钟策略给每个页框附加一个使用位，每当该页 <strong>装入内存，或被访问时使用位置为 1</strong>，并有一个指针与之相关联，当 <strong>一页被置换时，该指针指向位下一个页框</strong>。需要置换一页时，操作系统扫描缓冲区，<strong>查找一个使用位为 0 的页框，扫描过程中遇到使用位为 1 时，将其置为 0</strong>。</p>
<p>这个时钟策略类似 FIFO，不过它跳过了 1 的项，1 说明它最近访问过，时钟策略都是尽可能用少的开销达到 LRU 的效率</p></li>
</ul>
<p>四种方法的比较：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/15.jpg" /></p>
<p>对固定页框数量且为局部页面置换，有如下关系：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/16.jpg" /></p>
<p>一种更有效的时钟算法采取了<strong>使用位和修改位</strong>，此时每个页框状态有：</p>
<ul>
<li>最近未被访问，也未被修改 (u = 0; m = 0)</li>
<li>最近被访问，但未被修改 (u = 1; m = 0)</li>
<li>最近未被访问，但被修改 (u = 0; m = 1)</li>
<li>最近被访问，且被修改 (u = 1; m = 1)</li>
</ul>
<p>此时的时钟算法执行过程如下：</p>
<ol type="1">
<li>从指针的当前位置开始扫描缓冲区，选择遇到的第一个 (u = 0; m = 0) 用户置换</li>
<li>若第一步失败，则重新扫描，查找 (u = 0; m = 1) 的页框，选择第一次遇到的用于置换，在这一扫描过程中将每个跳过的页框的使用位置为0</li>
<li>若第2步失败，则指针回到最初的位置，且集合中所有页框的使用位均为0，重复第1步，并在必要时重复第二步，直到寻找到可用于置换的页框</li>
</ol>
<p>==此策略查找自被取入至今未被修改且未访问的页==（如果有的话），由于未被修改，则不需要写回辅存。</p>
<p>还有一种称为 <span id="page-buffer"><strong>页缓冲</strong></span> 的方法允许使用较简单的页面置换策略（FIFO）。这种算法不丢弃置换出的页而是分配到两个表中（不移动页移动对应的页表项）：</p>
<ol type="1">
<li>若未被修改，分配到空闲链表中</li>
<li>若已被修改则分配到修改页链表中</li>
</ol>
<p>这种方法的特定是，<strong>被置换的页仍然留在内存中</strong>，若进程访问该页，则可迅速返回该进程的驻留集且代价很小，实际上就是充当了高速缓存的角色</p>
<h5 id="驻留集管理">驻留集管理</h5>
<hr />
<p>对于驻留集（操作系统给进程分配的内存空间）大小，需要考虑以下几个因素：</p>
<ul>
<li>分配给一个进程的内存越少，则驻留在内存中的进程数就越多。增加了操作系统至少找到一个就绪进程的可能性，减少了由于交换而消耗的处理器时间</li>
<li>若一个进程在内存的页数较少，尽管有局部性原理，缺页率仍相对较高</li>
<li>给特定进程分配的内存空间超过一定大小后，由于局部性原理，改进程的缺页率没有明显的变化</li>
</ul>
<p>当代操作系统通常采取两种策略：</p>
<ul>
<li><strong>固定分配策略</strong>：为一个进程在内存中分配固定数量的页框</li>
<li><strong>可变分配策略</strong>：允许分配给一个进程的页框在该进程的生命周期中不断的发生变化</li>
</ul>
<p>可变分配策略的 <u>难点在于要求操作系统评估活动进程的行为</u>，会增加操作系统的软件开销</p>
<p>对于 <strong>置换范围</strong> 有局部和全局两类</p>
<ul>
<li><strong>局部置换策略</strong>：仅在产生这次缺页的进程的驻留页中选择</li>
<li><strong>全局置换策略</strong>：内存中所有未锁定的页都是置换目标</li>
</ul>
<p>置换范围和驻留集大小之间的关系：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/17.jpg" /></p>
<p>注意固定分配没有全局置换策略，因为如果替换其它进程的页框，因为需要保持页框数固定，则它也需要重新置换一个，则是无意义的</p>
<p><strong>工作集策略</strong>：略</p>
<h5 id="清除策略">清除策略</h5>
<hr />
<p>清除策略用于确定何时将已修改的一页写回辅存，通常有两种选择：</p>
<ul>
<li><strong>请求式清除</strong>：只有当一页被选择用于置换时写回</li>
<li><strong>预约式清除</strong>：将已修改的多页在需要使用它们占据的页框之前成批写回</li>
</ul>
<p>完全使用一种策略都存在危险，预约式请求可能在写回后又发生更改，这样就没太大的意义，请求式则意味着写回修改页和读入新页，且读入在写回前，会降低处理器的利用率</p>
<p>一种较好的方法是结合 <a href="#page-buffer"><strong>页缓冲技术</strong></a>：只清除可用于置换的页，去除了清除和置换操作之间的成对关系，被置换页可放于修改表和未修改表。修改表中的页可以周期性的成批写出，并移到未修改表中。未修改表的一页要么被访问到而回收，要么在其页框分配给另一页时被淘汰。</p>
<h5 id="加载控制">加载控制</h5>
<hr />
<p>加载控制会影响到驻留在内存中的进程数量，着称之为系统并发度。如果驻留进程过少，那么所有进程都处于阻塞态概率就较大，因而许多时间花费在交换上。另一方面，进程过多，那么驻留集大小可能会不够用，会发生频繁的缺页中断，导致系统抖动</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/18.jpg" /></p>
<p>解决上述冲突，可以使用工作集策略或 PFF 算法。还有人提出了 L=S 准则，通过调整系统并发度，来使缺页中断之间的平均时间等于处理一次缺页中断所需的平均时间。这样处理器的利用率达到最大。</p>
<p>也可以采用时钟页面置换算法，监视该算法中扫描页框的指针循环缓冲区的速度。速度低于某个给定的最小阈值时，表明出现了如下的一种或两种情况：</p>
<ol type="1">
<li>很少发生缺页中断，因此很少需要请求指针前进</li>
<li>对每个请求，指针扫描的平均页框数很小，表明有许多驻留页未被访问到，且均易于被置换</li>
</ol>
<p>在上述情况下，系统并发度可以安全的增加，另一方面，指针扫描速度超过某个阈值，表明缺页率很高，要么难以找到可置换页，说明系统并发度过高</p>
<p>系统并发度减小时，一个或多个当前驻留进程须被挂起（换出），可根据以下标准换出进程：</p>
<ul>
<li><strong>最低优先级进程</strong>：实现调度策略决策，与性能无关</li>
<li><strong>缺页中断进程</strong>：原因在于很有可能是中断任务的工作集还未驻留，因而挂起它对性能的影响最小。此外，由于它阻塞了一个一定会被阻塞的进程，并且消除了页面置换和I/On操作的开销，可以立即收到成效</li>
<li><strong>最后一个被激活的进程</strong>：这个进程的工作集最有可能还未驻留</li>
<li><strong>驻留集最小的进程</strong>：在将来再次装入时的代价最小，不利于局部性较小的程序</li>
<li><strong>最大空间的进程</strong>：可在过来使用的内存中得到最多的空闲页框，使它不会很快又处于去活状态</li>
<li><strong>具有最大剩余执行窗口的进程</strong>：类似最短处理时间优先的调度原则</li>
</ul>
<h2 id="第四部分-调度">第四部分 调度</h2>
<h3 id="第九章-单处理器调度">第九章 单处理器调度</h3>
<hr />
<p>多道程序设计系统中，需要提高处理器处理效率，所以需要合理的调度策略以达到效率的最大化。多道程序涉及的关键就是调度，典型的调度类型有四种，处 I/O 调度外其它三种调度类型都属于处理器调度</p>
<ul>
<li><strong>长程调度</strong>：决定加入待执行进程池</li>
<li><strong>中程调度</strong>：决定加入部分或全部位于内存中的进程集合</li>
<li><strong>短程调度</strong>：决定处理器执行哪个可运行进程</li>
<li><strong>I/O调度</strong>：决定I/O设备处理哪个进程挂起的I/O请求</li>
</ul>
<p>长程调度和中程调度主要由于系统并发度相关的性能驱动，这些在前面的章节就讨论过</p>
<h4 id="处理器调度的类型">9.1 处理器调度的类型</h4>
<p>处理器调度的目的是，<strong>以满足系统目标（响应时间、吞吐率、处理器效率）的方式，把进程分配到一个或多个处理器上执行</strong>。</p>
<p>调度的层次结构以及进程状态和其所属调度种类如下：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/01.jpg" /></p>
<p>调度决定哪个进程须等待、哪个进程能继续运行，因此会影响系统的性能。本质上说调度属于队列管理，用于在排队环境中减少延迟并优化性能。</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/02.jpg" /></p>
<h5 id="长程调度">长程调度</h5>
<hr />
<p>长程调度决定哪个程序可以进入系统中处理，因此它控制了系统的并发度。调度程序必须决定操作系统 <strong>何时</strong> 才能接纳一个进程或多个进程；同时，调度程序必须决定接受哪个作业或哪些作业，并将其转变为进程。</p>
<p>何时创建一个新进程，通常由要求的系统并发度驱动，下次允许哪个作业进入决策可基于简单的先来先服务（FCFS）原则，或者其它基于管理系统性能的根据。</p>
<h5 id="中程调度">中程调度</h5>
<hr />
<p>中程调度是交换功能的一部分。典型情况下，换入决定取决于管理系统并发度的需求，在不使用虚存的系统中，存储管理也是个问题。因此换入决策将考虑换出进程的存储需求。</p>
<h5 id="短程调度">短程调度</h5>
<hr />
<p>长程调度程序执行的频率相对较低。短程调度程序，也称为分派程序（dispatcher）执行最为频繁，精确的决定下次执行哪个进程。</p>
<p>导致当前进程阻塞或抢占当前运行进程的事件发生时，调用短程调度程序，包括：</p>
<ul>
<li>时钟中断</li>
<li>I/O 中断</li>
<li>操作系统调用</li>
<li>信号（如信号量）</li>
</ul>
<h4 id="调度算法">9.2 调度算法</h4>
<h5 id="短程调度规则">短程调度规则</h5>
<hr />
<p>短程调度的主要目标是按照优化系统一个或多个方面行为的方式，来分配处理器时间。</p>
<p>常用的规则可按两个维度来分类</p>
<ol type="1">
<li>面向用户的规则和面向系统的规则
<ul>
<li>面向用户的规则与单个用户或进程感知到的系统行为相关，例如交互式系统中的响应时间</li>
<li>面向系统则注重处理器使用的效果和效率，如吞吐量</li>
</ul></li>
<li>是否与性能直接相关维度
<ul>
<li>与性能直接相关，如响应时间和吞吐量</li>
<li>与性能无关，不易测量或者定性规则</li>
</ul></li>
</ol>
<p>下表总结了几种重要的调度规则，相互依赖，不可能同时达到最优，比如提供较好的响应时间可能需要调度算法在进程间频繁切换，但也会增加系统开销，降低吞吐量。</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/03.jpg" /></p>
<h5 id="优先级的使用">优先级的使用</h5>
<hr />
<p>可以为每个进程指定一个优先级，调度程序总是优先选择具有较高优先级的进程，纯优先级调度方案可能导致低优先级进程可能会长期处于饥饿状态。可以让一个进程的优先级随时间或执行历史而变化，例如调度算法中的 <strong>反馈</strong> 法</p>
<h5 id="选择调度策略">选择调度策略</h5>
<hr />
<p>有以下三个参数：</p>
<ul>
<li><em>w</em>：目前为止在系统中的停留时间</li>
<li><em>e</em>：目前位置花费的执行时间</li>
<li><em>s</em>：进程所需的服务总时间</li>
</ul>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/04.jpg" /></p>
<ul>
<li><strong>非抢占</strong>：一旦进程处于运行状态，就会不断执行直到终止。进程要么因为等待I/O，要么因为请求某些操作系统服务而阻塞自己</li>
<li><strong>抢占</strong>：当前正运行进程可能被操作系统中断，并转换为就绪态</li>
</ul>
<p>与非抢占策略相比，抢占策略虽然会导致较大的开销，但能为所有进程提供较好的服务，因为它们避免了任何一个进程长时间独占处理器的情形。</p>
<p><strong>周转时间（turnaround time）</strong>：就是驻留时间 <span class="math inline">\(T_r\)</span> ，或这一项在系统中花费的总时间（等待时间+服务时间），另外有用的是归一化周转时间，为周转时间与服务时间的比值，<strong>表示一个进程的相对延迟情况</strong>。</p>
<p>下面是一个例子：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/05.jpg" /></p>
<p>调度策略的比较如下：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/06.jpg" /></p>
<p>各个策略的效率的简单度量：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/07.jpg" /></p>
<h5 id="先来先服务-fcfs">先来先服务 FCFS</h5>
<hr />
<p>FCFS 是长进程友好的，而且相对于I/O密集进程，更有利于处理器密集型进程，其它进程，FCFS可能导致处理器和I/O设备都未得到充分利用。</p>
<p>FCFS 自身对于单处理器系统而言并不是很有吸引力的选择，但它与优先级策略结合后通常能提供一种更有效的调度方法，如反馈。</p>
<h5 id="轮转-round-robin">轮转 Round Robin</h5>
<hr />
<p>根据<strong>时间片（time slicing）</strong>周期性的产生时钟中断，出现中断后将进程放置到就绪队列中，然后基于FCFS策略选择下一个就绪作业运行。</p>
<p>轮转法对处理器密集型进程和I/O密集进程的处理不同。处理器密集型进程在执行过程中通常会使用大部分处理器时间，导致I/O密集型进程性能降低，使用I/O设备低效，响应时间变化较大。</p>
<p>虚拟轮转法，这种方法可以避免上述不公平性，此方法的不同之处在于，接触了I/O阻塞的进程都会转移到一个FCFS辅助队列中。进行调度决策时，辅助队列中的决策优先于就绪队列中的进程，这种方法在公平性方面确实优于轮转法</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/08.jpg" /></p>
<h5 id="最短进程优先-shortest-process-next-spn">最短进程优先 （Shortest Process Next， SPN）</h5>
<hr />
<p>SPN是非抢占的，短进程友好的，SPN的难点在于需要直到或至少需要估计每个进程所需的处理时间。对于批处理作业，系统要求程序员给出估计值，若执行时间远高于实际运行时间，系统可能终止该作业。实际中操作系统可为每个进程保留一个运行平均值，计算方法如下： <span class="math display">\[
S_{n+1} = \frac{1}{n}T_n+\frac{n-1}{n}S_n \\
T_i:第i个实例的处理器执行时间 \\
S_i:第i个实例的预测值
\]</span> 这属于<strong>指数平均法</strong>的一种，SPN的风险在于，长进程可能饥饿。</p>
<h5 id="最短剩余时间shortest-remaining-timesrt">最短剩余时间（Shortest Remaining Time，SRT）</h5>
<hr />
<p>相当于是在SPN中增加了抢占机制的策略，和SPN一样，调度程序在执行选择函数的时候，必须具备关于处理时间的估计，并且具有长进程饥饿的风险。</p>
<p>SRT不像FCFS那样偏向长进程，也不像轮转法那样产生额外的中断，所以降低了开销。但是它必须记录过去的服务时间，又增加了开销，对于SPN，从周转时间上看，SRT性能更好，因为相当于一个正在运行的长作业而言，短作业可以立即选择执行。</p>
<h5 id="最高响应比优先-highest-response-ratio-nexthrrn">最高响应比优先 （Highest Response Ratio Next，HRRN）</h5>
<hr />
<p>调度规则见之前的对比图。HRRN偏向短作业（小分母产生大比值），长进程由于得不到服务等待的时间会不断增加，因此比值变大。所以是比较公平的。</p>
<h5 id="反馈法">反馈法</h5>
<hr />
<p>调度基于抢占原则（按时间片）并使用动态优先级机制。一个进程首次进入系统时，会放在<em>RQ0</em>中当它首次被抢占并返回就绪态时，会放在<em>RQ1</em>中，在随后的时间内，每当它被抢占就降级一次直到最低级。因此，新到的进程和短进程会优于老进程和长进程。这种方法称为<strong>多级反馈（Multilevel Feedback）</strong>。</p>
<p>但存在一个问题，可能会造成长进程的饥饿。可以按以下办法解决：</p>
<ol type="1">
<li>给低优先级的进程更多的时间片，一般而言，从<em>RQi</em>中调度的进程允许执行 <span class="math inline">\(q=2^i\)</span> 时间后被抢占</li>
<li>当一个进程在其队列等待服务的时间超过一定时间后，就把它提升到优先级高的队列中</li>
</ol>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/09.jpg" /></p>
<h5 id="性能比较">性能比较</h5>
<hr />
<p>略</p>
<h5 id="公平共享调度-fair-share-scheduling">公平共享调度 （Fair-Share Scheduling ）</h5>
<hr />
<p>公平共享调度考虑了<strong>进程组</strong>调度的基本原则。每个用户（进程组）被指定了某种类型的权值，此<strong>权值定义了用户对系统资源的共享，而且是作为在所有使用资源中所占的比例来体现的，如处理器资源</strong>。</p>
<p>调度是根据优先级进行的，它会考虑三方面因素：</p>
<ol type="1">
<li>进程的基本优先级</li>
<li>近期使用处理器的情况</li>
<li>进程所在组近期使用处理器的情况</li>
</ol>
<p>优先级数值越大，所表示的优先级越低，适用于组<em>k</em>中进程<em>j</em>的公式如下：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/10.jpg" /></p>
<h2 id="第五部分-输入输出和文件">第五部分 输入/输出和文件</h2>
<h4 id="第十一章-io-管理和磁盘调度">第十一章 I/O 管理和磁盘调度</h4>
<hr />
<h4 id="io-设备">11.1 I/O 设备</h4>
<hr />
<p>计算机系统中参与I/O的外设可以分为以下三类：</p>
<ul>
<li><strong>人可读</strong>：适用于计算机用户间的交互，如打印机和终端</li>
<li><strong>机器可读</strong>：适用于电子设备通信，如磁盘驱动器</li>
<li><strong>通信</strong>：适用于远程设备通信，如调制解调器</li>
</ul>
<p>其中主要差别包括：</p>
<ul>
<li><strong>数据传送速率</strong></li>
<li><strong>应用</strong></li>
<li><strong>控制的复杂性</strong></li>
<li><strong>传送单位</strong>：字节流或者字符流的形式传送，也可按块</li>
<li><strong>数据表示</strong>：不同的数据编码方式</li>
<li><strong>错误条件</strong></li>
</ul>
<h4 id="io-功能的组织">11.2 I/O 功能的组织</h4>
<hr />
<p>执行I/O的三种技术：</p>
<ul>
<li><strong>程序控制I/O</strong>：无中断</li>
<li><strong>中断驱动I/O</strong>：中断</li>
<li><strong>直接存储器访问</strong>：中断，一个DMA模块控制内存和I/O模块之间的数据交换。传送一块数据，处理器给DMA模块发送请求，当整个模块传送结束后，它才被中断，<strong>只有传送的开始和结束才会使用处理器</strong></li>
</ul>
<p>可选的DMA配置如下：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_11/01.jpg" /></p>
<h4 id="操作系统设计问题">11.3 操作系统设计问题</h4>
<hr />
<p>两个最重要的目标：</p>
<ul>
<li><strong>效率</strong>：大多数I/O设备的速度非常低，进程交换本身就是I/O操作</li>
<li><strong>通用性</strong>：需要从两个方面统一：一是处理器看待I/O设备的方式，二是操作系统管理I/O设备和I/O操作的方式</li>
</ul>
<h5 id="io-功能的逻辑结构">I/O 功能的逻辑结构</h5>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_11/02.jpg" /></p>
<h4 id="io-缓冲">11.4 I/O 缓冲</h4>
<p>为避免多余的开销和低效操作，在输入请求发出前就开始执行输入传送，并且在输出请求发出一段时间后才开始执输出传送，这样的技术称为<strong>缓冲</strong>。</p>
<p>两类I/O设备：</p>
<ul>
<li><strong>面向块</strong>：将信息保存在块中，块的大小通常是固定的</li>
<li><strong>面向流</strong>：设备以字节流的方式输入输出数据</li>
</ul>
<p>I/O缓冲方案：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_11/03.jpg" /></p>
<p>缓冲的作用：</p>
<p><strong>缓冲是用来平滑I/O需求的峰值的一种技术</strong>，但在进程的平均需求大于I/O设备的服务能力时，再多的缓冲也无法让I/O设备与进程一直并驾齐驱。</p>
<p>在多道程序设计中，当存在多种I/O活动和多种进程活动时，<strong>缓冲是提高操作系统效率和单个进程性能的一种方法</strong></p>
<h4 id="磁盘调度">11.5 磁盘调度</h4>
<h5 id="磁盘性能参数">磁盘性能参数</h5>
<hr />
<p>磁盘驱动器工作时，磁盘以某个恒定的速度旋转，为了读或写，磁头必须定位于指定磁道和该磁道中指定扇区的开始处。磁头定位到磁道所需要的时间称为<strong>寻道时间</strong>，之后，磁盘控制器开始等待直到适当的扇区旋转到磁头处，这段时间称为<strong>旋转延迟</strong>，<strong>寻道时间和旋转延迟的总和为存取时间</strong>，这是达到读或写位置所需要的时间，之后便开始执行读操作或写操作，这段时间就是<strong>传输时间</strong>。</p>
<p>总平均存取时间包括上面的三个，可用公式表示 <span class="math display">\[
T_a = T_s + \frac{1}{2r}+\frac{b}{rN} \\
T_s 为平均寻道时间，b表示传输的字节数，N表示一个磁道的字节数，r表示旋转速度（转/秒）
\]</span> 时序比较的经典例子：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_11/04.jpg" /></p>
<h5 id="磁盘调度策略">磁盘调度策略</h5>
<hr />
<p>磁盘调度算法及其比较：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_11/07.jpg" /></p>
<p>访问的磁道序列为：55、58、39、18、90、160、150、38、184</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_11/05.jpg" /></p>
<p>除此之外，还有<strong>基于优先级（PRI）</strong>和<strong>后进先出</strong>的算法</p>
<p><strong>基于优先级</strong>并不会优化磁盘的利用率，但能满足操作系统的其它目标。通常较短的批作业和交互作业的优先级较高，而较长计算时间的长作业优先级较低。对于数据库系统这类策略往往使得性能较差。</p>
<p><strong>后进先出</strong>在事务处理系统中，由于顺序读取文件，可减少磁壁的运动，可以提高吞吐量并缩短队列长度，但可能会导致饥饿。</p>
<h4 id="raid">11.6 RAID</h4>
<p>略</p>
<h4 id="磁盘高速缓存">11.7 磁盘高速缓存</h4>
<p>磁盘高速缓存是内存中为磁盘扇区设置的一个缓冲区，包含磁盘中某些扇区的副本</p>
<p>进程从磁盘高速缓存中获取数据可以采取两种方式</p>
<ol type="1">
<li>在内存中把这一块数据缓存传送到用户进程的存储空间中</li>
<li>简单使用一个共享内存，传送指向磁盘告诉缓冲中响应的指针</li>
</ol>
<p>后一种方法节省了内存到内存的传输时间</p>
<p>对于<strong>置换策略</strong>可以以下两种：</p>
<ul>
<li><strong>最近最少使用（LRU）</strong>：置换在高速缓存中未被访问时间最长的块，可用一个栈完成</li>
<li><strong>最不常使用（LFU）</strong>：置换集合中访问次数最少的块</li>
</ul>
<p>简单的LFU不能判断那些整体很少访问但是近期访问频繁的块，可以使用LFU的改进版</p>
<p>使用分区，新区老区（中间区），对不同区的对应措施不同</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_11/06.jpg" /></p>
<h3 id="第十二章-文件管理">第十二章 文件管理</h3>
<p>典型情况下，文件管理系统由系统实用程序组成，它们可以作为具有特权的应用程序来运行。一般来说，整个文件管理系统都被当做操作系统的一部分</p>
<h4 id="概述">12.1 概述</h4>
<h5 id="文件和文件系统">文件和文件系统</h5>
<hr />
<p>文件有以下理想的属性：</p>
<ul>
<li>长期存在</li>
<li>可在进程间共享</li>
<li>结构</li>
</ul>
<p>文件的操作如下：</p>
<ul>
<li>创建</li>
<li>删除</li>
<li>打开</li>
<li>关闭</li>
<li>读</li>
<li>写</li>
</ul>
<h5 id="文件结构">文件结构</h5>
<hr />
<ul>
<li><strong>域</strong>：基本的数据单元，一个域包含一个值，域的长度是定长或者变长的，取决于文件的设计</li>
<li><strong>记录</strong>：是一组相关域的集合，可视为应用程序的一个单元</li>
<li><strong>文件</strong>：一组相似记录的集合，被用户和应用程序视为一个实体，并通过文件名访问</li>
<li><strong>数据库</strong>：一组相关数据的集合，数据元素间存在着明确的关系，且可供不同应用程序使用，数据库管理系统独立于操作系统</li>
</ul>
<p>文件系统架构：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/01.jpg" /></p>
<p>文件管理的要素：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/02.jpg" /></p>
<p>文件管理系统作为一个单独的系统实用程序和操作系统关注的是不同两方面的内容，之间的共同点是记录的处理。</p>
<h4 id="文件组织和访问">12.2 文件组织和访问</h4>
<p>在选择文件组织，有以下重要原则：</p>
<ul>
<li>快速修改</li>
<li>易于修改</li>
<li>节约存储空间</li>
<li>维护简单</li>
<li>可靠性</li>
</ul>
<p>这些原则的优先级取决于将要使用这些文件的应用程序</p>
<p>基本文件组织：</p>
<ul>
<li><strong>堆</strong>：<strong>是简单的文件组织形式</strong>，数据按它们到达的顺序被收集，每条记录由一串数据组成。堆的目的仅是积累大量的数据并保存，对文件没有结构，使用穷举查找的方式进行，当数据难以组织或在初期前采集数据时会用到。</li>
<li><strong>顺序文件</strong>：<strong>是最常用的文件组织形式</strong>，每条记录都使用固定的格式，所有记录具有相同的长度，并由相同数量、长度固定的域按特定顺序组成。每条记录的第一个域通常是<strong>关键域</strong>，唯一的标识这条记录，性能很差，也可组织成链表的方式。</li>
<li><strong>索引顺序文件</strong>：用于克服顺序文件的缺点，增加了两个特征：用于支持随机访问的文件索引和溢出文件。索引顺序文件极大的减少了访问单条记录的时间，同时保留了文件的顺序特性，多级索引可以提供更有效的访问</li>
<li><strong>索引文件</strong>：索引顺序文件保留了顺序文件的一个限制：基于文件的一个域进行处理。当需要基于其它属性而非关键域查找一条记录时，这两种形式的顺序文件都无法胜任。索引文件采取多索引的结构，摒弃了顺序性和关键字的概念，只能通过索引来访问记录。对记录的位置不再有限制，还可使用长度可变的记录。</li>
<li><strong>直接或散列文件</strong>：直接访问磁盘中任何一个地址已知块的能力。直接文件使用基于关键字的散列，直接文件常在要求快速访问时使用，且记录的长度是固定的，通常一次访问一条记录。</li>
</ul>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/03.jpg" /></p>
<h4 id="文件目录">12.4 文件目录</h4>
<p>目录包含关于文件的信息，如属性、位置、所有权，都由操作系统管理。</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/04.jpg" /></p>
<p>目录的结构通常是树状结构：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/05.jpg" /></p>
<h4 id="文件共享">12.5 文件共享</h4>
<p>文件共享会产生两个问题：<strong>访问权限</strong>和<strong>同时访问的管理</strong>。</p>
<p>访问权限有如下：</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/06.jpg" /></p>
<p>话可以按面向用户分组：特定用户，用户组，全部</p>
<p>对于同时访问，必须解决互斥和死锁问题</p>
<h4 id="记录组块">12.6 记录组块</h4>
<p>记录是访问结构化文件的逻辑单元，而块是与辅存进行I/O操作的基本单位，为执行I/O，记录必须组织成块。</p>
<p>对于给定的块大小，有三种组块方法：</p>
<ul>
<li><strong>定长组块</strong>：使用定长的记录，且若干完整的记录保存在一个块中，块末尾可能会有未使用空间，称为内部碎片</li>
<li><strong>变长跨越式组块</strong>：使用变长的记录，并紧缩到块中，块中不存在未使用的空间，某些记录会跨越两个块，使用指针连接</li>
<li><strong>变长非跨越式组块</strong>：使用变长的记录，但不采用跨越方式，在大多数块中都会有未使用的空间</li>
</ul>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/07.jpg" /></p>
<p>定长组块是记录定产顺序文件最常用的方式，变长跨越式存储效率高，但难以实现。跨越两个块需要两次I/O操作，文件很难修改。变长非跨越式浪费空间，且存在记录大小不能超过块大小的限制。</p>
<h4 id="辅存管理">12.7 辅存管理</h4>
<p>在辅存中，文件是由许多块组成。操作系统负责为文件分配块。</p>
<h5 id="文件分配">文件分配</h5>
<hr />
<ul>
<li><strong>预分配</strong>：在发出创建文件的请求时，声明该文件的最大尺寸</li>
<li><strong>动态分配</strong>：只有在需要的时候才给文件分配空间</li>
</ul>
<p>对于分配给文件的<strong>分区大小</strong>，我们需要考虑下面四项内容：</p>
<ol type="1">
<li>邻近空间可以提高性能</li>
<li>数量较多的小分区会增加</li>
<li>使用固定大小的分区可以简化空间的再分配</li>
<li>使用可变大小的分区或固定大小的小分区，可减少超额分配导致未使用存储空间的浪费</li>
</ol>
<p>有以下两个选择：</p>
<ul>
<li><strong>大小可变的大规模连续分区</strong>：大小可变避免了浪费，且会使文件分配表较小，但着会导致空间很难再次利用</li>
<li><strong>块</strong>：小的固定分区能提供更大的灵活性，但为了分配，它们可能需要较大的表或更复杂的结构</li>
</ul>
<p>选择策略有：</p>
<ul>
<li>首次适配</li>
<li>最佳适配</li>
<li>最近适配</li>
</ul>
<h5 id="文件分配方法">文件分配方法</h5>
<hr />
<p><strong>连续分配</strong>：创建文件时，给文件分配一组连续的块。需要在创建文件时声明文件的大小，会出现外部碎片，所以需要紧缩算法</p>
<p><strong>链式分配</strong>：链式分配基于单个块，使用指针建立联系，不必担心外部碎片的出现，但是局部性原理不再适用，为了克服这个问题，有些系统会周期性的合并文件</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/08.jpg" /></p>
<p><strong>索引分配</strong>：解决了连续分配和链式分配中的许多问题。每个问价在文件分配表中都有一个一级的索引，分配给该文件的每个分区在索引中都有一个表项。</p>
<p><img src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/09.jpg" /></p>
<h5 id="空闲空间管理">空闲空间管理</h5>
<p>除了文件分配表外，还需要<strong>磁盘分配表（Disk Allocation Table，DAT）</strong></p>
<ul>
<li><strong>位表</strong>：使用一个向量值00111000标识空闲块，通过它能相对容易的找到一个或一组连续的空闲块，而且很小，但其长度仍然很长。</li>
<li><strong>链接空闲区</strong>：使用指向每个空闲区的指针和它们的长度值，链接在一起，开销很小。使用一段时间后，会出现许多碎片。删除一个由许多碎片组成的文件也非常耗时</li>
<li><strong>索引</strong>：索引方法把空闲空间视为一个文件，并使用一个索引表，索引基于可变大小的分区而非块</li>
<li><strong>空闲块列表</strong>：每块都指定一个序号，所有空闲块序号保存在磁盘的一个保留区中。</li>
</ul>
<p><strong>卷</strong>：一组分配在可寻址的扇区的集合，操作系统或应用程序用卷来存储数据。卷中的扇区在物理存储设备上不需要连续，只需要对操作系统或应用程序来说连续即可。卷可能由更小的卷合并或组合而成。最简单的情况下，一个单独的磁盘就是一个卷，通常一个磁盘会分为几个分区，每个分区都作为一个单独的卷来工作。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】图像特征检测，描述和匹配</title>
    <url>/2020/12/03/2020-12-03-Image%20Features%20Detection%20Description%20and%20Matching/</url>
    <content><![CDATA[<blockquote>
<p>Hassaballah, M. , A. A. Ali , and H. A. Alshazly . &quot;Image Features Detection, Description and Matching.&quot; (2016).a</p>
<p>原文地址：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnNwcmluZ2VyLmNvbS9jaGFwdGVyLzEwLjEwMDclMkY5NzgtMy0zMTktMjg4NTQtM18y">Image Features Detection, Description and Matching<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><strong>摘要</strong> 特征检测，描述和匹配是计算机视觉应用中重要的组成部分，因此它们在前几十年中受到了极大的注意。几种特征检测器和描述符已经在文献在中被提出，且对图像中那些具有潜在吸引力（即，具有一种独特的属性）的点做了许多定义。这篇文章为检测和描述图像特征介绍了基本符号和数学概念。然后文章还讨论了完美特征所具有的性质并且概述了现存的多种检测和描述方法。更深地，文章还解释了一些特征匹配方法。最后，文章讨论了最常用的检测和描述算法性能评估技术。</p>
<p><strong>关键词</strong> 兴趣点 特征检测器 特征描述符 特征提取 特征匹配</p>
<a id="more"></a>
<h2 id="介绍">1 介绍</h2>
<p>在前几十年中，图像特征检测器和描述符已经成为计算机视觉社区中最流行的工具并且被广泛应用在大量的应用中。图像表示 【1】，图像分类和图像检索 【2-5】，目标识别和匹配 【6-10】，三维场景重建 【11】，动作追踪 【12-14】，纹理分类 【15-16】，机器人定位 【17-19】，以及生物识别系统 【20-22】，所有都依赖于图像中稳定且有代表性的特征。因此，对于这些应用，检测和提取图像特征是十分重要的步骤。</p>
<p>为了建立图像之间的对应关系，其中两个或多个图像的对应关系是需要的，确定每一幅图像中显著的点集是重要的 【8，23】。在分类任务中，目标图像的特征描述符和训练完成的图像特征相匹配，并且已训练图像中具有最大一致对应关系的就是最佳匹配。在这种情况下，特征描述符匹配可以建立在距离测量上，例如欧几里得距离或者马氏距离。对于图像配准，同一场景不同设备不同时间获取的两幅或者多幅图像的空间对齐是十分重要的。图像配准或对齐任务中主要的步骤为：特征检测，特征匹配，基于图像中一致特征的变换函数的推导，以及基于导出的变换函数的图像重建【24】。任何匹配、识别系统的首要步骤是检测以及描述图像中的兴趣位置。一旦计算出描述符，比较这些描述符可以得到图像间的关系以完成匹配、识别任务。另外，对于线上街道级别虚拟导航应用，我们需要特征检测和特征描述符从一些平面图像（全景图像）中取提取特征【25】。</p>
<p>基本思想是首先检测对一类转换协变的兴趣区域。然后，对于每个检测到的区域，在检测到的关键点周围构建图像数据的不变特征向量表示（即描述符）。<u>从图像中提取特征描述符可以基于二阶统计数据、参数模型、从图像变换中获取的参数，甚至是这些方法的组合。</u>两种图像特征可以从图像内容表示中提取出来：<u>全局特征和局部特征</u>。全局特征（例如颜色和纹理）目的是将图像作为整体考虑，可以解释为从图像所有像素中获取的一种特别的属性。然而，局部特征是用于发现和描述图像中的关键点或兴趣区域。在这方面，如果局部特征算法在图像中检测到 n 个关键点，就有 n 个向量描述每一个关键点的形状，颜色，方向，纹理等。全局颜色和纹理特征被证实在数据库中寻找相似图像十分有用，而面向局部结构的特征适合目标分类或者寻找同一对象或场景的其它事件【26】。同时，全局特征不能区分图像的前景和背景，以及两个部分的混合信息【27】。</p>
<p>另一方面，因为实时应用需要处理更多数据或者需要在计算能力有限的移动设备中运行，对可以快速计算，快速匹配，有效利用内存并且还要保持好的准确度的局部特征描述符的需求在不断增长。另外，对移动平台上的图像匹配来说，局部特征描述符被证实是一个很好的选择，在这里可以处理遮挡和丢失的对象【18】。<u>对于相机标定，图像分类，图像检索和目标追踪、重建这一类具体应用，特征检测器和描述符对亮度、视角改变和图像扭曲（例如噪声，模糊，光照）的鲁棒性是十分重要的</u>【28】。 而其他特定的视觉识别任务，如人脸检测或识别，则需要使用特定的检测器和描述符【29】。</p>
<p>在文献中，大量的特征提取方法被提出来计算可靠的描述符。有些描述符是专门为特定的应用场景设计例如形状匹配【29，30】。在这些描述符中，<u>尺度不变特征变换（SIFT）</u>描述符【31】利用了高斯函数中一系列差分（DoG）中的局部极值来提取鲁棒性特征，并且<u>加速稳健特征（SURF）</u>描述符【32】受到 SIFT 的部分启发，用于快速计算独特不变的局部特征，SURF 十分流行且广泛应用于多种应用。这些描述符使用预设的过滤器和非线性操作来表示突出的图像区域。在文章的剩余部分， 我们概述了这些方法和算法以及开发人员提出的改进。更深地，我们也将介绍检测和描述图像特征的基础符号和数学概念。我们还在细节上探索检测器和描述符之间的量化关系以及如何评估它们的性能。</p>
<h2 id="定义和原理">2 定义和原理</h2>
<h3 id="全局和局部特征">2.1 全局和局部特征</h3>
<p>在图像处理和计算机视觉任务中，我们需要表示图像通过其特征。原始图像对人眼是抑郁提取特征的，但是对于计算机算法并非如此。总的来说，有两种表示图像的方法，全局特征和局部特征。在全局特征表达中，图像通过一个多维特征向量表示，用来描述整幅图像中的信息。换句话说，全局表示方法会生成一个单一向量，这个向量包含图像的多个方面的可测量信息，例如颜色，纹理或者形状。特别地，每幅图像中提取的单一向量可以用来作比较。例如，当一个人想要区分两幅图像，分别是关于海（蓝色）和森林（绿色）的，一个关于颜色的全局描述符可以为每个类生成完全不同的向量。在这样的背景下，全局特征可以被解释为图像中涉及所有像素的一个特别的属性。这种属性可以是颜色直方图，纹理，边缘，甚至是将图像滤波后的描述符【33】。在另一方面，局部特征表示的主要目标是根据一些显著区域区别表示图像，同时保持视角和光照不变性。因此，<u>图像是基于它的局部结构，通过从一组被称为兴趣区域（即关键点）的图像区域中提取的局部特征描述符集合来描述的</u>。 <strong><em>Fig. 1</em></strong> 描述了这些兴趣区域。大部分局部特征表达了图像块中的纹理。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201111213719530.png" alt="image-20201111213719530" style="zoom:60%;" /></p>
<p>总的来说，使用哪一种特征一般上很大程度上会依赖于手头上的应用，开发者偏向于最具有区分度的。例如，一个有着大鼻子和小眼睛的人和另一个小鼻子和大眼睛的人在释放图或者灰度分布上会有相似的面部照片。然后，从局部特征簇提取的局部特征或者全局模式看起来会根据有区分度。然而，<u>对于在 WEB 尺度级图像索引应用中的大型数据库，考虑全局特征识是合适的</u>。再者，<u>全局特征对那些可以接受粗略地兴趣目标分割应用是有用的。全局特征的优势在于它们更快，更紧凑同时易于计算且内存友好</u>。不过，全局表示也受到一些众所周知的限制，尤其是它们<u>对一些重要变换不能保持不变，并且对杂物和遮挡敏感</u>。在一些应用中，例如副本检测，许多非法拷贝和原件是十分相似的；它们仅收到压缩，缩放或者有限的裁剪【34】。同时，使用为大尺度图像搜索局部特征可以提供更好的效果【35】。另外因为局部结构比其它平滑区域结构更易区分且稳定，所以局部特征在图像匹配和目标识别中更有用。然而，它们经常需要大量的内存，因为图像可能包含成百上千个局部图像描述符。研究者建议将局部图像描述符聚集为一个紧凑向量并且降维优化【35】。</p>
<h3 id="特征检测器的特征">2.2 特征检测器的特征</h3>
<p><em>Tuytelaars</em> 和 <em>Mikolajczyk</em>【27】将局部特征定义为“是一个与其邻居区分开的图像模式”。因此，它们认为局部不变特征的目标是提供一种可以有效匹配图像间局部结构的表示。也就是说，我们希望获取一组稀疏的局部度量，这些度量可以捕获输入图像的本质并对它们的兴趣区域进行编码。为了这个目标，特征检测器和提取器必须有某些性质，同时需要记住这些性质的重要性依赖于实际的应用设置以及做出的妥协。下面列举的性质对在计算机视觉应用中运用特征是十分重要的：</p>
<ul>
<li><strong>鲁棒性</strong>，特征检测算法需要检测出同一个特征位置，不依赖缩放，选择，平移，光度变形，人为压缩和噪声。</li>
<li><strong>可重用性</strong>，特征检测算法可以在不同观测条件下获取的同一场景图像反复检测出相同的特征。</li>
<li><strong>准确性</strong>，特征检测算法应该准确地定位图像特征（相同像素位置），尤其是在需要精确对应关系来估计对极几何<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>（the epipolar geometry）的图像匹配任务中。</li>
<li><strong>通用性</strong>，特征检测算法需要可以在不同应用中检测特征。</li>
<li><strong>高效性</strong>，特征检测算法应该能够在新图像中快速检测特征以支持实时应用。</li>
<li><strong>保量性</strong>，图像检测算法需要检测所有的或者大量的图像特征。其中，检测出的特征密度应该反映图像的信息内容以提供紧凑的图像表示。</li>
</ul>
<h3 id="尺度和仿射不变性">2.3 尺度和仿射不变性</h3>
<p>事实上，基于矩形或者圆形这类固定形状的区域匹配，在存在一些几何和光度畸变下，寻找对应关系是不可靠的，因为它们会影响区域形状。数字图形中的目标在不同的观察尺度下会有不同的外表。因此，在分析图像内容时，尺度改变会产生重要的影响。已经提出了不同的技术来解决在这种条件下检测和提取不变图像特征。一些是处理尺度变化，还有一些则更深层次地处理仿射变换。为了解决尺度变化，这些技术假设尺度的变化在所有方向上都是相同的(即均匀的)，并使用尺度空间的连续核函数在所有可能的尺度上搜索稳定的特征。其中，<u>图像的大小是不同的，并且滤波器（例如，高斯滤波器）重复地用来平滑图像，也可以保持原始图像大小，改变滤波器的大小</u>，如 <strong><em>Fig. 2</em></strong> 所示。更多关于在尺度改变下的特征检测细节可以在【36】中找到，在这之中提出了一个用于生成图像兴趣尺度级的假设，通过在高斯拉普拉斯（LoG）归一化后的尺度中寻找尺度空间极值。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201114203537215.png" alt="image-20201114203537215" style="zoom:60%;" /></p>
<p>在另一个方面，<u>在仿射变换中每一个方向的缩放可以是不同的</u><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。不均匀的缩放对定位，尺度，局部结构形状都有影响。因此，尺度不变检测器在这种显著仿射变换中会失效。因此，在这种均匀缩放下的特征检测器需要拓展成仿射不变检测器，以检测局部图像结构的仿射形状。因此，这些放射不变检测器可以看作是尺度不变检测器的一般推广。</p>
<p>总的来说，仿射变换是一系列变换的组合：平移，缩放，翻转，旋转，和剪切<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>。一个仿射变换（affinity）是任一个保持共线性和距离比的线性映射。在这个角度上看，仿射意味着是射影变换的一个特殊情况，他不会把任何对象从仿射空间 <span class="math inline">\(\mathbb{R}^3\)</span> 移至无穷远平面，反之亦然。简单来说，<span class="math inline">\(\mathbb{R}^n\)</span> 仿射变换是一个映射 <span class="math inline">\(f:\mathbb{R}^n \rightarrow \mathbb{R}^n\)</span>，具体形式如下： <span class="math display">\[
f(Y) = \mathbb{A} Y + \mathbb{B}
\]</span> 对所有的 <span class="math inline">\(Y\in \mathbb{R}^n\)</span> ，其中 <span class="math inline">\(\mathbb{A}\)</span> 为 <span class="math inline">\(\mathbb{R}^n\)</span> 上的线性变换。在一些特殊的情况，如果 <span class="math inline">\(det(\mathbb{A}) \gt 0\)</span>，这样的变换被称为保向，然而如果 <span class="math inline">\(det(\mathbb{A}) \lt 0\)</span>，则被称为方向反转。众所周知的是，在特定变换族下的函数是不变的，当它的值不随其参数上的变换族改变而改变。二阶矩矩阵为估计局部图像特征的仿射形状提供了理论依据。<u>仿射不变检测器有以下几种：Harris-affifine，Hessian-affifine，以及 maximally stable extremal regions (MSER)</u>。还需要记住的是这些检测器检测的特征会从圆形变换为椭圆形。</p>
<h2 id="图像特征检测器">3 图像特征检测器</h2>
<p><u>特征检测器可以大概地分为三类：单尺度检测器，多尺度检测器以及仿射不变检测器。</u>概括地说，单尺度意味着使用检测器内部参数对特征或目标轮廓仅有一个表示。单尺度检测器对诸如旋转，平移，光照改变和附加噪声的变换是不变的。然而，它们不适用于处理缩放问题。给定同一场景的但尺度不同的两幅图像，我们想要确定是否可以检测到相同的兴趣点。因此，在尺度改变下，建立能够可靠地提取显著特征的多尺度检测器是有必要的。接下来我们会讨论单尺度和多尺度检测器以及仿射不变检测器的细节。</p>
<h3 id="单尺度检测器">3.1 单尺度检测器</h3>
<h4 id="moravecs-检测器">3.1.1 Moravec’s 检测器</h4>
<p>Moravec’s 检测器【37】对寻找图像中完全不同的区域感兴趣，这可以用于记录连续图像帧。它被用于角点检测算法，其中角点是那些低自相似性的点。 这个检测器测试给定图像的每一个像素来确定是否是一个角点。它考虑以某个像素为中心的局部图像块，然后确定它与相邻图像块的相似度。这个相似度是使用中心图像块核其它图像块的平方差之和（SSD）来确定的。基于 SSD 的值，我们需要考虑以下几种情况：</p>
<ul>
<li>如果像素在均匀强度的区域内，那么相邻的块会看起来相似或者发生很小的变化。</li>
<li>如果像素在边上，那么在平行方向的相邻块只有很小的改变，与边垂直的方向会有很大的变化。</li>
<li>如果像素在一个任意方向都会发生很大变化的位置，那么没有相邻块会与其相似，当任意平移都会发生很大改变时，也就检测到了一个角点。</li>
</ul>
<p>块与其邻居（水平，垂直和两个对角线）之间最小的 SSD 被用于角的一个度量。一个角或者兴趣点当 SSD 达到一个局部最大值时被检测到。下面的步骤可以用于实现 Moravec’s 检测器：</p>
<ol type="1">
<li><p>输入：灰度图像，窗口大小，阈值 <span class="math inline">\(T\)</span></p></li>
<li><p>对图像中的每一个像素 <span class="math inline">\((x,y)\)</span>，以及平移量 <span class="math inline">\((u,v)\)</span>，计算强度变化 <span class="math inline">\(V\)</span>，如下 <span class="math display">\[
 V_{u,v}(x,y) = \sum_{\forall a,b \in window } [I(x+u+a,y+v+b) - I(x+a,y+b)]^2
 \]</span></p></li>
<li><p>通过计算角测度 <span class="math inline">\(C(x,y)\)</span> 为每一个像素 <span class="math inline">\((x,y)\)</span> 构建对应的角图 <span class="math display">\[
 C(x,y) = min(V_{u,v}(x,y))
 \]</span></p></li>
<li><p>对所有角图中所有小于 T 的值归 0</p></li>
<li><p>使用非最大值抑制寻找局部最大值。剩下所有的非零值为角点。</p></li>
</ol>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201115201625703.png" alt="image-20201115201625703" style="zoom:60%;" /></p>
<p>为了执行非最大值抑制，需要按梯度方向扫描一幅图像，这个方向是与边方向是垂直的。所有不是局部最大值的像素都会被抑制为 0。正如 <strong><em>Fig.3</em></strong> 所描述的，p 和 r 是在 q 梯度方向上的两个相邻点。如果像素 q 的值比 p，q 任一个小，则抑制。Moravec’s 检测器的一个优势为可以检测出大量的角点。然而，<u>它不是各向同性的。强度改变值仅仅在一些离散的位移上（例如，8 个理论方向）并且不再这 8 个相邻方向上的边会被分配到一个相对大的角测度。</u>因此，它不是旋转不变的<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>，这也导致了可重用率低。</p>
<h4 id="harris-检测器">3.1.2 Harris 检测器</h4>
<p>Harris 和 Stephens【38】发展了一种结合角和边检测器的方法以解决 Moravec’s 检测器中的限制。通过获取所有方向上的自相关改变量（例如，强度改变），这使得检测器在检测和重用率上变得可取。这个基于自相关矩阵的检测器是应用最广泛的技术。这个用于检测图像特征以及描述局部结构的 2*2 对称自相关矩阵如下表示<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>： <span class="math display">\[
M(x,y) = \sum_{x,y} w(u,v) \times 
\left[
\begin{matrix}
I_x^2(u,v) &amp; I_xI_y(u,v) \\
I_xI_y(u,v) &amp; I_y^2(u,v)
\end{matrix}
\right]
\]</span></p>
<p>其中 <span class="math inline">\(I_x,I_y\)</span> 分别是在 x 和 y 方向上的局部图像微分，<span class="math inline">\(w(u,v)\)</span> 表示以 <span class="math inline">\((x,y)\)</span> 为中心的区域 <span class="math inline">\((u,v)\)</span> 中的加权窗口。如果一个圆形窗口，例如高斯函数，那么这个响应将是各向同性的，并且中心部分会有更高的权重。为了寻找兴趣点，将为每一个像素计算矩阵 M 的特征值。如果两个特征值都很大就代表这里存在着角点。特征值和检测点的分类关系描述在 <strong><em>Fig.4</em></strong> 中。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201115224916303.png" alt="image-20201115224916303" style="zoom:67%;" /></p>
<p>通过为每一个像素 <span class="math inline">\((x,y)\)</span> 计算角测度 <span class="math inline">\(C(x,y)\)</span> 构建响应图，<span class="math inline">\(C(x,y)\)</span> 计算公式如下： <span class="math display">\[
C(x,y)=det(M) - K(trace(M))^2
\]</span> 其中 <span class="math display">\[
\begin{align}
det(M) &amp;= \lambda_1 \times \lambda_2 \\
trace(M) &amp;= \lambda_1 + \lambda_2
\end{align}
\]</span> K 是一个调节参数，<span class="math inline">\(\lambda_1,\lambda_2\)</span> 是自相关矩阵的特征值。特征值计算的开销是昂贵的，因为涉及到平方根的计算。因此，Harris 建议使用这个角测度，它将两个特征值合并在一个计算中。非最大值抑制用于寻找局部最大值，最后角测度图中保留的非零点就是寻找到的角点。<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<h4 id="susan-检测器">3.1.3 SUSAN 检测器</h4>
<p>Simith 和 Brady 【39】介绍了一中不使用图像微分的角点计算方法，是一种通用的低层次的图像处理技术，称为 SUSAN（Smallest Univalue Segment Assimilating Nucleus）<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>。它不仅是一个角检测器还可以用于边缘检测核图像降噪。<u>通过在每一个像素上放置一个固定半径的圆形掩膜来检测角点</u>。中心像素就代表着核，掩膜下的其它像素会与核相比较来检查是否与核有相似的强度值。<u>与核亮度十分相似的像素归为一组，被称为 USAN （Univalve Segment Assimilating Nucleus）。当一个位置的 USAN 中的像素个数达到一个局部最小值并且低于特别的阈值 T，这个位置就是角点</u>。为了检测角点，同一掩膜下的两个像素的相似比较函数 <span class="math inline">\(C(r,r_0)\)</span> 如下表示： <span class="math display">\[
C(r,r_0) = 
\left\{
\begin{align}
1&amp;, &amp;\text{if　}\vert I(r)-I(r_0) \vert \le T \\
0&amp;, &amp; otherwise
\end{align}
\right.
\]</span> 并且 USAN 的区域大小为： <span class="math display">\[
n(r_0) = \sum_{r \in c(r_0)} C(r,r_0)
\]</span> 其中 <span class="math inline">\(r_0\)</span> 和 <span class="math inline">\(r\)</span> 分别是掩膜下核与其它点的坐标。SUSAN 角点检测器的性能主要依赖于相似比较函数 <span class="math inline">\(C(r,r_0)\)</span>，它不能免疫某些影响图像的因素（例如，强亮度波动和噪声）。</p>
<p>SUSAN 检测器有如下几个优势：</p>
<ol type="1">
<li>不需要使用微分，因此不需要额外的降噪或者任何昂贵的计算</li>
<li>高可重用率</li>
<li>平移以及旋转不变</li>
</ol>
<p>不幸的是，<u>它对尺度和其它变换不是不变的，并且固定的阈值不使用于一般情况</u>。这个检测器需要一个可适应的阈值，并且掩膜的形状需要改变。</p>
<h4 id="fast-检测器7">3.1.4 FAST 检测器<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a></h4>
<p>FAST（Features from Accelerated Segment Test）最初是由 Rosten 和 Drummondn 【40，41】提出的角点检测器。在这个检测方案中，通过对每个像素使用分段检测来确定候选点，该方法将围绕候选点的 16 个像素作为计算基础。如果在以 r 为半径的 Bresenham 圆上有一组包含 n 个连续像素，且这些像素全部比候选像素（表示为 <span class="math inline">\(I_p\)</span> ）与阈值 t 相加还亮，或者比与阈值相减还暗，那么 p 就被归为角点。有一种高速的检测方法来排除大量的非角点，这种快速检测方法仅检查 1，5，9，13 四个像素。一个角点必须满足至少有三个测试像素比 <span class="math inline">\(I_p+t\)</span> 亮或者比 <span class="math inline">\(I_p - t\)</span> 暗，快速检测方法剩下的点则使用原来的检测方法。<strong><em>Fig.5</em></strong> 描述了这个过程，其中放大的方块为角点检测使用的像素。像素 p 为候选角的中心。使用虚线描绘的弧中有 12 个连续像素比 p 亮了一个阈值。使用 <span class="math inline">\(r=3,n=9\)</span> 的圆可以带来最好的结果。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201116000143758.png" alt="image-20201116000143758" style="zoom:65%;" /></p>
<p>尽管高速测试可以有很好的性能，但还是受到了在【41】中提及的几个限制和不足。使用机器学习方法可以改善这些限制和不足。决策树算法（ID3）是一种著名的用于学习像素分类的方法，可以对上述算法有很大的加速。因为第一阶段测试会在兴趣点周围产生很多响应，所以需要额外执行非最大值抑制。这使得特征定位更加准确。这个步骤的角测度公式如下： <span class="math display">\[
C(x,y) = max(
\sum_{j\in S_{bright}}\vert I_{p\rightarrow j} - I_p \vert - t,
\sum_{j\in S_{dark}}\vert I_p - I_{p\rightarrow j} \vert - t
)
\]</span> 其中 <span class="math inline">\(I_{p\rightarrow j}\)</span> 表示位于 Bresenham 圆上的像素。用这个方法，处理时间依然是短，因为第二个阶段测试仅仅用于通过第一阶段测试的那一小部分像素。</p>
<p>换句话说，整个处理分为两个阶段。<u>首先，对给定 n 以及合适的阈值的分段测试的角点检测在一组图像（最好是取自目标应用域）上执行。圆上的 16 个像素被分为比中心暗，相似或者亮。然后，在这 16 个位置使用 ID3 算法来得到最大信息增益</u><a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>。 非最大值抑制应用于连续弧中像素与中心像素之间的绝对差值之和。注意到使用 ID3 算法执行的角点检测与使用分段检测器会有轻微的不同，因为决策树模型依赖于训练数据，这些模型不能覆盖所有的角点。<u>与现存的许多检测器相比，FAST 角点检测器的高速表现使其十分适合实时视频处理应用</u>。然而，<u>它不是尺度不变的，并且对噪声敏感</u>，它还依赖于阈值，选择一个合适的阈值是一个相当重要的工作。</p>
<h4 id="hessian-检测器10">3.1.5 Hessian 检测器<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a></h4>
<p>Hessian 斑点检测器【42，43】是以一个关于图像强度 <span class="math inline">\(I(x,y)\)</span> 的 <span class="math inline">\(2\times 2\)</span> 的二阶微分矩阵，这个矩阵称为 Hesian 矩阵。这个矩阵可以用于局部图像结构，并且其形式如下： <span class="math display">\[
H(x,y,\sigma) = 
\left[
\begin{matrix}
I_{xx}(x,y,\sigma) &amp; I_{xy}(x,y,\sigma) \\
I_{xy}(x,y,\sigma) &amp; I_{yy}(x,y,\sigma)
\end{matrix}
\right]
\]</span></p>
<p>其中 <span class="math inline">\(I_{xx},I_{xy},I_{yy}\)</span> 是二阶图像微分使用标准差为 <span class="math inline">\(\sigma\)</span> 的高斯函数计算，它寻找在两个正交方向上高响应的点。也就是说，检测器寻找那些满足 Hessian 矩阵行列式达到局部最大值的点： <span class="math display">\[
\text{det}(H) = I_{xx}I_{yy}-I_{xy}^2
\]</span> 通过选择具有最大行列式的带你，这个方法长结构不友好，因为长结构在一个方向上只有很小的二阶微分（即，信号改变）。使用 <span class="math inline">\(3\times 3\)</span> 的窗口对图像执行非最大值抑制，保持那些比周围 8 个像素都大的像素不变，否则置为 0。然后，检测器返回那些保留下来的像素中大于预设阈值 T 的像素。最后保留下来的主要为角点和纹理改变强烈的区域。虽然 Hessian 矩阵用于描述点周围 8 个相邻点的局部结构，但它的行列式可以用于检测在两个方向上表现出信号变化的图像结构。与其它检测器（例如，拉普拉斯）相比，Hessian 矩阵的行列式仅在两个正交方向显著改变的局部图像模式上响应【44】。然而，在检测器中使用二阶微分使得对噪声敏感。另外，局部最大值经常存在于轮廓或者直边上，在这些位置信号仅在一个方向上发生改变【45】。因此，这些局部最大值是不稳定的，因为噪声和相邻模式的轻微改变都会产生影响。</p>
<h3 id="多尺度检测器">3.2 多尺度检测器</h3>
<h4 id="高斯拉普拉斯log">3.2.1 高斯拉普拉斯（LoG）</h4>
<p>高斯拉普拉斯（Laplacian-of-Gaussian，LoG）是一个二阶微分的线性组合且是一个常用的斑点检测器。给定一副图像 <span class="math inline">\(I(x.y)\)</span> 作为输入，图像的尺度空间表示为 <span class="math inline">\(L(x,y,\sigma)\)</span>，通过图像和一系列不同高斯核卷积 <span class="math inline">\(G(x,y,\sigma)\)</span> 生成，其中 <span class="math display">\[
L(x,y,\sigma) = G(x,y,\sigma)\bigotimes I(x,y) \\
G(x,y,\sigma) = \frac{1}{2\pi \sigma^2} e^{\frac{-(x^2+y^2)}{2\sigma^2}}
\]</span> 通过下式计算拉普拉斯操作 <span class="math display">\[
\nabla^2L(x,y,\sigma) = L_{xx}(x,y,\sigma) + L_{yy}(x,y,\sigma)
\]</span></p>
<p>拉普拉斯对暗斑点呈现正响应，对亮斑点则是负响应，斑点大小为 <span class="math inline">\(\sqrt{2\sigma}\)</span> 时响应最强。然而，响应十分依赖于斑点结构的大小以及高斯平滑核的大小。高斯标准差用于控制模糊尺度。为了在图像域自动捕获不同大小的斑点，一种带有自动尺度选择的多尺度方法在【36】中提出，这种方法通过寻找如下式所示的<u>尺度归一化拉普拉斯</u>的尺度空间极值。 <span class="math display">\[
\nabla^2_{norm} L(x,y,\sigma) = \sigma^2(L_{xx}(x,y,\sigma) + L_{yy}(x,y,\sigma))
\]</span> 它还可以检测那些在空间和尺度上同时是归一化拉普拉斯极值的点。LoG 操作符是循环对称的，因此它很自然地具有旋转不变性。LoG 很适合斑点检测，因为它的循环对称性质，但它也为例如角，边，脊，多节（multi-junctions）这类局部结构提供了很好的<u>特征尺度</u><a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a>估计。在这种情况下，LoG 可用于为给定的图像位置寻找特征尺度或直接检测尺度不变区域，通过寻找 LoG 函数的 3D（位置和尺度<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>） 极值，如 <strong><em>Fig.6</em></strong> 所述。拉普拉斯的尺度选择性质可以在【46】中获取到细节。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201124171703461.png" alt="image-20201124171703461" style="zoom:80%;" /></p>
<h4 id="高斯差分dog">3.2.2 高斯差分（DoG）</h4>
<p>实际上，LoG 操作是十分耗时的。为了加速计算，Lowe【31】提出了一种基于局部三维极值的高效算法，极值是在使用高斯差分（Difference-of-Gaussian，DoG）构建的尺度空间金字塔中寻找的。这种方法应用于<em>尺度不变特征变换（SIFT）</em>算法。在这个背景下，DoG 给出了 LoG 的一种近似，并且用于从尺度空间极值中高效检测稳定特征。DoG 函数 <span class="math inline">\(D(x,y,\sigma)\)</span> 可以不使用卷积操作得出，通过高斯金字塔中由因子 k 分割的相邻尺度相减得到。 <span class="math display">\[
\begin{align}
D(x,y,\sigma) =&amp; (G(x,y,k\sigma)-G(x,y,\sigma)) \bigotimes I(x,y) \\
=&amp; L(x,y,k\sigma) - L(x,y,\sigma)
\end{align}
\]</span> 通过 DoG 提取的特征类型与 LoG 有一致的分类。DoG 区域检测器寻找 3D 尺度空间极值的过程如 <strong><em>Fig.7</em></strong> 所示。LoG 和 DoG 共有的<u>缺点为局部极值可以在相邻的直边轮廓中检测出，这种轮廓仅在一个方向上发生信号改变，使得它们稳定性下降，并对噪声和微小的改变敏感</u>【45】。</p>
<figure>
<img src="\assets\Note\Image%20Features%20Detection%20Description%20and%20Matching.assets\image-20201124174117634.png" alt="image-20201124174117634" /><figcaption>image-20201124174117634</figcaption>
</figure>
<h4 id="harris-laplace13">3.2.3 Harris-Laplace<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a></h4>
<p>Harris-Laplace 是由 Mikolajczyk 和 Schmid【45】提出的尺度不变的角点检测器。<u>它依赖于 Harris 角点检测器和高斯尺度空间的组合</u>。尽管 Harris 角点具有旋转不变性和光照不变性，但不是尺度不变的因此，对该检测器中使用的二阶矩矩阵进行了修正，使其与图像分辨率无关。Harris-Laplace 中的尺度适应的二阶矩矩阵表示如下： <span class="math display">\[
M(x,y,\sigma_1,\sigma_D) = \sigma^2_D g(\sigma_1)
\left[
\begin{matrix}
I^2_{x}(x,y,\sigma_D) &amp; I_{x}I_y(x,y,\sigma_D) \\
I_{x}I_y(x,y,\sigma_D) &amp; I^2_{y}(x,y,\sigma_D)
\end{matrix}
\right]
\]</span> 其中 <span class="math inline">\(I_x,I_y\)</span> 为使用尺度为 <span class="math inline">\(\sigma_D\)</span> 的高斯核在分别在它们方向上做的图像微分。参数 <span class="math inline">\(\sigma_1\)</span> 决定了当前尺度，Harris 角点在这个尺度下的高斯尺度空间内检测。换句话说，微分尺度 <span class="math inline">\(\sigma_D\)</span> 决定了用于计算微分的高斯核大小。然而，积分尺度 <span class="math inline">\(\sigma_1\)</span> 用于控制某一相邻区域内的微分加权平均。多尺度 Harris 角点度量是使用上式矩阵的行列式和迹计算的，如下式： <span class="math display">\[
C(x,y,\sigma_1,\sigma_D) = \text{det} [M(x,y,\sigma_1,\sigma_D)]-\alpha \cdot \text{trace}^2[M(x,y,\sigma_1,\sigma_D)]
\]</span> 常量 <span class="math inline">\(\alpha\)</span> 的值在 0.04 和 0.06 之间。在每一层尺度空间表示中，通过检测点 <span class="math inline">\((x,y)\)</span> 8 邻域的局部最大值来提取兴趣点。然后，使用阈值来过滤那些极值比较小的角点，因为它们在任一观测条件下都不稳定 <span class="math display">\[
C(x,y.\sigma_1,\sigma_D) &gt; Threshold_{Harris}
\]</span> 另外，LoG 也可以用于寻找所有尺度上的极大值。其中，只有那些达到拉普拉斯最大值或者其响应大于阈值的点才可以接受<a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a>。 <span class="math display">\[
\sigma_1^2\vert L_{xx}(x,y,\sigma_1) + L_{yy}(x,y,\sigma_1) \vert &gt; Threshold_{Laplacian}
\]</span> Harris-Laplace 提供了一组具有代表性的点，这些点在图像以及尺度维度都是具有特征的。与多尺度 Harris 相比，Harris-Laplace 减少了很多不必要的兴趣点。这些兴趣点在尺度，旋转，光照以及附加噪声具有不变性。 此外，兴趣点是高可重用的。然而，Harris-Laplace 检测器与 LoG 和 DoG 检测器相比，返回更少的点。它也不适用于仿射变换。</p>
<h4 id="hessian-laplace">3.2.4 Hessian-Laplace</h4>
<p>和 Harris-Laplace 相似，基于 Hessian 矩阵的检测器也可以用相同的方法构造一个具有尺度不变性的检测器，名为 Hessian-Laplace。首先，我们使用 Laplacian 或者它的近似表示 DoG 来构造尺度空间。然后使用 Hessian 矩阵的行列式提取尺度不变类斑点特征。Hessian-Laplace 检测器获取的大量特征覆盖了整幅图像，和 Harris-Laplace 相比可重用性略低。此外，由于空间和尺度定位中使用的滤波器的相似性，提取的位置更适合于基于二阶高斯微分的尺度估计。Bay et al. 【32】宣称基于 Hessian 的检测器比基于 Harris 的更稳定。类似得，使用 DoG 代替 LoG 来加速计算，Hessian 行列式使用积分图像技术来近似【29】以达到 Fast Hessian 检测器【32】。</p>
<h4 id="gabor-wavelet-检测器">3.2.5 Gabor-Wavelet 检测器</h4>
<p>最近，Yussof 和 Hitam【47】提出一种基于 Gabor 小波<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a>的多尺度兴趣点检测器。Gabor 小波是受高斯包络函数限制的平面波形状的生物激励卷积核，其核类似于哺乳动物简单皮层细胞的二维感受场谱的响应。Gabor 小波使用经过高斯包络函数调制的复平面波。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201125112807047.png" alt="image-20201125112807047" style="zoom:39%;" /></p>
<p>其中 <span class="math inline">\(K_{u,v} = K_ve^{i\Phi u},z=(x,y)\)</span>，u 和 v 决定了Gabor 小波的方向和尺度，<span class="math inline">\(K_v = K_{max}/f^v\)</span> 并且 <span class="math inline">\(\Phi_u = \pi u/8\)</span>，<span class="math inline">\(K_{max}\)</span> 是最大频率，<span class="math inline">\(f = \sqrt{2}\)</span> 为频率域内核间距因子。通过下面的卷积计算图像 <span class="math inline">\(I\)</span> 与 <span class="math inline">\(\psi\)</span> 之间的响应 <span class="math display">\[
G = I \bigotimes \psi
\]</span> 这个卷积的系数表示局部图像区域的信息，这应该比独立的像素更有效。Gabor 小波的优势是可以同时在空间和空间频率域上提供最佳分辨率。另外，Gabor 小波可以增强低层次的特征，例如峰，谷，脊。因此，通过组合图像多方向的响应，它可以从不同尺度的图像中提取特征点。兴趣点在多个尺度上提取，并结合均匀间隔的方向。作者证明了 Gabor 小波检测器提取的特征点对不同几何变换都具有高准确度以及高适应性。</p>
<h3 id="仿射不变检测器">3.3 仿射不变检测器</h3>
<p>到现在为止讨论的特征检测器展示了平移、旋转和均匀尺度的不变性，并认为局部图像结构的位置和尺度不受仿射变换的影响。因此，它们可以处理一部分富含挑战性的反射不变性问题，同时记住尺度在每个方向上是可以不同的。这反过来使得尺度不变检测器不能处理显著的仿射变换。因此，建立一个对透视变换具有鲁棒性的检测器需要仿射变换不变性。一个仿射不变检测器可以视作是尺度不变检测器的一般版本。最近，一些特征检测器拓展为可以处理仿射变换不变特征。举个例子，Schaffalitzky 和 Zisserman 【48】通过仿射归一化拓展 Harris-Laplace 检测器。Mikolajczyk 和 Schmid 【45】介绍了一种尺度以及仿射不变兴趣点检测方法。他们的算法同时适应了点邻域的位置，尺度，形状来获取仿射不变点。其中，Harris 检测器使用适用于仿射变换并基于二阶矩矩阵估计点邻域的形状。这是通过如下由 Lindberg 和 Garding【49】得出的迭代估计方案：</p>
<ol type="1">
<li>使用尺度不变 Harris-Laplace 检测器明确初始区域点。</li>
<li>对每一个初始点，使用仿射形状自适应将区域归一化以满足仿射不变。</li>
<li>迭代估计仿射区域，选择合适的积分尺度，微分尺度和空间定位兴趣点。</li>
<li>使用这些尺度以及空间定位来更新仿射区域。</li>
<li>重复第三步直到满足停止条件。</li>
</ol>
<p>类似于 Harris-affine，同样的想法可以用于基于 Hessian 的检测器，以实现名为 Hessian-affine 的仿射不变检测器。对于单幅图像。Hessian-affine 通常比 Harris-affine 得到更多可靠的区域。性能的改变依赖于分析的场景类型。再者，Hessian-affine 对纹理场景有很好的响应，纹理场景中有很多类似角的部分。然而，对一些类似建筑的结构化场景，Hessian-affine 处理得很好。Mikolajczyk 和 Schmid 对几种最先进的仿射检测器进行了深入的分析【50】。</p>
<p>由于篇幅限制，还有几种没有被讨论过的特征检测器，例如，Fast Hessian 或 the Determinant of Hessian (DoH) 【32】 ，MSER【51，52】。关于这些检测器更详细的讨论见【44，45，53】。</p>
<h2 id="图像特征描述">4 图像特征描述</h2>
<p>一旦在位置 <span class="math inline">\(p(x,y)\)</span>，尺度 <span class="math inline">\(s\)</span>，以及角度 <span class="math inline">\(\theta\)</span> 检测到一组兴趣点，它们在 <span class="math inline">\(p\)</span> 邻域的内容或者图像结构就需要编码为合适的描述符以达到有识别度的匹配并对局部图像变形不敏感。这种描述符需要和 <span class="math inline">\(\theta\)</span> 对齐并和尺度 <span class="math inline">\(s\)</span> 成比例。文献中有大量的图像特征描述符，最常用的是在接下来的章节中要讨论的几种。</p>
<h3 id="尺度不变特征变换sift">4.1 尺度不变特征变换（SIFT）</h3>
<p>lowe【31】提出了尺度不变特征变换算法（scale-invariant feature transform ，SIFT），其使用 DoG 操作在图像中检测到大量的兴趣点。这些点通过 DoG 函数的局部极值选择。在每一个兴趣点可以提取一个特征向量。在多个尺度上，在兴趣点周围的邻域上，利用局部图像属性来估计图像的局部方向，以提供相对于旋转的不变性。接下来，为每一个检测到的点基于特定特征尺度的局部图像信息计算一个描述符。通过建立兴趣点周围区域的梯度方向直方图，SIFT 描述符寻找最高的方向值并且其它大于最值 80% 的值，并使用这些方向作为这个关键点的主方向。</p>
<p>SIFT 算法的描述阶段从采样关键点周围 <span class="math inline">\(16\times 16\)</span> 区域的梯度值与方向开始，使用它的尺度作为高斯模糊的等级。然后，将原区域划分为 <span class="math inline">\(4\times 4\)</span> 的子区域，并为每个子区域创建一组包含 8 个方向的方向直方图。<span class="math inline">\(\sigma\)</span> 大小为区域一半的高斯加权函数为每一个采样点赋予一个权值，位于区域中心的梯度有较高的权值，这些梯度受位置变化的影响较小。描述符由所有方向直方图组成的向量构成。因为有 <span class="math inline">\(4\times 4\)</span> 个直方图，每一个都包含 8 个 bin，所以每个关键点的特征向量有 <span class="math inline">\(4\times 4\times 8 = 128\)</span> 个元素。最后，特征向量归一化为单位长度以获取光照仿射变化的不变性。然而，相机饱和度或其它类似的影响造成非的线性光照改变会使得某些梯度发生大的改变。这些改变可以通过将特征向量最大值 0.2 以上的值阈值化<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a>处理减少，并再次归一化。<strong><em>Fig.8</em></strong> 为 SIFT 算法的图形表示，其中梯度方向和大小在每一个像素处计算并使用高斯分布加权（如图中的覆盖圆）。然后为每一个子区域计算加权的梯度方向直方图。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201126082806529.png" alt="image-20201126082806529" style="zoom:70%;" /></p>
<p>标准 SIFT 描述符表示在几个方面是值得注意的：<u>这种表示是精心设计的，以避免由于边界效应和位置的平滑变化而产生的问题，方向和尺度不会引起特征向量的根本变化；它十分紧凑，使用 128 元素的向量表示像素块；但对仿射变换不是显著不变的，这种表示对由透视效果引起的变形具有惊人的弹性</u>。这些特征在不同尺度，选择和光照下与其它竞争算法的匹配性能中得到了证明。在另一个方面，标准 SIFT 特征向量的组成是复杂的并且 SIFT 具体设计背后的选择不明确导致 SIFT 公共的高维问题，这影响了计算描述符所需的时间（十分慢）。作为 SIFT 的拓展，Ke 和 Sukthankar【54】提出了 PCA-SIFT 来减少原始 SIFT 描述符的高维性。<strong>PCA-SIFT</strong> 使用主成分分析（Principal Components Analysis，PCA）技术对关键点周围的梯度图像块归一化。它在给定的尺度下提取 <span class="math inline">\(41\times 41\)</span> 的块并计算竖直和水平两个方向的图像梯度，然后将两个方向的梯度连接以创建特征向量。因此，它的特征向量长度为 <span class="math inline">\(2\times 39 \times 39 = 3042\)</span>。梯度图像向量投影到事先计算的特征空间中，最后得到 36 维的特征向量。然后将向量归一化为单位大小以减少光照改变的影响。此外，Morel 和 Yu【55】证明了 SIFT 对除了六参数的仿射变换外的四参数的缩放，选择和平移是完全不变的。因此，它们介绍了 <strong>affine-SIFT（ASIFT）</strong>通过不同的相机轴方向参数，也就是 SIFT 遗留下来的经纬度角，模拟可获得的所有图像视图。</p>
<h3 id="梯度位置方向直方图gloh">4.2 梯度位置方向直方图（GLOH）</h3>
<p>梯度位置方向直方图（Gradient location-orientation histogram，GLOH）由 Mikolajczyk 和 Schmid 【50】提出，也是 SIFT 描述符的拓展。GLOH 与 SIFT 描述符非常相似，它只将 SIFT 使用的笛卡尔位置网格替换为对数-极坐标网格，并应用 PCA 来减小描述符的大小。GLOH 使用对数-极坐标位置网格将径向分为三个（半径设置为 6，11，15），角度方向分为 8 个，如 <strong><em>Fig.9</em></strong> 所示最后有 17 个子块。GLOH 描述符将梯度方向分为 16 个条目并以此建立了一组直方图，所以每个兴趣点的特征向量有 <span class="math inline">\(17\times 16 = 272\)</span> 个元素。通过计算 PCA 协方差矩阵将这个 272 维描述符降为 128 维，并选择最高的 128 维特征用于描述。基于在【50】中的实验评估，<u>GLOH 优于原始 SIFT 描述符，并给出了最佳的性能，尤其是在光照改变的情况下。此外，和 SIFT 描述符相比，GLOH 获取的特征更具有区分度，但也需要更昂贵的计算开销</u>。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201126112550328.png" alt="image-20201126112550328" style="zoom:67%;" /></p>
<h3 id="加速鲁棒特征描述符surf">4.3 加速鲁棒特征描述符（SURF）</h3>
<p>加速鲁棒特征（Speeded-Up Robust Features，SURF）检测-描述符由 Bay 等人发展【32】以作为 SIFT 的有效替代。与SIFT 相比它更加快且更具鲁棒性。对于兴趣点检测阶段，并不依赖理想高斯微分，而是基于简单的 2D 核滤波器。其中，它使用基于 Hessian 矩阵行列式的尺度不变斑点检测器来进行尺度选择和定位。<u>它基础的思想为用一个高效的方式来近似高斯二阶微分，通过一组盒滤波器创建的积分图像</u>。<strong><em>Fig.10</em></strong> 描绘了这个 <span class="math inline">\(9\times 9\)</span> 的盒滤波器，它是 <span class="math inline">\(\sigma = 1.2\)</span> 的高斯函数的近似，并且代表了斑点响应映射的最低尺度。这些近似表示为 <span class="math inline">\(D_{xx},D_{yy},D_{xy}\)</span>。因此，Hessian 行列式的近似表示为： <span class="math display">\[
\text{det}(H_{approx}) = D_{xx}D_{yy} - (wD_{xy})^2
\]</span> 其中 <span class="math inline">\(w\)</span> 是滤波器响应的相对权重，用于平衡 Hessian 行列式表达式。近似的 Hessian 行列式表示了图像中的斑点响应大小。这些响应存储在斑点响应映射图中，使用二次插值寻找并细化局部最大值，如 DoG。最后，在 <span class="math inline">\(3\times 3\times 3\)</span> 的邻域内做非极大值抑制来获取稳定的兴趣点和尺度值。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201127130822757.png" alt="image-20201127130822757" style="zoom:67%;" /></p>
<p>SURF 描述符首先以检测到的兴趣点为中心建立一个方形区域，并确定其主方向。这个窗口的大小为 <span class="math inline">\(20s\)</span>，其中 s 为其兴趣点对应的尺度。然后，这个兴趣区域进一步分为 <span class="math inline">\(4\times 4\)</span> 个更小的子区域并为每一个子区域在如图 <strong><em>Fig.11</em></strong> <span class="math inline">\(5\times 5\)</span> 大小的采样点上计算竖直和水平（分别表示为 <span class="math inline">\(d_x,d_y\)</span> ）两个方向上的 Harr 小波响应。这些响应使用以兴趣点为中心的高斯窗口加权以增加对几何畸变和位置错误的鲁棒性。对每一个子区域小波响应 <span class="math inline">\(d_x,d_y\)</span> 求和并添加到特征向量 <span class="math inline">\(v\)</span> ，其中 <span class="math display">\[
v = (\sum d_x,\sum \vert d_x\vert,\sum d_y,\sum \vert d_y \vert)
\]</span> 为所有 <span class="math inline">\(4\times 4\)</span> 的子区域计算这个，就得到一个 <span class="math inline">\(4\times 4\times 4 = 64\)</span> 维的特征描述符。最后，对这个特征描述符归一化以减少光照影响。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201127131158056.png" alt="image-20201127131158056" style="zoom:60%;" /></p>
<p>和 SIFT 相比 SURF 描述符主要的优势在于处理速度，因为它使用 64 维特征向量来描述局部特征，而 SIFT 使用的是 128 维。然而，<u>SIFT 描述符更适于描述受平移，选择，缩放和其它光照变化影响的图像</u>。尽管 SURF 展示了它在很多计算机视觉应用上的潜力，但它也有许多缺陷。<u>在比较 2D 和 3D 目标时，当旋转幅度大或视角差距大时它将失效。此外，如【56】解释的那样，SURF 并不是完全仿射不变的</u>。</p>
<h3 id="local-binary-pattern-lbp">4.4 Local Binary Pattern (LBP)</h3>
<p>LBP 【57，58】表征了纹理的空间结构并展示了灰度单一变换的不变性特点。它通过将相邻像素和中心像素比较以编码排序关系，也就是说通过将每一个像素值和其相邻像素比较以创建一个基于顺序的特征。特别地，将那些比中心像素具有更大特征响应的相邻像素标记为 “1”，否则标记为 “0”。这些同时进行的比较的结果由一个二进制串记录。然后，从公共比率为 2 的几何序列得到的权重，根据串的索引分配给每一个比特。因此，带有权值的二进制串就可以转换为一个十进制值索引（即，LBP 特征响应）。也就是说，这个描述符将邻域上的结果描述了为一个二进制数（二元模式）。其标准模式下，强度为 <span class="math inline">\(g(c)\)</span> 的像素 <span class="math inline">\(c\)</span> 的标记按下式确定 <span class="math display">\[
S(g_p - g_c) = 
\left \{
\begin{align}
1,&amp; &amp;\text{if　} g_p \ge g_c \\
0,&amp; &amp;\text{if　} g_p &lt; g_c
\end{align}
\right.
\]</span> 其中像素 <span class="math inline">\(p\)</span> 属于 <span class="math inline">\(3\times 3\)</span> 大小的邻域，灰度为 <span class="math inline">\(g_p(p=0,1,\dots,7)\)</span> 。然后，像素邻域的 LBP 通过对阈值 <span class="math inline">\(S(g_p-g_c)\)</span> 按 <span class="math inline">\(2^k\)</span> 加权相加获得，如下： <span class="math display">\[
LBP = \sum_{k=0}^7 S(g_p-g_c).2^k
\]</span> 在为每一个像素计算其标记之后，就可以生成一个 256 bin 的直方图，作为这个纹理的特征描述符。<strong><em>Fig.12</em></strong> 展示了在 <span class="math inline">\(3\times 3\)</span> 邻域内计算 LBP 以及基础区域的方向描述符的例子。此外，LBP 描述符的一般形式为：</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201128003446585.png" alt="image-20201128003446585" style="zoom:55%;" /></p>
<p>其中 <span class="math inline">\(n_c\)</span> 对应着局部邻域中心像素的灰度级，<span class="math inline">\(n_i\)</span> 是半径为 R 的圆上的 N 等分像素的灰度级。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201128003803784.png" alt="image-20201128003803784" style="zoom:60%;" /></p>
<p>因为像素之间的关系随距离增加而减少，所以许多的纹理信息可以从局部邻域中获得。因此，半径 R 一般都比较小。在实际应用中，邻域间的差分符号被解释为 N 位二进制数，使得有如 <strong><em>Fig.13</em></strong> 所示的 <span class="math inline">\(2^N\)</span> 个不同的二元模式。二元模式被称为均匀模式，其中每位最多包含两个从 “0” 到 “1” 的转换。例如，“11000011” 和 “00001110” 是两个二元模式，但 “00100100” 和 “01001110” 就不是二元模式。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201129111111162.png" alt="image-20201129111111162" style="zoom:60%;" /></p>
<p>已经提出了几种不同的 LBP，包括中心对称 LBP（the center-symmetric local binary patterns，CS-LBP），局部三元模式（the local ternary pattern，LTP），基于 CS-LBP 的中心对称 LTP（CS-LTP），以及正交对称 LTP（orthogonal symmetric local ternary pattern，OS-LTP）【60】。不像 LBP，CS-LBP 描述符比较中心对称对之间的灰度差分（见 Fig.13）。实际上，LBP 有容忍光照改变和计算简单的优势。不幸的是，LBP 特征是离散模式的索引而不是数值特征，因此它很难与其它区分度高的特征结合在一个紧凑的描述符中【61】。此外，它产生更高维的特征并对平坦区域的高斯噪声敏感。</p>
<h3 id="binary-robust-independent-elementary-features-brief">4.5 Binary Robust Independent Elementary Features (BRIEF)</h3>
<p>BRIEF 是一个低比特率描述符，用于随机森林和随机蕨类分类器的图像匹配【62】。它属于 LBP 和 BRISK 那样的二元描述族，它仅执行简单的二元比较测试和使用汉明距离<a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a>而不是欧几里得距离或者马氏距离。简单来说，为了建立二元描述符，有必要的仅仅是比较被检测兴趣点周围的两个像素的强度。这使得以一个非常小的计算开销便可以获得具有代表形的描述符。此外，二元描述符匹配仅需要计算汉明距离，而汉明距离通过现代架构的 XOR 原语实现快速计算。</p>
<p>BRIEF 算法依赖于相对小的图像强度差分测试来将图像块表示为二进制串。更特别的是，对大小为 <span class="math inline">\(S \times S\)</span> 的图像块的二元描述符通过连接以下测试结果获得： <span class="math display">\[
\tau = 
\left\{
\begin{align}
1,&amp; &amp;\text{if　} I(P_j) &gt; I(P_i) \\
0,&amp; &amp;\text{otherwise}
\end{align}
\right.
\]</span> 其中 <span class="math inline">\(I(p_i)\)</span> 表示为 <span class="math inline">\(p_i\)</span> 处的（平滑）像素强度，并且所有 <span class="math inline">\(p_i\)</span> 位置的选择唯一定义了一组二进制测试。采样点来自于均值为 0 ，方差为 <span class="math inline">\(\frac{1}{25} S^2\)</span> 的各向同性的高斯分布。为了增加这个描述子的鲁棒性，图像块使用方差为 2，大小为 <span class="math inline">\(9\times 9\)</span> 的高斯核进行预平滑。BRIEF 描述符需要设置两个参数：二元像素对数量和二进制阈值。</p>
<p>作者的实验显示了仅仅 256 位，甚至 128 位便足以获取十分好的匹配结果。因此，BRIEF 在计算以及内存存储方面都是高效的。不幸的是 BRIEF 描述符对大于 35° 的旋转不具鲁棒性，因此，它并不提供旋转不变性。</p>
<h3 id="其它特征描述符">4.6 其它特征描述符</h3>
<p>大量的描述符在文献中提出，并且之中的许多已经被证明在计算机视觉应用中是有效的。举个例子，基于颜色的局部特征是由 Weijer 和 Schmidt 【63】提出的基于颜色信息的四个颜色描述符。Gabor 表示或者其变化【64，65】在某种意义上是最优的，在最小化空间和频率的二维联合不确定性上。Zernike 矩【66，67】和 Steerable 滤波器【68】也用于特征提取和描述。</p>
<p>受到 Weber’s Law 的启发，根据局部强度变化和中心像素强度值为每个像素计算一个密集的描述符，这个方法为在【28】中提出的 Weber Local Descriptor（WLD）。WLD 描述符采用了 SIFT 使用梯度和其方向直方图的优势，以及 LBP 的计算效率和较小支持区域的优势。和 LBP 描述符相比，WLD 首先计算显著微模式（即，差分激励），然后在这些显著模式以及当前点的梯度方向上建立统计数据。</p>
<p>两种基于测量图像可视实体相似度从兴趣区域提取特征的方法在【69】中提出。这些方法的思路为将两个著名的方法结合起来，即 SIFT 描述符和 Local Self-Similarities（LSS）。基于笛卡尔位置网格提取了两个名为 Local Self-Similarities（LSS，C）和 Fast Local Self-Similarities（FLSS，C）的特征，这两个特征是基于对数-极坐标位置网格（LSS，LP）的 Local Self-Similarities 的改进版本。LSS 和 FLSS 作为局部特征应用于 SIFT 算法。LSS和FLSS描述符在每个单元中使用基于分布的直方图表示而不是而不是在自然（LSS，LP）描述符中的对数-极坐标位置网格中选择每个桶中的最大相关值。因此，它们得到更具鲁棒性的几何变换不变性和好的光度变换不变性。一个基于二阶梯度直方图的局部图像描述符在【70】中提出，名为 HSOG，用于捕捉神经邻域的曲率相关几何特性。Dalal 和 Triggs【71】展示了梯度方向直方图（HOG）描述符，结合了 SIFT 的性质以及 GLOH 描述符。HOG 和 SIFT 的主要差别为 HOG描述符是在具有重叠局部对比归一化的均匀间隔单元的密集网格上计算的。</p>
<p>Fan 等人在另一个方向提出了一种兴趣区域描述方法，这种方法在多个可使用区域中基于强度顺序汇聚局部特征。通过强度顺序汇聚不仅对选择和单调强度改变不变，而且将序数信息编码为描述符。通过汇聚两种不同的局部特征，可以得到一种基于梯度，一种基于强度的描述符，即 Multisupport Region Order-Based Gradient Histogram (MROGH) 和 the Multisupport Region Rotation and Intensity Monotonic Invariant Descriptor (MRRID)。前一种结合了强度顺序信息和梯度，然而后一种完全基于强度顺序，这使得它对大的光照改变部分不变。</p>
<p>尽管最近提出了大量的图像特征描述符，其中的几个是专门为某些场景应用设计的，如目标识别，形状检索或者 LADAR 数据处理【73】。此外，这些描述符的作者在为某些特别任务收集的有限数量基准数据集上评估描述符性能。因此，为特别的应用邻域选择一个合适的描述符是困难的。在这方面，最近一些研究对几种描述符做了比较：兴趣区域描述符【50】，二进制描述符【74】，局部颜色描述符【75】，和 3D 描述符【76，77】。事实上，声称描述图像特征是一个已经被解决的问题是过于大胆和乐观的。另一方面，鉴于上述描述符在几种应用程序中的成功，声称为一般现实情况设计描述符几乎是不可能的说法太过悲观了。最后，为了将描述符算法设计为可以通用还有大量的工作要做。我们主张进一步研究如何使用由三维数据和颜色信息捕获的新模式。对于实时应用，未来研究的进一步是在如 GPU 的并行处理单元上实现算法。</p>
<h2 id="特征匹配">5 特征匹配</h2>
<p>特征匹配或者一般而言的图像匹配，作为很多计算机视觉应用的一部分，如图像配准，相机标定和目标识别，建立同一场景/目标的两幅图像之间的对应关系。一种常见的图像匹配方法包括从图像数据中检测一组与图像描述符相联系的兴趣点。一旦特征和它的描述符从两幅或多幅图像中提取出来，下一步便是如 <strong><em>Fig.14</em></strong> 那样在这些图像之间建立基础的特征匹配。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202112550367.png" alt="image-20201202112550367" style="zoom:67%;" /></p>
<p>为了不失一般性，图像匹配的问题可以表述如下，假设 <span class="math inline">\(p\)</span> 是由检测器检测到的点与一个描述符相联系<a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a></p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202000243428.png" alt="image-20201202000243428" style="zoom:60%;" /></p>
<p>其中，对于所有的 <span class="math inline">\(K\)</span>，第 <span class="math inline">\(k\)</span> 个描述符的特征向量为：</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202000306500.png" alt="image-20201202000306500" style="zoom:60%;" /></p>
<p>兴趣点 <span class="math inline">\((p,q)\)</span> 匹配仅当 <span class="math inline">\((\text{i})\)</span> <span class="math inline">\(p\)</span> 为 <span class="math inline">\(q\)</span> 与第一幅图像中所有点的最佳匹配并且反过来 <span class="math inline">\((\text{ii})\)</span> <span class="math inline">\(q\)</span> 是 <span class="math inline">\(p\)</span> 与第二幅图像所有点的最佳匹配。在这个条件下，设计一个高效算法来尽可能快的执行匹配是非常重要的。欧氏范数中图像描述符特征空间中的最近邻匹配可用于基于向量的特征匹配。然而，实际上最优最近邻匹配算法及其参数依赖于数据集的特征。此外，为了抑制那些被认为模棱两可的一致关系的候选匹配，图像描述符之间的最近距离和次近距离之间的比值需要小于一个阈值。特别的是，在高维特征匹配中，这两个算法是最高效的：随机 K-d 森林和 the fast library for approximate nearest neighbors (FLANN)【78】。</p>
<p>在另一方面，这些算法并不适用与二进制特征（例如，FREAK 或者 BRISK）。二进制特征匹配使用的是汉明距离，通过 按位 XOR 操作计算，并对结果进行位计数。这里涉及到的操作都可以很快的执行。匹配大型数据库的经典方案为使用比线性搜索快几个数量级的近似匹配来提到原先的线性搜索。也就是说，以返回最近邻的近似点作为代价，但是经常与真实的最近邻点十分相近。为了执行二进制特征匹配，需要使用其它的方法如【80-82】。</p>
<p>一般地，基于兴趣点的匹配方法的性能依赖于潜在兴趣点的性质以及与之相联系的图像描述符【83】。因此，适合图像内容的检测器和描述符应该被用于应用中。举个例子，如果一副包含细菌细胞的图像，那么就需要斑点检测器而不是角点检测器，但对于城市的鸟瞰图，角点检测器更适于人造结构。此外，选择一个可以解决图像退化问题的检测器和描述符是十分重要的。例如，如果没有尺度改变，则不处理尺度变换的检测器更受推崇；反之，如果一副包含很大变形，例如尺度和旋转，那么具有更高计算力的 SURF 特征检测器和描述符更适用于这个情况。至于更高的准确度，建议同时使用几种检测器和描述符。在特征匹配邻域，必须注意到二进制描述符（例如，FREAK 或 BRISK）一般具有更快的速度且一般用于寻找图像间点的一致性关系，但是它们和基于向量的描述符相比准确度更低【74】。数据分析显示，类似 RANSAC 的鲁棒性方法可以用于在估计几何变换或者基础矩阵时，筛选匹配特征中的外点，这对图像配置和目标识别应用中的特征匹配十分有用。</p>
<h2 id="性能评估">6 性能评估</h2>
<h3 id="基准数据集">6.1 基准数据集</h3>
<p>在互联网上有多种多样的数据集可以作为研究者的基准。一个流行并广泛用于检测器和描述符性能评估的为标准 Oxford 数据集【84】。这个数据集包含了不同几何和光度变换（视角改变，尺度改变，图像旋转，图像模糊，光照变换以及 JPEG 压缩）以及不同场景类型的（结构和纹理场景）数据集。在光照改变的情况下，通过改变相机孔径来改变光照。然而对于旋转，尺度改变，视角改变和模糊，有两种不同的场景类型。一种为结构场景，包含独特边缘边界的同类区域（例如涂鸦，建筑）。另一种则包含不同形式的重复纹理。因此，图像变换和场景类型造成的影响可以单独分析。每一个数据集包含 6 个几何和光度变形图像，其中第一张图像和其余 5 张相比是渐变的。<strong><em>Fig.15</em></strong> 为从 Oxford 数据集中抽取的几张图像。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202224948702.png" alt="image-20201202224948702" style="zoom:67%;" /></p>
<h3 id="评估标准">6.2 评估标准</h3>
<p>为了判断两张图像特征是否匹配（即，属于是否属于同一特征），Mikolajczyk 等人【44】提出基于重复率标准的评估方法，通过比较检测到的区域和真实区域之间的重叠大小。重复率可以被认为是最重要的评估标准，在评估特征检测器的稳定性上。它测量探测器在图像中提取相同特征点的能力，而不考虑成像条件。重复率标准表示了检测器某个检测器对于某一场景是否足够好。在这个评估方法中，两个兴趣区域 A 和 B 是一致的，当重叠错误率 <span class="math inline">\(\epsilon\)</span> 足够小时，如 <strong>Fig.16</strong> 所示。这个重复错误率表示了在一个单应性变换 H 下两个区域一致性的好坏。它由两个区域的交集和并集的比率定义：</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202230218642.png" alt="image-20201202230218642" style="zoom:67%;" /></p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202225919982.png" alt="image-20201202225919982" style="zoom:67%;" /></p>
<p>这个方法计算了两个区域的并集和交集的全部像素数量。此外，一个匹配是正确的，当图像上两个对应区域的错误率小于 区域并的 50%，也就是 <span class="math inline">\(\epsilon &lt; 0.5\)</span> 。重叠错误率的计算是基于 H 的，这个单应性变换矩阵是由区域定义的。因此，为了评估特征检测器的性能，对给定一对图像的重复率分数计算为区域与区域的对应数量和这对图像中较少的区域数量的比值。</p>
<p>另一方面，区域描述符的性能由匹配标准度量，即，描述符表示一个场景区域的好坏。这是基于由图像对得到的正确和错误匹配的数量决定的。这通过比较真实的对应区域数量和正确匹配的区域数量计算。匹配为描述符空间中最邻近的【50】。在这个情况下，两个兴趣区域成匹配对，如果它们描述符 <span class="math inline">\(D_A,D_B\)</span> 之间的欧几里得距离小于一个阈值 <span class="math inline">\(\tau\)</span> 。最后的结果使用召回率（recall）和 1-准确度（1-precision） 表示。每一个参考图像的描述符与变换之后的描述符相比较并计算正确和错误匹配的数量。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202232054828.png" alt="image-20201202232054828" style="zoom:60%;" /></p>
<p>其中，No.correspondences 为两幅图像的匹配区域的数量。然而，召回率是同一场景的两幅图像之间正确匹配的区域数量对于一致区域数量。一个理想描述符的对任意准确率其召回率为 1。为了获取其曲线，需要改变阈值 <span class="math inline">\(\tau\)</span>。特别地，召回率随着阈值的增长而增长，因为图像变换引入的噪声和区域检测器中相似描述符间距离的增加。一个慢增长曲线表明描述符会受到图像噪声的影响。如果不同描述符的曲线的斜率差异很大，然后，对于所研究的图像变换或场景类型，这些描述符的显著性和鲁棒性是不同的【50】。</p>
<h2 id="总结">7 总结</h2>
<p>这篇文章的目标是为新研究者在图像特征检测和提取研究领域提供一简洁明了的，简短的介绍。介绍了检测和提取图像特征的基本符号和数学概念，描述了完美特征检测器的特性。之前介绍了各种现存的检测兴趣点的算法。也讨论了使用最频繁的描述算法 SIFT，SURF，LBP，WLD，……并且它们的优缺点也着重强调了。此外，它解释了一些特征匹配方法。最后，文章还介绍了它们算法中用于评估性能的技术。</p>
<hr />
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li>Yap, T., Jiang, X., Kot, A.C.: Two-dimensional polar harmonic transforms for invariant image representation. IEEE Trans. Pattern Anal. Mach. Intell. 32(7), 1259–1270 (2010)</li>
<li>Liu, S., Bai, X.: Discriminative features for image classification and retrieval. Pattern Recogn. Lett. 33(6), 744–751 (2012)</li>
<li>Rahmani, R., Goldman, S., Zhang, H., Cholleti, S., Fritts, J.: Localized content-based image retrieval. IEEE Trans. Pattern Anal. Mach. Intell. 30(11), 1902–1912 (2008)</li>
<li>Stöttinger, J., Hanbury, A., Sebe, N., Gevers, T.: Sparse color interest points for image retrieval and object categorization. IEEE Trans. Image Process. 21(5), 2681–2691 (2012)</li>
<li>Wang, J., Li, Y., Zhang, Y., Wang, C., Xie, H., Chen, G., Gao, X.: Bag-of-features based medical image retrieval via multiple assignment and visual words weighting. IEEE Trans. Med. Imaging 30(11), 1996–2011 (2011)</li>
<li>Andreopoulos, A., Tsotsos, J.: 50 years of object recognition: directions forward. Comput. Vis. Image Underst. 117(8), 827–891 (2013)</li>
<li>Dollár, P., Wojek, C., Schiele, B., Perona, P.: Pedestrian detection: an evaluation of the state of the art. IEEE Trans. Pattern Anal. Mach. Intell. 34(4), 743–761 (2012)</li>
<li>Felsberg, M., Larsson, F., Wiklund, J., Wadströmer, N., Ahlberg, J.: Online learning of correspondences between images. IEEE Trans. Pattern Anal. Mach. Intell. 35(1), 118–129 (2013)</li>
<li>Miksik, O., Mikolajczyk, K.: Evaluation of local detectors and descriptors for fast feature matching. In: International Conference on Pattern Recognition (ICPR 2012), pp. 2681–2684. Tsukuba, Japan, 11–15 Nov 2012</li>
<li>Kim, B., Yoo, H., Sohn, K.: Exact order based feature descriptor for illumination robust image matching. Pattern Recogn. 46(12), 3268–3278 (2013)</li>
<li>Moreels, P., Perona, P.: Evaluation of features detectors and descriptors based on 3D objects. Int. J. Comput. Vis. 73(3), 263–284 (2007)</li>
<li>Takacs, G., Chandrasekhar, V., Tsai, S., Chen, D., Grzeszczuk, R., Girod, B.: Rotation-invariant fast features for large-scale recognition and real-time tracking. Sign. Process. Image Commun. 28(4), 334–344 (2013)</li>
<li>Tang, S., Andriluka, M., Schiele, B.: Detection and tracking of occluded people. Int. J. Comput. Vis. 110(1), 58–69 (2014)</li>
<li>Rincón, J.M., Makris, D., Uru ˇnuela, C., Nebel, J.C.: Tracking human position and lower body parts using Kalman and particle filters constrained by human biomechanics. IEEE Trans. Syst. Man Cybern. Part B 41(1), 26–37 (2011)</li>
<li><p>Lazebnik, S., Schmid, C., Ponce, J.: A sparse texture representation using local affine regions. IEEE Trans. Pattern Anal. Mach. Intell. 27(8), 1265–1278 (2005)</p></li>
<li>Liu, L., Fieguth, P.: Texture classification from random features. IEEE Trans. Pattern Anal. Mach. Intell. 34(3), 574–586 (2012)</li>
<li>Murillo, A., Guerrero, J., Sagues, C.: SURF features for efficient robot localization with omnidirectional images. In: International Conference on Robotics and Automation, pp. 3901–3907. Rome, Italy, 10–14 Apr, 2007</li>
<li>Valgren, C., Lilienthal, A.J.: SIFT, SURF &amp; seasons: appearance-based long-term localization in outdoor environments. Rob. Auton. Syst. 58(2), 149–156 (2010)</li>
<li>Campos, F.M., Correia, L., Calado, J.M.F.: Robot visual localization through local feature fusion: an evaluation of multiple classifiers combination approaches. J. Intell. Rob. Syst. 77(2), 377–390 (2015)</li>
<li>Farajzadeh, N., Faez, K., Pan, G.: Study on the performance of moments as invariant descriptors for practical face recognition systems. IET Comput. Vis. 4(4), 272–285 (2010)</li>
<li>Mian, A., Bennamoun, M., Owens, R.: Keypoint detection and local feature matching for textured 3D face recognition. Int. J. Comput. Vis. 79(1), 1–12 (2008)</li>
<li>Jain, A.K., Ross, A.A., Nandakumar, K.: Introduction to Biometrics, 1st edn. Springer (2011)</li>
<li>Burghardt, T., Damen, D., Mayol-Cuevas, W., Mirmehdi, M.: Correspondence, matching and recognition. Int. J. Comput. Vis. 113(3), 161–162 (2015)</li>
<li>Bouchiha, R., Besbes, K.: Comparison of local descriptors for automatic remote sensing image registration. SIViP 9(2), 463–469 (2015)</li>
<li>Zhao, Q., Feng, W., Wan, L., Zhang, J.: SPHORB: a fast and robust binary feature on the sphere. Int. J. Comput. Vis. 113(2), 143–159 (2015)</li>
<li>Zhang, S., Tian, Q., Huang, Q., Gao, W., Rui, Y.: USB: ultrashort binary descriptor for fast visual matching and retrieval. IEEE Trans. Image Process. 23(8), 3671–3683 (2014)</li>
<li>Tuytelaars, T., Mikolajczyk, K.: Local invariant feature detectors: a survey. Found. Trends Comput. Graph. Vis. 3(3), 177–280 (2007)</li>
<li>Chen, J., Shan, S., He, C., Zhao, G., Pietikäinen, M., Chen, X., Gao, W.: WLD: a robust local image descriptor. IEEE Trans. Pattern Anal. Mach. Intell. 32(9), 1705–1720 (2010)</li>
<li>Viola, P., Jones, M.J.: Robust real-time face detection. Int. J. Comput. Vis. 57(2), 137–154 (2004)</li>
<li>Janan, F., Brady, M.: Shape description and matching using integral invariants on eccentricity transformed images. Int. J. Comput. Vis. 113(2), 92–112 (2015)</li>
<li>Lowe, D.G.: Distinctive image features from scale-invariant keypoints. Int. J. Comput. Vis. 60(2), 91–110 (2004)</li>
<li>Bay, H., Ess, A., Tuytelaars, T., Gool, L.: Speeded-up robust features (SURF). Comput. Vis. Image Underst. 110(3), 346–359 (2008)</li>
<li>Oliva, A., Torralba, A.: Modeling the shape of the scene: a holistic representation of the spatial envelope. Int. J. Comput. Vis. 42(3), 145–175 (2001)</li>
<li>Bianco, S., Mazzini, D., Pau, D., Schettini, R.: Local detectors and compact descriptors for visual search: a quantitative comparison. Digital Signal Process. 44, 1–13 (2015)</li>
<li>Jégou, H., Perronnin, F., Douze, M., Sánchez, J., Pérez, P., Schmid, C.: Aggregating local descriptors into a compact codes. IEEE Trans. Pattern Anal. Mach. Intell. 34(9), 1704–1716 (2012)</li>
<li>Lindeberg, T.: Feature detection with automatic scale selection. Int. J. Comput. Vis. 30(2), 79–116 (1998)</li>
<li>Moravec, H.P.: Towards automatic visual obstacle avoidance. In: 5th International Joint Conference on Artificial Intelligence, pp. 584–594 (1977)</li>
<li>Harris, C., Stephens, M.: A combined corner and edge detector. In: The Fourth Alvey Vision Conference, pp. 147–151. Manchester, UK (1988)</li>
<li>Smith, S.M., Brady, J.M.: A new approach to low level image processing. Int. J. Comput. Vis. 23(1), 45–78 (1997)</li>
<li><p>Rosten, E., Drummond, T.: Fusing points and lines for high performance tracking. In: International Conference on Computer Vision (ICCV’05), pp. 1508–1515. Beijing, China, 17–21 Oct 2005</p></li>
<li>Rosten, E., Drummond, T.: Machine learning for high speed corner detection. In: 9th European Conference on Computer Vision (ECCV’06), pp. 430–443. Graz, Austria, 7–13 May 2006</li>
<li>Beaudet, P.R.: Rotationally invariant image operators. In: International Joint Conference on Pattern Recognition, pp. 579–583 (1978)</li>
<li>Lakemond, R., Sridharan, S., Fookes, C.: Hessian-based affine adaptation of salient local image features. J. Math. Imaging Vis. 44(2), 150–167 (2012)</li>
<li>Mikolajczyk, K., Tuytelaars, T., Schmid, C., Zisserman, A., Matas, J., Schaffalitzky, F., Kadir, T., Gool, L.: A comparison of affine region detectors. Int. J. Comput. Vis. 65(1/2), 43–72 (2005)</li>
<li>Mikolajczyk, K., Schmid, C.: Scale &amp; affine invariant interest point detectors. Int. J. Comput. Vis. 60(1), 63–86 (2004)</li>
<li>Lindeberg, T.: Scale selection properties of generalized scale-space interest point detectors. J. Math. Imaging Vis. 46(2), 177–210 (2013)</li>
<li>Yussof, W., Hitam, M.: Invariant Gabor-based interest points detector under geometric transformation. Digital Signal Process. 25, 190–197 (2014)</li>
<li>Schaffalitzky, F., Zisserman, A.: Multi-view matching for unordered image sets. In: European Conference on Computer Vision (ECCV), pp. 414–431. Copenhagen, Denmark, 28–31 May 2002</li>
<li>Lindeberg, T., Gårding, J.: Shape-adapted smoothing in estimation of 3-D shape cues from affine deformations of local 2-D brightness structure. Image Vis. Comput. 15(6), 415–434 (1997)</li>
<li>Mikolajczyk, K., Schmid, C.: A performance evaluation of local descriptors. IEEE Trans. Pattern Anal. Mach. Intell. 27(10), 1615–1630 (2005)</li>
<li>Matas, J., Chum, O., Urban, M., Pajdla, T.: Robust wide baseline stereo from maximally stable extremal regions. In. In British Machine Vision Conference (BMV), pp. 384–393 (2002)</li>
<li>Matas, J., Ondrej, C., Urban, M., Pajdla, T.: Robust wide-baseline stereo from maximally stable extremal regions. Image Vis. Comput. 22(10), 761–767 (2004)</li>
<li>Li, J., Allinson, N.: A comprehensive review of current local features for computer vision. Neurocomputing 71(10–12), 1771–1787 (2008)</li>
<li>Ke, Y., Sukthankar, R.: PCA-SIFT: a more distinctive representation for local image descriptors. In: IEEE Conference on Computer Vision and Pattern Recognition (CVPR’04), pp. 506–513. Washington, DC, USA, 27 June–2 July 2004</li>
<li>Morel, J., Yu, G.: ASIFT: a new framework for fully affine invariant image comparison. SIAM J. Imaging Sci. 2(2), 438–469 (2009)</li>
<li>Pang, Y., Li, W., Yuan, Y., Pan, J.: Fully affine invariant SURF for image matching. Neurocomputing 85, 6–10 (2012)</li>
<li>Ojala, T., Pietikäinen, M., Mäenpää, M.: Multiresolution gray-scale and rotation invariant texture classification with local binary patterns. IEEE Trans. Pattern Anal. Mach. Intell. 24(7), 971–987 (2002)</li>
<li>Heikkiläa, M., Pietikäinen, M., Schmid, C.: Description of interest regions with local binary patterns. Pattern Recogn. 42(3), 425–436 (2009)</li>
<li>Tian, H., Fang, Y., Zhao, Y., Lin, W., Ni, R., Zhu, Z.: Salient region detection by fusing bottomup and top-down features extracted from a single image. IEEE Trans. Image Process. 23(10), 4389–4398 (2014)</li>
<li>Huang, M., Mu, Z., Zeng, H., Huang, S.: Local image region description using orthogonal symmetric local ternary pattern. Pattern Recogn. Lett. 54(1), 56–62 (2015)</li>
<li>Hong, X., Zhao, G., Pietikäinen, M., Chen, X.: Combining LBP difference and feature correlation for texture description. IEEE Trans. Image Process. 23(6), 2557–2568 (2014)</li>
<li>Calonder, M., Lepetit, V., Özuysal, M., Trzcinski, T., Strecha, C., Fua, P.: BRIEF: computing a local binary descriptor very fast. IEEE Trans. Pattern Anal. Mach. Intell. 34(7), 1281–1298 (2012)</li>
<li>Van De Weijer, J., Schmid, C.: Coloring local feature extraction. In: European Conference on Computer Vision (ECCV), pp. 334–348. Graz, Austria, 7–13 May 2006</li>
<li>Subrahmanyam, M., Gonde, A.B., Maheshwari, R.P.: Color and texture features for image indexing and retrieval. In: IEEE International Advance Computing Conference (IACC), pp.1411–1416. Patiala, India, 6–7 Mar 2009</li>
<li>Zhang, Y., Tian, T., Tian, J., Gong, J., Ming, D.: A novel biologically inspired local feature descriptor. Biol. Cybern. 108(3), 275–290 (2014)</li>
<li>Chen, Z., Sun, S.: A Zernike moment phase-based descriptor for local image representation and matching. IEEE Trans. Image Process. 19(1), 205–219 (2010)</li>
<li>Chen, B., Shu, H., Zhang, H., Coatrieux, G., Luo, L., Coatrieux, J.: Combined invariants to similarity transformation and to blur using orthogonal Zernike moments. IEEE Trans. Image Process. 20(2), 345–360 (2011)</li>
<li>Freeman, W., Adelson, E.: The design and use of steerable filters. IEEE Trans. Pattern Anal. Mach. Intell. 13(9), 891–906 (1991)</li>
<li>Liu, J., Zeng, G., Fan, J.: Fast local self-similarity for describing interest regions. Pattern Recogn. Lett. 33(9), 1224–1235 (2012)</li>
<li>Huang, D., Chao, Z., Yunhong, W., Liming, C.: HSOG: a novel local image descriptor based on histograms of the second-order gradients. IEEE Trans. Image Process. 23(11), 4680–4695 (2014)</li>
<li>Dalal, N., Triggs, B.: Histograms of oriented gradients for human detection. In: IEEE Conference on Computer Vision and Pattern Recognition (CVPR’05), pp. 886–893. San Diego, CA, USA, 20–26 June 2005</li>
<li>Fan, B., Wu, F., Hu, Z.: Rotationally invariant descriptors using intensity order pooling. IEEE Trans. Pattern Anal. Mach. Intell. 34(10), 2031–2045 (2012)</li>
<li>Al-Temeemy, A.A., Spencer, J.W.: Invariant chromatic descriptor for LADAR data processing. Mach. Vis. Appl. 26(5), 649–660 (2015)</li>
<li>Figat, J., Kornuta, T., Kasprzak, W.: Performance evaluation of binary descriptors of local features. Lect. Notes Comput. Sci. (LNCS) 8671, 187–194 (2014)</li>
<li>Burghouts, G., Geusebroek, J.M.: Performance evaluation of local color invariantss. Comput. Vis. Image Underst. 113(1), 48–62 (2009)</li>
<li>Moreels, P., Perona, P.: Evaluation of features detectors and descriptors based on 3D objects. Int. J. Comput. Vis. 73(2), 263–284 (2007)</li>
<li>Guo, Y., Bennamoun, M., Sohel, F., Lu, M., Wan, J., Kwok, N.M.: A comprehensive performance evaluation of 3D local feature descriptors. Int. J. Comput. Vis. First online, 1–24 (2015)</li>
<li>Muja, M., Lowe, D.G.: Scalable nearest neighbor algorithms for high dimensional data. IEEE Trans. Pattern Anal. Mach. Intell. 36(11), 2227–2240 (2014)</li>
<li>Szeliski, R.: Computer Vision: Algorithms and Applications. Springer, USA (2011)</li>
<li>Muja, M., David G. Lowe: Fast matching of binary features. In: IEEE Conference on Computer Vision and Pattern Recognition (CVPR’12), pp. 404–410. Toronto, ON, USA, 28–30 May 2012</li>
<li>Nister, D., Stewenius, H.: Scalable recognition with a vocabulary tree. In: IEEE Conference on Computer Vision and Pattern Recognition (CVPR’06), pp. 2161–2168. Washington, DC, USA, 17–22 June 2006</li>
<li>Yan, C.C., Xie, H., Zhang, B., Ma, Y., Dai, Q., Liu, Y.: Fast approximate matching of binary codes with distinctive bits. Frontiers Comput. Sci. 9(5), 741–750 (2015)</li>
<li>Lindeberg, T.: Image matching using generalized scale-space interest points. J. Math. Imaging Vis. 52(1), 3–36 (2015)</li>
<li><p>The oxford data set is available at (last visit, Oct. 2015) <span class="exturl" data-url="aHR0cDovL3d3dy5yb2JvdHMub3guYWMudWsvfnZnZy9kYXRhL2FmZmluZS8=">http://www.robots.ox.ac.uk/~vgg/data/affine/<i class="fa fa-external-link-alt"></i></span></p></li>
</ol>
<hr />
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>研究在两个相机位置产生的两幅图像的之间存在的特殊几何关系<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>即仿射不变性包含了尺度不变，仿射会改变不同方向的尺度，即不均匀地缩放，尺度不变是均匀地缩放<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>四边形变为平行四边形的变换，仿射变换其实就是一个线性变换和一个平移<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>这里使用8个方向作为改变依据，但旋转会改变这8个离散方向所代表的原有方向<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>这里原文有点错误（或者他想表达的是卷积操作），可参考http://dept.me.umn.edu/courses/me5286/vision/Notes/2015/ME5286-Lecture8.pdf<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>具有旋转不变性，部分光照变化不变性（兴趣点数量会发生改变），不具备尺度不变性，因为依然单尺度的<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>翻译为最小核值相似区或者最小同值分割吸收核<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p>参考 https://www.cnblogs.com/ronny/p/4078710.html<a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p>也就是首先对一组测试图像使用完整的 FAST 算法，然后使用 ID3 得到16像素中亮，暗，相似像素数量和是否是角点的关系，之后就可以直接判断 16 像素中这三种像素的数量直接判断角点<a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p>海森矩阵参考 https://blog.csdn.net/u013921430/article/details/79770458<a href="#fnref10" class="footnote-back">↩</a></p></li>
<li id="fn11"><p>具有最大 LoG 响应的尺度<a href="#fnref11" class="footnote-back">↩</a></p></li>
<li id="fn12"><p>位置代表的是图像空间，尺度代表的是尺度空间，尺度为1维，图像为2维，组成3维<a href="#fnref12" class="footnote-back">↩</a></p></li>
<li id="fn13"><p>可参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcm9ubnkvcC80MDA5NDI1Lmh0bWw=">Harris角点 - ☆Ronny丶 - 博客园 (cnblogs.com)<i class="fa fa-external-link-alt"></i></span><a href="#fnref13" class="footnote-back">↩</a></p></li>
<li id="fn14"><p>这里也就是说需要在尺度空间获得最大值，尺度不变性需要同时满足尺度空间 LoG 最大响应以及图像空间极值条件<a href="#fnref14" class="footnote-back">↩</a></p></li>
<li id="fn15"><p>这个是真不懂 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd3hsODQ1MjM1ODAwL3AvMTA3MTE4NTguaHRtbA==">小波变换——哈尔小波，Haar - ostartech - 博客园 (cnblogs.com)<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzI3NjQzMjc1L2FydGljbGUvZGV0YWlscy84NDgyNjc3Mw==">【小波变换】小波变换入门----haar小波-筱-CSDN博客-haar小波<i class="fa fa-external-link-alt"></i></span><a href="#fnref15" class="footnote-back">↩</a></p></li>
<li id="fn16"><p>即值大于最大值 0.2 的值截断为最大值的 0.2<a href="#fnref16" class="footnote-back">↩</a></p></li>
<li id="fn17"><p>两个字之间对应位不同的数量<a href="#fnref17" class="footnote-back">↩</a></p></li>
<li id="fn18"><p>感觉这里是某一个点的一组描述符<a href="#fnref18" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
      </categories>
      <tags>
        <tag>特征检测</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title>霍夫变换直线检测原理实现</title>
    <url>/2020/12/31/2020-12-31-HoughTransform/</url>
    <content><![CDATA[<h2 id="简单介绍">简单介绍</h2>
<p>霍夫变换可以用于边缘检测，更一般的则可以拟合曲线。基本原理如下：由曲线的定义式可得如XY确定，其对应的未知数构成的等式也可视作一个曲线表达式，这个新的表达式称作<strong>参数空间</strong>（自变量为原来的参数）改变 XY 的过程中这些位置构成的新的表达式必会都经过某一个固定点，这个固定点代表的参数就是原来曲线表达式。</p>
<a id="more"></a>
<p>但实际上的曲线会受到噪声影响，也就是说参数空间中所有的表达式并不会经过同一点，而是大部分曲线会经过某一固定点，这个固定点可能不止一个，所以我们将参数空间切分为一个个子区域，并统计子区域中线的交点（也可以直接统计线的点数，只要代表密度即可），交点最多的那个区域就是原曲线的参数。</p>
<p>更加详细的介绍可见《数字图像处理》中文第三版 <em>P472</em> 10.2.7 边缘检测和边界检测。或参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vUG9ueXMvcC8zMTQ2NzUzLmh0bWw=">Matlab 霍夫变换 ( Hough Transform） 直线检测 - Pony_s - 博客园 (cnblogs.com)<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="代码实现">代码实现</h2>
<p>以下为 matlab 代码实现，基本实现过程如下：</p>
<ol type="1">
<li>实现生成直线</li>
<li>给直线增加噪声</li>
<li>对噪声处理后的图像生成其参数空间</li>
<li>对参数空间的所有曲线做直方图统计，得到最大数量的参数表达</li>
<li>获得拟合的直线</li>
</ol>
<p>代码如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 霍夫变换 &amp; 直线</span></span><br><span class="line"><span class="comment">% 生成直线 y = 2x + 3</span></span><br><span class="line">x = <span class="number">-5</span>:<span class="number">5</span>;</span><br><span class="line">y = <span class="number">2</span>*x + <span class="number">3</span>;</span><br><span class="line"><span class="comment">% 添加噪声</span></span><br><span class="line">y_noise = y + <span class="built_in">randn</span>(<span class="number">1</span>, <span class="built_in">size</span>(x, <span class="number">2</span>))*<span class="number">1.5</span>;</span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;霍夫变换&quot;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">% 绘制原始线和噪声后的线</span></span><br><span class="line"><span class="built_in">plot</span>(x,y, x, y_noise, <span class="string">&#x27;--+&#x27;</span>);</span><br><span class="line">title(<span class="string">&quot;直线拟合&quot;</span>);</span><br><span class="line">axis equal</span><br><span class="line">grid on</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制霍夫变换参数空间，ysin(theta)+xcos(theta) = p</span></span><br><span class="line"><span class="comment">% 设置范围</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="comment">% 设置角度范围</span></span><br><span class="line">[theta_min, theta_max] = deal(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>);</span><br><span class="line">theta = theta_min:<span class="number">0.1</span>:theta_max;</span><br><span class="line"><span class="comment">% 预开辟所有点的参数空间存储</span></span><br><span class="line">p_all = <span class="built_in">zeros</span>(<span class="built_in">size</span>(x,<span class="number">2</span>), <span class="built_in">length</span>(theta(:)));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(x, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">% 生成对应范围内的参数曲线</span></span><br><span class="line">    p = y_noise(<span class="built_in">i</span>) * <span class="built_in">sin</span>(theta) + x(<span class="built_in">i</span>) * <span class="built_in">cos</span>(theta);</span><br><span class="line">    p_all(<span class="built_in">i</span>, :) = p;</span><br><span class="line">    <span class="comment">% 绘制参数空间的曲线</span></span><br><span class="line">    <span class="built_in">plot</span>(theta, p);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">title(<span class="string">&quot;参数空间&quot;</span>);</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line">axis normal</span><br><span class="line">grid on</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">% 统计其中每个子区域中的点数，并记录最大的</span></span><br><span class="line"><span class="comment">% 这里使用直方图hist3计算</span></span><br><span class="line">theta_repeat = <span class="built_in">repmat</span>(theta, <span class="number">11</span>, <span class="number">1</span>);</span><br><span class="line">hist3([theta_repeat(:) p_all(:)], <span class="string">&#x27;CDataMode&#x27;</span>,<span class="string">&#x27;auto&#x27;</span>,<span class="string">&#x27;FaceColor&#x27;</span>,<span class="string">&#x27;interp&#x27;</span>);</span><br><span class="line">title(<span class="string">&quot;直方图统计交点最多的区域&quot;</span>);</span><br><span class="line"><span class="comment">% num 是每个bin的数量，center为对应的x,y坐标</span></span><br><span class="line">[num, center] = hist3([theta_repeat(:) p_all(:)]);</span><br><span class="line"><span class="comment">% 找到最大的那个bin的下标并获取对应的参数</span></span><br><span class="line">[<span class="built_in">i</span>, <span class="built_in">j</span>] = <span class="built_in">find</span>(num == <span class="built_in">max</span>(<span class="built_in">max</span>(num)));</span><br><span class="line">theta_best = center&#123;<span class="number">1</span>&#125;(<span class="built_in">i</span>);</span><br><span class="line">p_best = center&#123;<span class="number">2</span>&#125;(<span class="built_in">j</span>);</span><br><span class="line"><span class="comment">% 获得拟合后的直线并绘制</span></span><br><span class="line">y_simulate = (p_best - x*<span class="built_in">cos</span>(theta_best))/<span class="built_in">sin</span>(theta_best);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x, y_simulate);</span><br><span class="line"><span class="built_in">legend</span>([<span class="string">&quot;y=2x+3&quot;</span>, <span class="string">&quot;y=2x+3+noise&quot;</span>, <span class="string">&quot;simulate&quot;</span>], <span class="string">&#x27;Location&#x27;</span>, <span class="string">&#x27;northwest&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure>
<p>最后的效果如下：</p>
<p><img src="/assets/ArticleImg/2020/hough.png" /></p>
<p>其中参数空间的方框为交点比较多的，也就是比较密集的，这里有两个，代码里就取了一个，另外一个也是可以的。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
      </categories>
      <tags>
        <tag>特征检测</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
</search>
